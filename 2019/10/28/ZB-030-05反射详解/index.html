<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>ZB-030-05反射详解 | Almost</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一、Java 反射机制Java 反射机制在程序运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种 动态的获取信息 以及 动态调用对象的方法 的功能称为 java 的反射机制。 反射机制很重要的一点就是“运行时”，其使得我们可以在程序运行时加载、探索以及使用编译期间完全未知的 .class 文件。换句话说，Java 程序可以加载一个运行">
<meta name="keywords" content="oak">
<meta property="og:type" content="article">
<meta property="og:title" content="ZB-030-05反射详解">
<meta property="og:url" content="http://yoursite.com/2019/10/28/ZB-030-05反射详解/index.html">
<meta property="og:site_name" content="Almost">
<meta property="og:description" content="一、Java 反射机制Java 反射机制在程序运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种 动态的获取信息 以及 动态调用对象的方法 的功能称为 java 的反射机制。 反射机制很重要的一点就是“运行时”，其使得我们可以在程序运行时加载、探索以及使用编译期间完全未知的 .class 文件。换句话说，Java 程序可以加载一个运行">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2020-09-08T12:50:20.341Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ZB-030-05反射详解">
<meta name="twitter:description" content="一、Java 反射机制Java 反射机制在程序运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种 动态的获取信息 以及 动态调用对象的方法 的功能称为 java 的反射机制。 反射机制很重要的一点就是“运行时”，其使得我们可以在程序运行时加载、探索以及使用编译期间完全未知的 .class 文件。换句话说，Java 程序可以加载一个运行">
  
    <link rel="alternate" href="/atom.xml" title="Almost" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Almost</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-ZB-030-05反射详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/28/ZB-030-05反射详解/" class="article-date">
  <time datetime="2019-10-28T15:53:04.000Z" itemprop="datePublished">2019-10-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      ZB-030-05反射详解
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一、Java-反射机制"><a href="#一、Java-反射机制" class="headerlink" title="一、Java 反射机制"></a>一、Java 反射机制</h3><p>Java 反射机制在程序运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种 <strong>动态的获取信息</strong> 以及 <strong>动态调用对象的方法</strong> 的功能称为 <strong>java 的反射机制</strong>。</p>
<p>反射机制很重要的一点就是“运行时”，其使得我们可以在程序运行时加载、探索以及使用编译期间完全未知的 .class 文件。换句话说，Java 程序可以加载一个运行时才得知名称的 .class 文件，然后获悉其完整构造，并生成其对象实体、或对其 fields（变量）设值、或调用其 methods（方法）。</p>
<h3 id="二、使用反射获取类的信息"><a href="#二、使用反射获取类的信息" class="headerlink" title="二、使用反射获取类的信息"></a>二、使用反射获取类的信息</h3><p>为使得测试结果更加明显，我首先定义了一个 <code>FatherClass</code> 类（默认继承自 Object 类），然后定义一个继承自 <code>FatherClass</code> 类的 <code>SonClass</code> 类，如下所示。可以看到测试类中变量以及方法的访问权限不是很规范，是为了更明显得查看测试结果而故意设置的，实际项目中不提倡这么写。</p>
<p><strong>FatherClass.java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class FatherClass &#123;</span><br><span class="line">    public String mFatherName;</span><br><span class="line">    public int mFatherAge;</span><br><span class="line"></span><br><span class="line">    public void printFatherMsg()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>SonClass.java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class SonClass extends FatherClass&#123;</span><br><span class="line"></span><br><span class="line">    private String mSonName;</span><br><span class="line">    protected int mSonAge;</span><br><span class="line">    public String mSonBirthday;</span><br><span class="line"></span><br><span class="line">    public void printSonMsg()&#123;</span><br><span class="line">        System.out.println(&quot;Son Msg - name : &quot;</span><br><span class="line">                + mSonName + &quot;; age : &quot; + mSonAge);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setSonName(String name)&#123;</span><br><span class="line">        mSonName = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setSonAge(int age)&#123;</span><br><span class="line">        mSonAge = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int getSonAge()&#123;</span><br><span class="line">        return mSonAge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String getSonName()&#123;</span><br><span class="line">        return mSonName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-获取类的所有变量信息"><a href="#1-获取类的所有变量信息" class="headerlink" title="1.获取类的所有变量信息"></a>1.获取类的所有变量信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 通过反射获取类的所有变量</span><br><span class="line"> */</span><br><span class="line">private static void printFields()&#123;</span><br><span class="line">    //1.获取并输出类的名称</span><br><span class="line">    Class mClass = SonClass.class;</span><br><span class="line">    System.out.println(&quot;类的名称：&quot; + mClass.getName());</span><br><span class="line"></span><br><span class="line">    //2.1 获取所有 public 访问权限的变量</span><br><span class="line">    // 包括本类声明的和从父类继承的</span><br><span class="line">    Field[] fields = mClass.getFields();</span><br><span class="line"></span><br><span class="line">    //2.2 获取所有本类声明的变量（不问访问权限）</span><br><span class="line">    //Field[] fields = mClass.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">    //3. 遍历变量并输出变量信息</span><br><span class="line">    for (Field field :</span><br><span class="line">            fields) &#123;</span><br><span class="line">        //获取访问权限并输出</span><br><span class="line">        int modifiers = field.getModifiers();</span><br><span class="line">        System.out.print(Modifier.toString(modifiers) + &quot; &quot;);</span><br><span class="line">        //输出变量的类型及变量名</span><br><span class="line">        System.out.println(field.getType().getName()</span><br><span class="line">                 + &quot; &quot; + field.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码注释很详细，就不再解释了。需要注意的是注释中 2.1 的 <code>getFields()</code> 与 2.2的 <code>getDeclaredFields()</code> 之间的区别，下面分别看一下两种情况下的输出。看之前强调一下：<code>SonClass extends FatherClass extends  Object</code> ：</p>
<ul>
<li><p>调用 <code>getFields()</code> 方法，输出 <code>SonClass</code> 类以及其所继承的父类( 包括 <code>FatherClass</code> 和 Object ) 的 public 方法。注：Object 类中没有成员变量，所以没有输出</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类的名称：obj.SonClass</span><br><span class="line">public java.lang.String mSonBirthday</span><br><span class="line">public java.lang.String mFatherName</span><br><span class="line">public int mFatherAge</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用 <code>getDeclaredFields()</code> ， 输出 SonClass 类的所有成员变量，不问访问权限。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类的名称：obj.SonClass</span><br><span class="line">private java.lang.String mSonName</span><br><span class="line">protected int mSonAge</span><br><span class="line">public java.lang.String mSonBirthday</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-获取类的所有方法信息"><a href="#2-获取类的所有方法信息" class="headerlink" title="2. 获取类的所有方法信息"></a>2. 获取类的所有方法信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 通过反射获取类的所有方法</span><br><span class="line"> */</span><br><span class="line">private static void printMethods()&#123;</span><br><span class="line">    //1.获取并输出类的名称</span><br><span class="line">    Class mClass = SonClass.class;</span><br><span class="line">    System.out.println(&quot;类的名称：&quot; + mClass.getName());</span><br><span class="line"></span><br><span class="line">    //2.1 获取所有 public 访问权限的方法</span><br><span class="line">    //包括自己声明和从父类继承的</span><br><span class="line">    Method[] mMethods = mClass.getMethods();</span><br><span class="line"></span><br><span class="line">    //2.2 获取所有本类的的方法（不问访问权限）</span><br><span class="line">    //Method[] mMethods = mClass.getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">    //3.遍历所有方法</span><br><span class="line">    for (Method method :</span><br><span class="line">            mMethods) &#123;</span><br><span class="line">        //获取并输出方法的访问权限（Modifiers：修饰符）</span><br><span class="line">        int modifiers = method.getModifiers();</span><br><span class="line">        System.out.print(Modifier.toString(modifiers) + &quot; &quot;);</span><br><span class="line">        //获取并输出方法的返回值类型</span><br><span class="line">        Class returnType = method.getReturnType();</span><br><span class="line">        System.out.print(returnType.getName() + &quot; &quot;</span><br><span class="line">                + method.getName() + &quot;( &quot;);</span><br><span class="line">        //获取并输出方法的所有参数</span><br><span class="line">        Parameter[] parameters = method.getParameters();</span><br><span class="line">        for (Parameter parameter:</span><br><span class="line">             parameters) &#123;</span><br><span class="line">            System.out.print(parameter.getType().getName()</span><br><span class="line">                    + &quot; &quot; + parameter.getName() + &quot;,&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //获取并输出方法抛出的异常</span><br><span class="line">        Class[] exceptionTypes = method.getExceptionTypes();</span><br><span class="line">        if (exceptionTypes.length == 0)&#123;</span><br><span class="line">            System.out.println(&quot; )&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            for (Class c : exceptionTypes) &#123;</span><br><span class="line">                System.out.println(&quot; ) throws &quot;</span><br><span class="line">                        + c.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同获取变量信息一样，需要注意注释中 2.1 与 2.2 的区别，下面看一下打印输出：</p>
<ul>
<li><p>调用 <code>getMethods()</code> 方法</p>
<ul>
<li><p>获取 SonClass 类所有 public 访问权限的方法，包括从父类继承的。打印信息中，printSonMsg() 方法来自 SonClass 类， printFatherMsg() 来自 FatherClass 类，其余方法来自 Object 类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">类的名称：obj.SonClass</span><br><span class="line">public void printSonMsg(  )</span><br><span class="line">public void printFatherMsg(  )</span><br><span class="line">public final void wait(  ) throws java.lang.InterruptedException</span><br><span class="line">public final void wait( long arg0,int arg1, ) throws java.lang.InterruptedException</span><br><span class="line">public final native void wait( long arg0, ) throws java.lang.InterruptedException</span><br><span class="line">public boolean equals( java.lang.Object arg0, )</span><br><span class="line">public java.lang.String toString(  )</span><br><span class="line">public native int hashCode(  )</span><br><span class="line">public final native java.lang.Class getClass(  )</span><br><span class="line">public final native void notify(  )</span><br><span class="line">public final native void notifyAll(  )</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>调用 <code>getDeclaredMethods()</code> 方法</p>
<ul>
<li>打印信息中，输出的都是 <code>SonClass</code> 类的方法，不问访问权限。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">类的名称：obj.SonClass</span><br><span class="line">private int getSonAge(  )</span><br><span class="line">private void setSonAge( int arg0, )</span><br><span class="line">public void printSonMsg(  )</span><br><span class="line">private void setSonName( java.lang.String arg0, )</span><br><span class="line">private java.lang.String getSonName(  )</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="三、访问或操作类的私有变量和方法"><a href="#三、访问或操作类的私有变量和方法" class="headerlink" title="三、访问或操作类的私有变量和方法"></a>三、访问或操作类的私有变量和方法</h3><p>在上面，我们成功获取了类的变量和方法信息，验证了在运行时   <strong>动态的获取信息</strong>  的观点。那么，仅仅是获取信息吗？我们接着往后看。</p>
<p>都知道，对象是无法访问或操作类的私有变量和方法的，但是，通过反射，我们就可以做到。没错，反射可以做到！下面，让我们一起探讨如何利用反射访问 <strong>类对象的私有方法</strong> 以及修改 <strong>私有变量或常量</strong>。</p>
<p>老规矩，先上测试类。</p>
<p>注：</p>
<ol>
<li>请注意看测试类中变量和方法的修饰符（访问权限）；</li>
<li>测试类仅供测试，不提倡实际开发时这么写 : )</li>
</ol>
<p><strong>TestClass.java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class TestClass &#123;</span><br><span class="line"></span><br><span class="line">    private String MSG = &quot;Original&quot;;</span><br><span class="line"></span><br><span class="line">    private void privateMethod(String head , int tail)&#123;</span><br><span class="line">        System.out.print(head + tail);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMsg()&#123;</span><br><span class="line">        return MSG;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-访问私有方法"><a href="#3-1-访问私有方法" class="headerlink" title="3.1 访问私有方法"></a>3.1 访问私有方法</h4><p>以访问 <code>TestClass</code> 类中的私有方法 <code>privateMethod(...)</code> 为例，方法加参数是为了考虑最全的情况，很贴心有木有？先贴代码，看注释，最后我会重点解释部分代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 访问对象的私有方法</span><br><span class="line"> * 为简洁代码，在方法上抛出总的异常，实际开发别这样</span><br><span class="line"> */</span><br><span class="line">private static void getPrivateMethod() throws Exception&#123;</span><br><span class="line">    //1. 获取 Class 类实例</span><br><span class="line">    TestClass testClass = new TestClass();</span><br><span class="line">    Class mClass = testClass.getClass();</span><br><span class="line"></span><br><span class="line">    //2. 获取私有方法</span><br><span class="line">    //第一个参数为要获取的私有方法的名称</span><br><span class="line">    //第二个为要获取方法的参数的类型，参数为 Class...，没有参数就是null</span><br><span class="line">    //方法参数也可这么写 ：new Class[]&#123;String.class , int.class&#125;</span><br><span class="line">    Method privateMethod =</span><br><span class="line">            mClass.getDeclaredMethod(&quot;privateMethod&quot;, String.class, int.class);</span><br><span class="line"></span><br><span class="line">    //3. 开始操作方法</span><br><span class="line">    if (privateMethod != null) &#123;</span><br><span class="line">        //获取私有方法的访问权</span><br><span class="line">        //只是获取访问权，并不是修改实际权限</span><br><span class="line">        privateMethod.setAccessible(true);</span><br><span class="line"></span><br><span class="line">        //使用 invoke 反射调用私有方法</span><br><span class="line">        //privateMethod 是获取到的私有方法</span><br><span class="line">        //testClass 要操作的对象</span><br><span class="line">        //后面两个参数传实参</span><br><span class="line">        privateMethod.invoke(testClass, &quot;Java Reflect &quot;, 666);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，第3步中的 <code>setAccessible(true)</code> 方法，是获取私有方法的访问权限，如果不加会报异常 <strong>IllegalAccessException</strong>，因为当前方法访问权限是“private”的，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalAccessException: Class MainClass can not access a member of class obj.TestClass with modifiers &quot;private&quot;</span><br></pre></td></tr></table></figure>
<p>正常运行后，打印如下，调用私有方法成功：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java Reflect 666</span><br></pre></td></tr></table></figure>
<h4 id="3-2-修改私有变量"><a href="#3-2-修改私有变量" class="headerlink" title="3.2 修改私有变量"></a>3.2 修改私有变量</h4><p>以修改 <code>TestClass</code> 类中的私有变量 <code>MSG</code> 为例，其初始值为 “Original” ，我们要修改为 “Modified”。老规矩，先上代码看注释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 修改对象私有变量的值</span><br><span class="line"> * 为简洁代码，在方法上抛出总的异常</span><br><span class="line"> */</span><br><span class="line">private static void modifyPrivateFiled() throws Exception &#123;</span><br><span class="line">    //1. 获取 Class 类实例</span><br><span class="line">    TestClass testClass = new TestClass();</span><br><span class="line">    Class mClass = testClass.getClass();</span><br><span class="line"></span><br><span class="line">    //2. 获取私有变量</span><br><span class="line">    Field privateField = mClass.getDeclaredField(&quot;MSG&quot;);</span><br><span class="line"></span><br><span class="line">    //3. 操作私有变量</span><br><span class="line">    if (privateField != null) &#123;</span><br><span class="line">        //获取私有变量的访问权</span><br><span class="line">        privateField.setAccessible(true);</span><br><span class="line"></span><br><span class="line">        //修改私有变量，并输出以测试</span><br><span class="line">        System.out.println(&quot;Before Modify：MSG = &quot; + testClass.getMsg());</span><br><span class="line"></span><br><span class="line">        //调用 set(object , value) 修改变量的值</span><br><span class="line">        //privateField 是获取到的私有变量</span><br><span class="line">        //testClass 要操作的对象</span><br><span class="line">        //&quot;Modified&quot; 为要修改成的值</span><br><span class="line">        privateField.set(testClass, &quot;Modified&quot;);</span><br><span class="line">        System.out.println(&quot;After Modify：MSG = &quot; + testClass.getMsg());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处代码和访问私有方法的逻辑差不多，就不再赘述，从输出信息看出 <strong>修改私有变量</strong> 成功：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Before Modify：MSG = Original</span><br><span class="line">After Modify：MSG = Modified</span><br></pre></td></tr></table></figure>
<h4 id="3-3-修改私有常量"><a href="#3-3-修改私有常量" class="headerlink" title="3.3 修改私有常量"></a>3.3 修改私有常量</h4><blockquote>
<p>01.真的能修改吗？</p>
</blockquote>
<p>常量是指使用 <code>final</code> 修饰符修饰的成员属性，与变量的区别就在于有无 final 关键字修饰。在说之前，先补充一个知识点。<br>Java 虚拟机（JVM）在编译 .java 文件得到 .class 文件时，会优化我们的代码以提升效率。其中一个优化就是：JVM 在编译阶段会把引用常量的代码替换成具体的常量值，如下所示（部分代码）。</p>
<p>编译前的 .java 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//注意是 String  类型的值</span><br><span class="line">private final String FINAL_VALUE = &quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">if(FINAL_VALUE.equals(&quot;world&quot;))&#123;</span><br><span class="line">    //do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后得到的 .class 文件（当然，编译后是没有注释的）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private final String FINAL_VALUE = &quot;hello&quot;;</span><br><span class="line">//替换为&quot;hello&quot;</span><br><span class="line">if(&quot;hello&quot;.equals(&quot;world&quot;))&#123;</span><br><span class="line">    //do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，并不是所有常量都会优化。经测试对于 int 、long 、boolean 以及 String 这些基本类型 JVM 会优化，而对于 Integer 、Long 、Boolean 这种包装类型，或者其他诸如 Date 、Object 类型则不会被优化。</p>
<p>总结来说：<strong>对于基本类型的静态常量，JVM 在编译阶段会把引用此常量的代码替换成具体的常量值。</strong></p>
<p>这么说来，在实际开发中，如果我们想修改某个类的常量值，恰好那个常量是基本类型的，岂不是无能为力了？反正我个人认为除非修改源码，否则真没办法！</p>
<p>这里所谓的无能为力是指：<strong>我们在程序运行时刻依然可以使用反射修改常量的值（后面会代码验证），但是 JVM 在编译阶段得到的 .class 文件已经将常量优化为具体的值，在运行阶段就直接使用具体的值了，所以即使修改了常量的值也已经毫无意义了。</strong></p>
<p>下面我们验证这一点，在测试类 TestClass 类中添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//String 会被 JVM 优化</span><br><span class="line">private final String FINAL_VALUE = &quot;FINAL&quot;;</span><br><span class="line"></span><br><span class="line">public String getFinalValue()&#123;</span><br><span class="line">    //剧透，会被优化为: return &quot;FINAL&quot; ,拭目以待吧</span><br><span class="line">    return FINAL_VALUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，是修改常量的值，先上代码，请仔细看注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 修改对象私有常量的值</span><br><span class="line"> * 为简洁代码，在方法上抛出总的异常，实际开发别这样</span><br><span class="line"> */</span><br><span class="line">private static void modifyFinalFiled() throws Exception &#123;</span><br><span class="line">    //1. 获取 Class 类实例</span><br><span class="line">    TestClass testClass = new TestClass();</span><br><span class="line">    Class mClass = testClass.getClass();</span><br><span class="line"></span><br><span class="line">    //2. 获取私有常量</span><br><span class="line">    Field finalField = mClass.getDeclaredField(&quot;FINAL_VALUE&quot;);</span><br><span class="line"></span><br><span class="line">    //3. 修改常量的值</span><br><span class="line">    if (finalField != null) &#123;</span><br><span class="line"></span><br><span class="line">        //获取私有常量的访问权</span><br><span class="line">        finalField.setAccessible(true);</span><br><span class="line"></span><br><span class="line">        //调用 finalField 的 getter 方法</span><br><span class="line">        //输出 FINAL_VALUE 修改前的值</span><br><span class="line">        System.out.println(&quot;Before Modify：FINAL_VALUE = &quot;</span><br><span class="line">                + finalField.get(testClass));</span><br><span class="line"></span><br><span class="line">        //修改私有常量</span><br><span class="line">        finalField.set(testClass, &quot;Modified&quot;);</span><br><span class="line"></span><br><span class="line">        //调用 finalField 的 getter 方法</span><br><span class="line">        //输出 FINAL_VALUE 修改后的值</span><br><span class="line">        System.out.println(&quot;After Modify：FINAL_VALUE = &quot;</span><br><span class="line">                + finalField.get(testClass));</span><br><span class="line"></span><br><span class="line">        //使用对象调用类的 getter 方法</span><br><span class="line">        //获取值并输出</span><br><span class="line">        System.out.println(&quot;Actually ：FINAL_VALUE = &quot;</span><br><span class="line">                + testClass.getFinalValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码不解释了，注释巨详细有木有！特别注意一下第3步的注释，然后来看看输出，已经迫不及待了，擦亮双眼：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before Modify：FINAL_VALUE = FINAL</span><br><span class="line">After Modify：FINAL_VALUE = Modified</span><br><span class="line">Actually ：FINAL_VALUE = FINAL</span><br></pre></td></tr></table></figure>
<p>结果出来了:</p>
<p>第一句打印修改前 FINAL_VALUE 的值，没有异议；</p>
<p>第二句打印修改后常量的值，说明FINAL_VALUE确实通过反射修改了；</p>
<p>第三句打印通过   getFinalValue() 方法获取的 FINAL_VALUE 的值，但还是初始值，导致修改无效！</p>
<p>这结果你觉得可信吗？什么，你还不信？问我怎么知道 JVM 编译后会优化代码？那要不这样吧，一起来看看 TestClass.java 文件编译后得到的 TestClass.class 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class TestClass &#123;</span><br><span class="line">    private final String FINAL_VALUE = &quot;FINAL&quot;;</span><br><span class="line"></span><br><span class="line">    public TestClass() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getFinalValue() &#123;</span><br><span class="line">        return &quot;FINAL&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到了吧，getFinalValue() 方法直接 return “FINAL”！同时也说明了，<strong>程序运行时是根据编译后的 .class 来执行的</strong>。</p>
<p>顺便提一下，如果你有时间，可以换几个数据类型试试，正如上面说的，有些数据类型是不会优化的。你可以修改数据类型后，根据我的思路试试，看输出觉得不靠谱就直接看 .classs 文件，一眼就能看出来哪些数据类型优化了 ，哪些没有优化。下面说下一个知识点。</p>
<h4 id="02-我就是要修改常量！"><a href="#02-我就是要修改常量！" class="headerlink" title="02.我就是要修改常量！"></a>02.我就是要修改常量！</h4><blockquote>
<p>方法一</p>
</blockquote>
<p>事实上，Java 允许我们声明常量时不赋值，但必须在构造函数中赋值。你可能会问我为什么要说这个，这就解释：</p>
<p>我们修改一下 TestClass 类，在声明常量时不赋值，然后添加构造函数并为其赋值，大概看一下修改后的代码（部分代码 ）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class TestClass &#123;</span><br><span class="line"></span><br><span class="line">    //......</span><br><span class="line">    private final String FINAL_VALUE;</span><br><span class="line"></span><br><span class="line">    //构造函数内为常量赋值 </span><br><span class="line">    public TestClass()&#123;</span><br><span class="line">        this.FINAL_VALUE = &quot;FINAL&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    //......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们再调用上面贴出的修改常量的方法，发现输出是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before Modify：FINAL_VALUE = FINAL</span><br><span class="line">After Modify：FINAL_VALUE = Modified</span><br><span class="line">Actually ：FINAL_VALUE = Modified</span><br></pre></td></tr></table></figure>
<p>纳尼，最后一句输出修改后的值了？对，修改成功了！还得看编译后的 TestClass.class </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class TestClass &#123;</span><br><span class="line">    private final String FINAL_VALUE = &quot;FINAL&quot;;</span><br><span class="line"></span><br><span class="line">    public TestClass() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getFinalValue() &#123;</span><br><span class="line">        return this.FINAL_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释一下：我们将赋值放在构造函数中，构造函数是我们运行时 new 对象才会调用的，所以就不会像之前直接为常量赋值那样，在编译阶段将 getFinalValue() 方法优化为返回常量值，而是指向 FINAL_VALUE ，这样我们在运行阶段通过反射修改敞亮的值就有意义啦。但是，看得出来，程序还是有优化的，将构造函数中的赋值语句优化了。再想想那句 程序运行时是根据编译后的 .class 来执行的 ，相信你一定明白为什么这么输出了！</p>
<blockquote>
<p>方法二</p>
</blockquote>
<p>请你务必将上面捋清楚了再往下看。接下来再说一种改法，不使用构造函数，也可以成功修改常量的值，但原理上都一样。去掉构造函数，将声明常量的语句改为使用三目表达式赋值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private final String FINAL_VALUE</span><br><span class="line">        = null == null ? &quot;FINAL&quot; : null;</span><br></pre></td></tr></table></figure>
<p>其实，上述代码等价于直接为 <code>FINAL_VALUE</code> 赋值 “FINAL”，但是他就是可以！至于为什么，你这么想：<code>null == null ? &quot;FINAL&quot; : null</code> 是在运行时刻计算的，在编译时刻不会计算，也就不会被优化，所以你懂得。</p>
<p>总结来说，不管使用构造函数还是三目表达式，根本上都是<strong>避免在编译时刻被优化</strong>，这样我们通过反射修改常量之后才有意义！好了，这一小部分到此结束！</p>
<blockquote>
<p>最后的强调：</p>
</blockquote>
<p>必须提醒你的是，无论<strong>直接为常量赋值 、 通过构造函数为常量赋值</strong> 还是 <strong>使用三目运算符</strong>，实际上我们都能通过反射成功修改常量的值。而我在上面说的修改”成功”与否是指：<strong>我们在程序运行阶段通过反射肯定能修改常量值，但是实际执行优化后的 .class 文件时，修改的后值真的起到作用了吗？换句话说，就是编译时是否将常量替换为具体的值了？如果替换了，再怎么修改常量的值都不会影响最终的结果了，不是吗</strong>？。</p>
<p>其实，你可以直接这么想：<strong>反射肯定能修改常量的值，但修改后的值是否有意义</strong>？</p>
<h3 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h3><ul>
<li><a href="https://juejin.im/post/5c04892351882516e70dcc9b" target="_blank" rel="noopener">老大难的 Java ClassLoader 再不理解就老了</a></li>
</ul>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ul>
<li><a href="https://github.com/hcsp/map-bean-converter" target="_blank" rel="noopener">q使用反射实现一个Java Bean到Map的转换器</a></li>
<li><a href="https://github.com/hcsp/map-bean-converter/pull/18" target="_blank" rel="noopener">a</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/10/28/ZB-030-05反射详解/" data-id="cklhjlfm300tqoyfyp85u4pql" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/oak/">oak</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/10/29/ZB-031-01为什么需要范型/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          ZB-031-01为什么需要范型
        
      </div>
    </a>
  
  
    <a href="/2019/10/28/ZB-030-04ClassLoader详解/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">ZB-030-04ClassLoader详解</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6速学/">ES6速学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS不知深浅/">JS不知深浅</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/M01/">M01</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/M02/">M02</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/M03/">M03</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/M04/">M04</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/M06/">M06</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/M07/">M07</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/M08/">M08</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/M09/">M09</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NodeWeb/">NodeWeb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node后端/">Node后端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ReactWheels/">ReactWheels</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React入门/">React入门</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TS入门/">TS入门</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/express/">express</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fullstack/">fullstack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jQuery/">jQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mobile/">mobile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb/">mongodb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/">node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node每日精进/">node每日精进</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oak/">oak</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tools/">tools</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/">vim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vultr/">vultr</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web性能优化/">web性能优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web面经/">web面经</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端知识点/">前端知识点</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 13.91px;">CSS</a> <a href="/tags/ES6速学/" style="font-size: 14.35px;">ES6速学</a> <a href="/tags/JS不知深浅/" style="font-size: 11.3px;">JS不知深浅</a> <a href="/tags/M01/" style="font-size: 13.48px;">M01</a> <a href="/tags/M02/" style="font-size: 15.22px;">M02</a> <a href="/tags/M03/" style="font-size: 15.65px;">M03</a> <a href="/tags/M04/" style="font-size: 16.09px;">M04</a> <a href="/tags/M06/" style="font-size: 18.26px;">M06</a> <a href="/tags/M07/" style="font-size: 17.83px;">M07</a> <a href="/tags/M08/" style="font-size: 16.96px;">M08</a> <a href="/tags/M09/" style="font-size: 11.74px;">M09</a> <a href="/tags/NodeWeb/" style="font-size: 15.65px;">NodeWeb</a> <a href="/tags/Node后端/" style="font-size: 18.7px;">Node后端</a> <a href="/tags/ReactWheels/" style="font-size: 16.52px;">ReactWheels</a> <a href="/tags/React入门/" style="font-size: 15.22px;">React入门</a> <a href="/tags/TS入门/" style="font-size: 14.78px;">TS入门</a> <a href="/tags/express/" style="font-size: 10.43px;">express</a> <a href="/tags/fullstack/" style="font-size: 17.83px;">fullstack</a> <a href="/tags/http/" style="font-size: 12.17px;">http</a> <a href="/tags/jQuery/" style="font-size: 10px;">jQuery</a> <a href="/tags/java/" style="font-size: 19.13px;">java</a> <a href="/tags/linux/" style="font-size: 10.87px;">linux</a> <a href="/tags/mobile/" style="font-size: 11.3px;">mobile</a> <a href="/tags/mongodb/" style="font-size: 12.61px;">mongodb</a> <a href="/tags/mysql/" style="font-size: 12.61px;">mysql</a> <a href="/tags/node/" style="font-size: 10.43px;">node</a> <a href="/tags/node每日精进/" style="font-size: 10px;">node每日精进</a> <a href="/tags/oak/" style="font-size: 20px;">oak</a> <a href="/tags/python/" style="font-size: 17.39px;">python</a> <a href="/tags/tools/" style="font-size: 10px;">tools</a> <a href="/tags/vim/" style="font-size: 10px;">vim</a> <a href="/tags/vue/" style="font-size: 13.04px;">vue</a> <a href="/tags/vultr/" style="font-size: 10px;">vultr</a> <a href="/tags/web性能优化/" style="font-size: 10px;">web性能优化</a> <a href="/tags/web面经/" style="font-size: 10px;">web面经</a> <a href="/tags/前端知识点/" style="font-size: 19.57px;">前端知识点</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/02/23/Node-web05-09-03博客系统使用nginx/">Node-web05-09-03博客系统使用nginx</a>
          </li>
        
          <li>
            <a href="/2021/02/22/Node-web05-09-02博客系统部署最新版流程/">Node-web05-09-02博客系统部署最新版流程</a>
          </li>
        
          <li>
            <a href="/2021/02/20/Node-web05-09-01博客统部署2/">Node-web05-09-01博客统部署优化解释</a>
          </li>
        
          <li>
            <a href="/2021/02/20/Node-web05-08博客统页面完善/">Node-web05-08博客统页面完善</a>
          </li>
        
          <li>
            <a href="/2021/02/19/Node-web05-07-03服务器端构建/">Node-web05-07-03服务器端构建</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Stevin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>