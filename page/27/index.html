<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Almost</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Almost">
<meta property="og:url" content="http://yoursite.com/page/27/index.html">
<meta property="og:site_name" content="Almost">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Almost">
  
    <link rel="alternate" href="/atom.xml" title="Almost" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Almost</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Py008-10-01nginx介绍" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/27/Py008-10-01nginx介绍/" class="article-date">
  <time datetime="2018-12-27T13:25:05.000Z" itemprop="datePublished">2018-12-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/27/Py008-10-01nginx介绍/">Py008-10-01nginx介绍</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="nginx-介绍"><a href="#nginx-介绍" class="headerlink" title="nginx 介绍"></a>nginx 介绍</h3><ul>
<li>一个开发高性能 web 和 反向代理服务器，也是一个 IMAP/POP3/SMTP 代理服务器</li>
<li>轻量级web服务器</li>
<li>延伸版本 tengine (淘宝) openresrt (章亦春)</li>
<li><a href="http://nginx.org" target="_blank" rel="noopener">http://nginx.org</a> 官网</li>
<li><a href="http://www.nginx.cn/doc/index.html" target="_blank" rel="noopener">http://www.nginx.cn/doc/index.html</a> 中文文档</li>
</ul>
<h4 id="nginx管理"><a href="#nginx管理" class="headerlink" title="nginx管理"></a>nginx管理</h4><ul>
<li>安装/启动</li>
<li>nginx相关目录配置</li>
<li>nginx默认网站<ul>
<li>访问控制</li>
<li>日志管理</li>
<li>防盗链</li>
</ul>
</li>
<li>nginx 虚拟主机</li>
<li>反向代理</li>
<li>URL重写</li>
<li>Nginx下载限速</li>
</ul>
<h4 id="Nginx优化"><a href="#Nginx优化" class="headerlink" title="Nginx优化"></a>Nginx优化</h4><h4 id="Nginx-负载均衡"><a href="#Nginx-负载均衡" class="headerlink" title="Nginx 负载均衡"></a>Nginx 负载均衡</h4><h4 id="Nginx-缓存"><a href="#Nginx-缓存" class="headerlink" title="Nginx 缓存"></a>Nginx 缓存</h4><h4 id="硬件配置"><a href="#硬件配置" class="headerlink" title="硬件配置"></a>硬件配置</h4><ul>
<li>Vmware 虚拟机2核 4G</li>
<li>网卡：桥接</li>
<li>系统 Centos7.5</li>
<li>关闭防火墙</li>
<li>Selinux 关闭</li>
<li>网段 192.168.10.0/24</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/27/Py008-10-01nginx介绍/" data-id="cklhjp25z00l6ulfy5icel0f2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/M08/">M08</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Py008-02-02数据结构之栈" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/13/Py008-02-02数据结构之栈/" class="article-date">
  <time datetime="2018-12-13T14:26:48.000Z" itemprop="datePublished">2018-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/13/Py008-02-02数据结构之栈/">Py008-02-02数据结构之栈</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈 Stack"></a>栈 Stack</h3><p>栈是一种数据集合，可以理解为只能在一端进行插入和删除操作的列表</p>
<blockquote>
<p>栈的特点</p>
</blockquote>
<ul>
<li>后进先出LIFO</li>
</ul>
<blockquote>
<p>栈的概念</p>
</blockquote>
<ul>
<li>栈顶</li>
<li>栈底</li>
</ul>
<blockquote>
<p>栈的基本操作</p>
</blockquote>
<ul>
<li>进栈（压栈）push</li>
<li>出栈 pop</li>
<li>取栈顶 gettop</li>
</ul>
<blockquote>
<p>生活实例</p>
</blockquote>
<ul>
<li>弹匣的  压子弹，取子弹</li>
</ul>
<blockquote>
<h4 id="栈的简单实现"><a href="#栈的简单实现" class="headerlink" title="栈的简单实现"></a>栈的简单实现</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Stack:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.stack = []</span><br><span class="line">    </span><br><span class="line">    def push(self,element):</span><br><span class="line">        self.stack.append(element)</span><br><span class="line">    </span><br><span class="line">    def pop(self,element):</span><br><span class="line">        if len(self.stack) &gt; 0:</span><br><span class="line">            return self.pop()</span><br><span class="line">        else:</span><br><span class="line">            return None</span><br><span class="line">    def get_top(self):</span><br><span class="line">        if len(self.stack) &gt; 0 :</span><br><span class="line">            return self.stack[-1]</span><br><span class="line"></span><br><span class="line">    def is_empty(self):</span><br><span class="line">        return len(self.stack) == 0</span><br></pre></td></tr></table></figure>
<h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><blockquote>
<p>括号匹配问题：给一个字符串，其中包括小括号，中括号，大括号，求该字符串中括号是否匹配</p>
</blockquote>
<p>例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">()()[]&#123;&#125; 匹配</span><br><span class="line">([&#123;()&#125;]) 匹配</span><br><span class="line">[](      不匹配</span><br><span class="line">[(])     不匹配</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Stack:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.stack = []</span><br><span class="line">    </span><br><span class="line">    def push(self,element):</span><br><span class="line">        self.stack.append(element)</span><br><span class="line">    </span><br><span class="line">    def pop(self,element):</span><br><span class="line">        if len(self.stack) &gt; 0:</span><br><span class="line">            return self.pop()</span><br><span class="line">        else:</span><br><span class="line">            return None</span><br><span class="line">    def get_top(self):</span><br><span class="line">        if len(self.stack) &gt; 0 :</span><br><span class="line">            return self.stack[-1]</span><br><span class="line"></span><br><span class="line">    def is_empty(self):</span><br><span class="line">        return len(self.stack) == 0</span><br><span class="line"></span><br><span class="line">def brace_match(s):</span><br><span class="line">    match = &#123;</span><br><span class="line">        &apos;&#125;&apos;:&apos;&#123;&apos;,</span><br><span class="line">        &apos;]&apos;:&apos;[&apos;,</span><br><span class="line">        &apos;)&apos;:&apos;(&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    stack = Stack()</span><br><span class="line">    for ch in s:</span><br><span class="line">        if ch in &#123;&apos;&#123;&apos;,&apos;[&apos;,&apos;(&apos;&#125;:</span><br><span class="line">            stack.push(ch)</span><br><span class="line">        else: # &#123;&apos;&#125;&apos;,&apos;]&apos;,&apos;)&apos;&#125;</span><br><span class="line">            if stack.is_empty():</span><br><span class="line">                return False</span><br><span class="line">            elif stack.get_top() == match[ch]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            else: # stack.get_top() != match[ch]</span><br><span class="line">                return False</span><br><span class="line">    if stack.is_empty():</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line">print(brace_match(&apos;[&#123;(&#123;[]&#125;)&#125;]&apos;))</span><br><span class="line">print(brace_match(&apos;[&#123;]&apos;))</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/13/Py008-02-02数据结构之栈/" data-id="cklhjp25y00l3ulfy59nha2gb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/M08/">M08</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Py008-02-01数据结构之列表" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/13/Py008-02-01数据结构之列表/" class="article-date">
  <time datetime="2018-12-13T13:16:59.000Z" itemprop="datePublished">2018-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/13/Py008-02-01数据结构之列表/">Py008-02-01数据结构之列表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><blockquote>
<p>相互之间存在一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成</p>
</blockquote>
<ul>
<li>数据结构就是设计数据以何种方式组织并存储在计算机中。</li>
<li>比如：列表/集合与字典等都是一种数据结构</li>
</ul>
<h4 id="数据结构的分类"><a href="#数据结构的分类" class="headerlink" title="数据结构的分类"></a>数据结构的分类</h4><ul>
<li>线性结构:数据结构中的元素存在一对一的相互关系</li>
<li>树结构：数据结构中的元素存在一对多的相互关系</li>
<li>图结构：数据结构中的元素存在多对多的相互关系</li>
</ul>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul>
<li>列表是如何存储的</li>
<li>列表的下标查找，插入，删除操作的时间复杂度</li>
<li>python的列表是如何实现的</li>
</ul>
<h4 id="列表是如何存储的"><a href="#列表是如何存储的" class="headerlink" title="列表是如何存储的"></a>列表是如何存储的</h4><ul>
<li>顺序存储，一块(一个接一个)连续的内存</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">32位机器上，一个整数四个字节32位</span><br><span class="line">在c语言里的数组</span><br><span class="line">arr = [1,2,3,4,5]</span><br><span class="line">假设arr[0] 内存地址是100</span><br><span class="line">整型变量占用4个字节</span><br><span class="line">那么a[1] 的内存地址就是104</span><br><span class="line">a[2] 的内存地址是 108 。。。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>数组和列表两点不同</p>
</blockquote>
<ul>
<li>数组元素类型要相同</li>
<li>数组长度固定</li>
</ul>
<blockquote>
<h4 id="通过li-index-的寻址过程和处理数组内数据类型不同问题"><a href="#通过li-index-的寻址过程和处理数组内数据类型不同问题" class="headerlink" title="通过li[index]的寻址过程和处理数组内数据类型不同问题"></a>通过li[index]的寻址过程和处理数组内数据类型不同问题</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">python中列表</span><br><span class="line">li = [1,2,3]</span><br><span class="line">针对常用的小整数python直接分配固定的内存</span><br><span class="line">假设分配的addr</span><br><span class="line">1 addr = 200</span><br><span class="line">2 addr = 305</span><br><span class="line">3 addr = 500</span><br><span class="line">那么 li = [1,2,3]</span><br><span class="line">32位机器上，一个整数四个字节32位</span><br><span class="line">假设li[0] 的地址为 100  它里面存的是1的内存地址200</span><br><span class="line">假设li[1] 的地址为 104  它里面存的是1的内存地址305 </span><br><span class="line">假设li[2] 的地址为 108  它里面存的是1的内存地址500</span><br><span class="line"></span><br><span class="line">这就是python列表解决 类型不同的问题</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如何解决数组动态添加元素的问题</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内存动态分配</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="append的时间复杂度"><a href="#append的时间复杂度" class="headerlink" title="append的时间复杂度"></a>append的时间复杂度</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(1)</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="插入和删除的时间复杂度"><a href="#插入和删除的时间复杂度" class="headerlink" title="插入和删除的时间复杂度"></a>插入和删除的时间复杂度</h4></blockquote>
<ul>
<li>O(n)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[1,2,3,4,5,6]</span><br><span class="line">删除第一个元素</span><br><span class="line">1后面的元素都要把地址向前迁移一位</span><br><span class="line">[2,3,4,5,6]</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/13/Py008-02-01数据结构之列表/" data-id="cklhjp25x00l2ulfy2egxo7id" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/M08/">M08</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Py008-01-12NB三人组总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/12/Py008-01-12NB三人组总结/" class="article-date">
  <time datetime="2018-12-12T15:36:44.000Z" itemprop="datePublished">2018-12-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/12/Py008-01-12NB三人组总结/">Py008-01-12NB三人组总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/slTrust/note/master/img/py/py008_01_1201.png" alt></p>
<h3 id="综合数据"><a href="#综合数据" class="headerlink" title="综合数据"></a>综合数据</h3><p><img src="https://raw.githubusercontent.com/slTrust/note/master/img/py/py008_01_1202.png" alt></p>
<blockquote>
<p>#### 空间复杂度 </p>
</blockquote>
<ul>
<li>快排和归并里有递归(递归需要压栈所有需要一定的空间)</li>
</ul>
<blockquote>
<h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4></blockquote>
<ul>
<li>挨个换   冒泡 插入 归并</li>
<li>跳着换   选择 快排 堆排序</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/12/Py008-01-12NB三人组总结/" data-id="cklhjp25w00kzulfytfpqvm7a" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/M08/">M08</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Py008-01-11归并排序之归并" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/12/Py008-01-11归并排序之归并/" class="article-date">
  <time datetime="2018-12-12T14:21:44.000Z" itemprop="datePublished">2018-12-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/12/Py008-01-11归并排序之归并/">Py008-01-11归并排序之归并</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="归并排序——归并"><a href="#归并排序——归并" class="headerlink" title="归并排序——归并"></a>归并排序——归并</h3><blockquote>
<p>假设现在有一个列表 分两段有序，如何将其合并成一个有序列表</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如[2,5,7,8,9|华丽的分割线|1,3,4,6]</span><br></pre></td></tr></table></figure>
<ul>
<li>这种操作称为一次归并</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">res = []</span><br><span class="line">两个列表分别取第一个</span><br><span class="line">[2,5,7,8,9] </span><br><span class="line">[1,3,4,6]</span><br><span class="line">2&gt;1 1出来 res = [1]</span><br><span class="line">[2,5,7,8,9] </span><br><span class="line">[3,4,6]</span><br><span class="line">2&lt;3 2出来 res = [1,2]</span><br><span class="line">[5,7,8,9] </span><br><span class="line">[3,4,6]</span><br><span class="line">5&gt;3 3出来 res = [1,2,3]</span><br><span class="line">[5,7,8,9] </span><br><span class="line">[4,6]</span><br><span class="line">5&gt;4 4出来 res = [1,2,3,4]</span><br><span class="line">[5,7,8,9] </span><br><span class="line">[6]</span><br><span class="line">5&lt;6 5出来 res = [1,2,3,4,5]</span><br><span class="line">[7,8,9] </span><br><span class="line">[6]</span><br><span class="line">7&gt;6 6出来 res = [1,2,3,4,5,6]</span><br><span class="line">[7,8,9] </span><br><span class="line">[]</span><br><span class="line">[7,8,9] 都出来 res = [1,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码实现</p>
</blockquote>
<ul>
<li>大前提：两段有序的归并</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">def merge(li,low,mid,high):</span><br><span class="line">    i = low # 第一个列表起点</span><br><span class="line">    j = mid+1 # 第二个列表起点</span><br><span class="line">    ltmp = [] # 没法用到原地排序了</span><br><span class="line">    while i&lt;=mid and j&lt;=high:# 只要左右两边都有数</span><br><span class="line">        if li[i] &lt; li[j]:</span><br><span class="line">            ltmp.append(li[i])</span><br><span class="line">            i += 1</span><br><span class="line">        else:</span><br><span class="line">            ltmp.append(li[j])</span><br><span class="line">            j += 1</span><br><span class="line"></span><br><span class="line">    # while执行完了，肯定有一头 没数了</span><br><span class="line">    while i &lt;= mid:</span><br><span class="line">        ltmp.append(li[i])</span><br><span class="line">        i += 1</span><br><span class="line">    while j &lt;= high:</span><br><span class="line">        ltmp.append(li[j])</span><br><span class="line">        j += 1</span><br><span class="line">    li[low:high+1] = ltmp</span><br><span class="line"></span><br><span class="line">li = [2,4,5,7,1,3,6,8]</span><br><span class="line">merge(li,0,3,7)</span><br><span class="line">print(li)</span><br></pre></td></tr></table></figure>
<h3 id="归并排序——使用归并"><a href="#归并排序——使用归并" class="headerlink" title="归并排序——使用归并"></a>归并排序——使用归并</h3><ul>
<li>分解：将列表越分越小，直至分成一个元素</li>
<li>终止条件：一个元素是有序的</li>
<li>合并：将两个有序列表归并，列表越来越大。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">def merge(li,low,mid,high):</span><br><span class="line">    i = low # 第一个列表起点</span><br><span class="line">    j = mid+1 # 第二个列表起点</span><br><span class="line">    ltmp = [] # 没法用到原地排序了</span><br><span class="line">    while i&lt;=mid and j&lt;=high:# 只要左右两边都有数</span><br><span class="line">        if li[i] &lt; li[j]:</span><br><span class="line">            ltmp.append(li[i])</span><br><span class="line">            i += 1</span><br><span class="line">        else:</span><br><span class="line">            ltmp.append(li[j])</span><br><span class="line">            j += 1</span><br><span class="line"></span><br><span class="line">    # while执行完了，肯定有一头 没数了</span><br><span class="line">    while i &lt;= mid:</span><br><span class="line">        ltmp.append(li[i])</span><br><span class="line">        i += 1</span><br><span class="line">    while j &lt;= high:</span><br><span class="line">        ltmp.append(li[j])</span><br><span class="line">        j += 1</span><br><span class="line">    li[low:high+1] = ltmp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def merge_sort(li,low,high):</span><br><span class="line">    if low &lt; high:#至少有两个元素，递归</span><br><span class="line">        mid = (low + high)//2</span><br><span class="line">        merge_sort(li,low,mid)</span><br><span class="line">        merge_sort(li,mid+1,high)</span><br><span class="line">        merge(li,low,mid,high)</span><br><span class="line"></span><br><span class="line">li = list(range(16))</span><br><span class="line">import random</span><br><span class="line">random.shuffle(li)</span><br><span class="line">print(li)</span><br><span class="line">merge_sort(li,0,len(li)-1)</span><br><span class="line">print(li)</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/slTrust/note/master/img/py/py008_01_1101.png" alt></p>
<h3 id="归并排序复杂度"><a href="#归并排序复杂度" class="headerlink" title="归并排序复杂度"></a>归并排序复杂度</h3><blockquote>
<p>时间复杂度</p>
</blockquote>
<ul>
<li>O(nlogn)</li>
</ul>
<blockquote>
<p>空间复杂度</p>
</blockquote>
<ul>
<li>O(n) 因为不是原地排序需要单独开辟空间</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/12/Py008-01-11归并排序之归并/" data-id="cklhjp25v00kyulfyah2quoi8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/M08/">M08</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Py008-01-10堆排序之topk问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/12/Py008-01-10堆排序之topk问题/" class="article-date">
  <time datetime="2018-12-12T13:37:36.000Z" itemprop="datePublished">2018-12-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/12/Py008-01-10堆排序之topk问题/">Py008-01-10堆排序之topk问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="topk问题"><a href="#topk问题" class="headerlink" title="topk问题"></a>topk问题</h3><ul>
<li>现在有n个数，设计算法得到前k大的数。 (k&lt;n)</li>
<li>解决思路：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 1.排序后切片 O(nlogn) + k</span><br><span class="line"></span><br><span class="line">- 2.排序lowB三人组 O(kn) </span><br><span class="line">    如果是冒泡只需要k趟就可以</span><br><span class="line"></span><br><span class="line">- 3.堆排序思路  O(nlogk)</span><br></pre></td></tr></table></figure>
<h4 id="堆排序解决思路"><a href="#堆排序解决思路" class="headerlink" title="堆排序解决思路"></a>堆排序解决思路</h4><ul>
<li>取列表前k个元素建立一个小根堆。堆顶就是目前第k大的数。</li>
<li>依次向后遍历原列表，对于列表中的元素，如果小于堆顶，则忽略该元素；如果大于堆顶，则将堆顶更换为该元素，并且对堆进行一次调整；</li>
<li>遍历列表所有元素后，倒序弹出堆顶</li>
</ul>
<blockquote>
<p>如假设一个长度为10的列表,取最大的前5个数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[6,8,1,9,3,0,7,2,4,5]</span><br><span class="line">思路</span><br><span class="line">step001 </span><br><span class="line">从列表里取出前5个数[6,8,1,9,3]</span><br><span class="line">step002 将这5个数变成一个小根堆</span><br><span class="line">      1</span><br><span class="line">  3       6</span><br><span class="line">9   8</span><br><span class="line">step003 循环剩余列表[0,7,2,4,5]依次跟堆顶比较</span><br><span class="line"></span><br><span class="line">0 &lt; 1 不换 [7,2,4,5]</span><br><span class="line"></span><br><span class="line">7 &gt; 1 换 [2,4,5]</span><br><span class="line">      7</span><br><span class="line">  3       6</span><br><span class="line">9   8</span><br><span class="line">此时向上调整</span><br><span class="line">      3</span><br><span class="line">  7       6</span><br><span class="line">9   8</span><br><span class="line">2 &lt; 3 不换 [4,5]</span><br><span class="line">4 &gt; 3 换 [5]</span><br><span class="line">      4</span><br><span class="line">  7       6</span><br><span class="line">9   8</span><br><span class="line">无需调整继续循环</span><br><span class="line">5 &gt; 4 换 []</span><br><span class="line">      5</span><br><span class="line">  7       6</span><br><span class="line">9   8</span><br></pre></td></tr></table></figure>
<ul>
<li>此时时间复杂度是O(nlogk)</li>
</ul>
<h4 id="topk实现"><a href="#topk实现" class="headerlink" title="topk实现"></a>topk实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">#-*- encoding:utf-8 -*-</span><br><span class="line"></span><br><span class="line"># 原地排序，所以 大根堆 堆顶下来的元素会放到列表的末尾</span><br><span class="line"># high则标记 堆的最后一个元素</span><br><span class="line">def sift(li,low,high):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    :param li: 列表</span><br><span class="line">    :param low: 堆的根节点位置</span><br><span class="line">    :param high: 堆的最后一个元素的位置</span><br><span class="line">    :return:</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    i = low # i最开始指向根节点</span><br><span class="line">    j = 2 * i + 1 # j就是i的左孩子</span><br><span class="line">    tmp = li[low] # 把堆顶存起来</span><br><span class="line">    while j &lt;= high: # 只要j位置有数</span><br><span class="line">        if j + 1 &lt;= high and li[j+1] &lt; li[j]: # 如果有右孩子而且 右孩子比左孩子小</span><br><span class="line">            j = j + 1 # 指向右孩子</span><br><span class="line"></span><br><span class="line">        if li[j] &lt; tmp: # 要么是左孩子  要么是右孩子</span><br><span class="line">            li[i] = li[j]</span><br><span class="line">            i = j    # 往下看一层</span><br><span class="line">            j = 2 * i + 1</span><br><span class="line"></span><br><span class="line">        else: # tmp最大，把tmp放到i的位置上</span><br><span class="line">            li[i] = tmp # 把tmp放到某一级领导位置上</span><br><span class="line">            break</span><br><span class="line">    else:</span><br><span class="line">        li[i] = tmp # 把tmp放到叶子节点上</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">def topk(li,k):</span><br><span class="line">    heap = li[0:k];</span><br><span class="line">    for i in range((k-2)//2,-1,-1):</span><br><span class="line">        sift(heap,i,k-1)</span><br><span class="line">    # 1。建堆</span><br><span class="line">    # 循环 k到 len(li)-1</span><br><span class="line">    for i in range(k,len(li)-1):</span><br><span class="line">        if li[i] &gt; heap[0]:</span><br><span class="line">            heap[0] = li[i]</span><br><span class="line">            sift(heap,0,k-1)</span><br><span class="line">    # 2。遍历</span><br><span class="line">    for i in range(k-1,-1,-1):</span><br><span class="line">        heap[0],heap[i] = heap[i],heap[0]</span><br><span class="line">        sift(heap,0,i-1)</span><br><span class="line"></span><br><span class="line">    # 3。出数</span><br><span class="line">    return heap</span><br><span class="line"></span><br><span class="line">import random</span><br><span class="line">li = list(range(1000))</span><br><span class="line">random.shuffle(li)</span><br><span class="line"></span><br><span class="line">print(topk(li,10))</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/12/Py008-01-10堆排序之topk问题/" data-id="cklhjp25u00kvulfytajq67jq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/M08/">M08</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Py008-01-09堆排序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/12/Py008-01-09堆排序/" class="article-date">
  <time datetime="2018-12-12T12:36:39.000Z" itemprop="datePublished">2018-12-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/12/Py008-01-09堆排序/">Py008-01-09堆排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="堆排序过程"><a href="#堆排序过程" class="headerlink" title="堆排序过程"></a>堆排序过程</h3><ul>
<li>1.建立堆</li>
<li>2.得到堆顶元素，为最大元素</li>
<li>3.去掉堆顶，将堆最后一个元素放到堆顶，此时可通过一次调整重新使堆有序</li>
<li>4.堆顶元素为第二最大元素</li>
<li>5.重复步骤3，直到堆变空</li>
</ul>
<h4 id="堆向下调整实现"><a href="#堆向下调整实现" class="headerlink" title="堆向下调整实现"></a>堆向下调整实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 原地排序，所以 大根堆 堆顶下来的元素会放到列表的末尾</span><br><span class="line"># high则标记 堆的最后一个元素</span><br><span class="line">def sift(li,low,high):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    :param li: 列表</span><br><span class="line">    :param low: 堆的根节点位置</span><br><span class="line">    :param high: 堆的最后一个元素的位置</span><br><span class="line">    :return:</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    i = low # i最开始指向根节点</span><br><span class="line">    j = 2 * i + 1 # j就是i的左孩子</span><br><span class="line">    tmp = li[low] # 把堆顶存起来</span><br><span class="line">    while j &lt;= high: # 只要j位置有数</span><br><span class="line">        if j + 1 &lt;= high and li[j+1] &gt; li[j]: # 如果有右孩子而且 右孩子比左孩子大</span><br><span class="line">            j = j + 1 # 指向右孩子</span><br><span class="line"></span><br><span class="line">        if li[j] &gt; tmp: # 要么是左孩子  要么是右孩子</span><br><span class="line">            li[i] = li[j]</span><br><span class="line">            i = j    # 往下看一层</span><br><span class="line">            j = 2 * i + 1</span><br><span class="line"></span><br><span class="line">        else: # tmp最大，把tmp放到i的位置上</span><br><span class="line">            li[i] = tmp # 把tmp放到某一级领导位置上</span><br><span class="line">            break</span><br><span class="line">    else:</span><br><span class="line">        li[i] = tmp # 把tmp放到叶子节点上</span><br></pre></td></tr></table></figure>
<h4 id="建立堆"><a href="#建立堆" class="headerlink" title="建立堆"></a>建立堆</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def heap_sort(li):</span><br><span class="line">    n = len(li)</span><br><span class="line">    # 倒着循环 找村级别</span><br><span class="line">    for i in range((n-2)//2,-1,-1):</span><br><span class="line">        # i表示建堆时候调整的部分的根的下标</span><br><span class="line">        # 此时的high不用 2*i+1</span><br><span class="line">        sift(li,i,n-1)</span><br><span class="line">    # 建堆完成了</span><br></pre></td></tr></table></figure>
<h4 id="挨个出数"><a href="#挨个出数" class="headerlink" title="挨个出数"></a>挨个出数</h4><ul>
<li>因为是原地排序</li>
<li>所以堆顶下台的元素会放到末尾</li>
<li>high = 列表长度 - 下太元素的个数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"># 原地排序，所以 大根堆 堆顶下来的元素会放到列表的末尾</span><br><span class="line"># high则标记 堆的最后一个元素</span><br><span class="line">def sift(li,low,high):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    :param li: 列表</span><br><span class="line">    :param low: 堆的根节点位置</span><br><span class="line">    :param high: 堆的最后一个元素的位置</span><br><span class="line">    :return:</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    i = low # i最开始指向根节点</span><br><span class="line">    j = 2 * i + 1 # j就是i的左孩子</span><br><span class="line">    tmp = li[low] # 把堆顶存起来</span><br><span class="line">    while j &lt;= high: # 只要j位置有数</span><br><span class="line">        if j + 1 &lt;= high and li[j+1] &gt; li[j]: # 如果有右孩子而且 右孩子比左孩子大</span><br><span class="line">            j = j + 1 # 指向右孩子</span><br><span class="line"></span><br><span class="line">        if li[j] &gt; tmp: # 要么是左孩子  要么是右孩子</span><br><span class="line">            li[i] = li[j]</span><br><span class="line">            i = j    # 往下看一层</span><br><span class="line">            j = 2 * i + 1</span><br><span class="line"></span><br><span class="line">        else: # tmp最大，把tmp放到i的位置上</span><br><span class="line">            li[i] = tmp # 把tmp放到某一级领导位置上</span><br><span class="line">            break</span><br><span class="line">    else:</span><br><span class="line">        li[i] = tmp # 把tmp放到叶子节点上</span><br><span class="line"></span><br><span class="line">def heap_sort(li):</span><br><span class="line">    n = len(li)</span><br><span class="line">    # 倒着循环 找村级别</span><br><span class="line">    for i in range((n-2)//2,-1,-1):</span><br><span class="line">        # i表示建堆时候调整的部分的根的下标</span><br><span class="line">        # 此时的high不用 2*i+1</span><br><span class="line">        sift(li,i,n-1)</span><br><span class="line">    # 建堆完成了</span><br><span class="line"></span><br><span class="line">    for i in range(n-1,-1,-1):</span><br><span class="line">        # i 指向当前堆的最后一个元素</span><br><span class="line">        # 把堆的最后一个元素放到堆顶</span><br><span class="line">        li[0],li[i] = li[i],li[0]</span><br><span class="line">        # 此时high = i-1 就是前一个元素</span><br><span class="line">        sift(li,0,i-1)</span><br><span class="line"></span><br><span class="line">li = [i for i in range(100)]</span><br><span class="line">import random</span><br><span class="line">random.shuffle(li)</span><br><span class="line">print(li)</span><br><span class="line"></span><br><span class="line">heap_sort(li)</span><br><span class="line">print(li)</span><br></pre></td></tr></table></figure>
<h3 id="堆排序的时间复杂度"><a href="#堆排序的时间复杂度" class="headerlink" title="堆排序的时间复杂度"></a>堆排序的时间复杂度</h3><ul>
<li>时间复杂度：O(nlogn)</li>
</ul>
<h3 id="堆排序——内置模块-heapq"><a href="#堆排序——内置模块-heapq" class="headerlink" title="堆排序——内置模块 heapq"></a>堆排序——内置模块 heapq</h3><blockquote>
<p>常用函数</p>
</blockquote>
<ul>
<li>heapify(x)</li>
<li>heappush(heap,item)</li>
<li>heappop(heap)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import heapq # q=&gt;queue 优先队列</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">li = [i for i in range(100)]</span><br><span class="line">random.shuffle(li)</span><br><span class="line">print(li)</span><br><span class="line"></span><br><span class="line">heapq.heapify(li) # 建堆</span><br><span class="line"></span><br><span class="line">n = len(li)</span><br><span class="line">for i in range(n):</span><br><span class="line">    # 每次出数</span><br><span class="line">    print(heapq.heappop(li),end=&apos;,&apos;)</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/12/Py008-01-09堆排序/" data-id="cklhjp25u00kuulfy4tkwvsqw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/M08/">M08</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Py008-01-08堆和堆的向下调整" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/10/Py008-01-08堆和堆的向下调整/" class="article-date">
  <time datetime="2018-12-10T14:08:21.000Z" itemprop="datePublished">2018-12-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/10/Py008-01-08堆和堆的向下调整/">Py008-01-08堆和堆的向下调整</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>一种特殊的完全二叉树结构</p>
<ul>
<li>大根堆：一颗完全二叉树，任意节点都比其孩子节点大</li>
<li>小根堆：一颗完全二叉树，任意节点都比其孩子节点小</li>
</ul>
<p><img src="https://raw.githubusercontent.com/slTrust/note/master/img/py/py008_01_0801.png" alt></p>
<blockquote>
<h4 id="一个具体的方式来看堆的问题-如上图的大根堆"><a href="#一个具体的方式来看堆的问题-如上图的大根堆" class="headerlink" title="一个具体的方式来看堆的问题(如上图的大根堆)"></a>一个具体的方式来看堆的问题(如上图的大根堆)</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一层 9 好比 省长</span><br><span class="line">第二层 8，7 好比 县长</span><br><span class="line">第三层 6，5，0，1 好比 村长</span><br><span class="line">第四层 2，4，3  好比 村民</span><br></pre></td></tr></table></figure>
<h4 id="堆的向下调整性"><a href="#堆的向下调整性" class="headerlink" title="堆的向下调整性"></a>堆的向下调整性</h4><blockquote>
<h4 id="假设：节点的左右子树都是堆，但自身不是堆"><a href="#假设：节点的左右子树都是堆，但自身不是堆" class="headerlink" title="假设：节点的左右子树都是堆，但自身不是堆"></a>假设：节点的左右子树都是堆，但自身不是堆</h4></blockquote>
<p><img src="https://raw.githubusercontent.com/slTrust/note/master/img/py/py008_01_0802.png" alt></p>
<blockquote>
<h4 id="很明显第一层坐在省长位置的2不合格"><a href="#很明显第一层坐在省长位置的2不合格" class="headerlink" title="很明显第一层坐在省长位置的2不合格"></a>很明显第一层坐在省长位置的2不合格</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">于是把 2 撸下来</span><br><span class="line">            ?</span><br><span class="line">    9                  7</span><br><span class="line">  8         5        0  1</span><br><span class="line">6   4     3</span><br><span class="line"></span><br><span class="line">让谁上去？待选人肯定是县长级别的   所以是 9 和 7，但是肯定要权限值大的上去</span><br><span class="line"></span><br><span class="line">            9</span><br><span class="line">    ？                 7</span><br><span class="line">  8         5        0  1</span><br><span class="line">6   4     3</span><br><span class="line">此时问？ 2能做一个县长吗？ 不能因为它领导不了下面的村长 8和5 而此时需要上位一个县长 8&gt;5  8上位了</span><br><span class="line">            9</span><br><span class="line">    8                 7</span><br><span class="line">  ?         5        0  1</span><br><span class="line">6   4     3</span><br><span class="line">此时问？ 2能做一个村长吗？ 不能因为它领导不了下面的村民 6，4和3 而此时需要上位一个村长 6&gt;4&gt;3  6上位了</span><br><span class="line"></span><br><span class="line">            9</span><br><span class="line">    8                 7</span><br><span class="line">  6         5        0  1</span><br><span class="line">?   4     3</span><br><span class="line"></span><br><span class="line">最后没法在撸了 ，所以2只能当村民了</span><br><span class="line">        9</span><br><span class="line">    8                 7</span><br><span class="line">  6         5        0  1</span><br><span class="line">2   4     3</span><br></pre></td></tr></table></figure>
<h3 id="堆排序过程演示"><a href="#堆排序过程演示" class="headerlink" title="堆排序过程演示"></a>堆排序过程演示</h3><blockquote>
<p>原理就是挨个出数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">res = []</span><br><span class="line">如大根堆的情况：</span><br><span class="line">            9</span><br><span class="line">    8                 7</span><br><span class="line">  6         5        0  1</span><br><span class="line">2   4     3</span><br><span class="line">step001 第一次 先让最大的下台 9下台了 </span><br><span class="line">res=[9]</span><br><span class="line">            ？</span><br><span class="line">    8                 7</span><br><span class="line">  6         5        0  1</span><br><span class="line">2   4     3</span><br><span class="line">---------------------------------</span><br><span class="line">思考假设  让谁上台</span><br><span class="line">如果是8上台</span><br><span class="line">导致8的位置空了</span><br><span class="line">            8</span><br><span class="line">    ?                 7</span><br><span class="line">  6         5        0  1</span><br><span class="line">2   4     3</span><br><span class="line">就必须 6上台</span><br><span class="line">导致6的位置空了</span><br><span class="line">            8</span><br><span class="line">    6                 7</span><br><span class="line">  ?         5        0  1</span><br><span class="line">2   4     3</span><br><span class="line">就必须 4上台</span><br><span class="line">导致4的位置空了</span><br><span class="line">            8</span><br><span class="line">    6                 7</span><br><span class="line">  4        5        0  1</span><br><span class="line">2   ?     3</span><br><span class="line">此时就不知道4的位置有一个空位</span><br><span class="line">这样就很麻烦</span><br><span class="line">这样就很麻烦</span><br><span class="line">这样就很麻烦</span><br><span class="line">---------------------------------</span><br><span class="line">            ？</span><br><span class="line">    8                 7</span><br><span class="line">  6         5        0  1</span><br><span class="line">2   4     3</span><br><span class="line">另一种思路 选一个备胎上去 取树的最后一层的最后的孩子也就是3</span><br><span class="line">            3</span><br><span class="line">    8                 7</span><br><span class="line">  6         5        0  1</span><br><span class="line">2   4     </span><br><span class="line">此时只要通过一次向下调整就能保持堆的层级:如下</span><br><span class="line">            8</span><br><span class="line">    6                 7</span><br><span class="line">  4         5        0  1</span><br><span class="line">2   3   </span><br><span class="line">step002  先让最大的下台 8下台了</span><br><span class="line">取树的最后一层的最后的孩子也就是3</span><br><span class="line">res=[9,8]</span><br><span class="line">            3</span><br><span class="line">    6                 7</span><br><span class="line">  4         5        0  1</span><br><span class="line">2     </span><br><span class="line">通过一次向下调整就能保持堆的层级</span><br><span class="line">res=[9,8]</span><br><span class="line">            7</span><br><span class="line">    6                 3</span><br><span class="line">  4         5        0  1</span><br><span class="line">2   </span><br><span class="line">step003  先让最大的下台 7下台了</span><br><span class="line">取树的最后一层的最后的孩子也就是2</span><br><span class="line">res=[9,8,7]</span><br><span class="line">          2</span><br><span class="line">    6            3</span><br><span class="line">  4   5        0  1</span><br><span class="line">通过一次向下调整就能保持堆的层级</span><br><span class="line">          6</span><br><span class="line">    5            3</span><br><span class="line">  4   2        0  1</span><br><span class="line">step004  先让最大的下台 6下台了</span><br><span class="line">取树的最后一层的最后的孩子也就是1</span><br><span class="line">res = [9,8,7,6]</span><br><span class="line">          1</span><br><span class="line">    5            3</span><br><span class="line">  4   2        0 </span><br><span class="line">通过一次向下调整就能保持堆的层级</span><br><span class="line">           5</span><br><span class="line">    4            3</span><br><span class="line">  1   2        0 </span><br><span class="line">step005  先让最大的下台 5下台了</span><br><span class="line">取树的最后一层的最后的孩子也就是0</span><br><span class="line">res = [9,8,7,6,5]</span><br><span class="line">           0</span><br><span class="line">    4            3</span><br><span class="line">  1   2  </span><br><span class="line">通过一次向下调整就能保持堆的层级       </span><br><span class="line">           4</span><br><span class="line">    2            3</span><br><span class="line">  1   0 </span><br><span class="line">step006  先让最大的下台 4下台了</span><br><span class="line">取树的最后一层的最后的孩子也就是0</span><br><span class="line">res = [9,8,7,6,5,4]</span><br><span class="line">          0</span><br><span class="line">    2            3</span><br><span class="line">  1   </span><br><span class="line">通过一次向下调整就能保持堆的层级 </span><br><span class="line">          3</span><br><span class="line">    2            0</span><br><span class="line">  1 </span><br><span class="line">step007  先让最大的下台 3下台了</span><br><span class="line">取树的最后一层的最后的孩子也就是1</span><br><span class="line">res = [9,8,7,6,5,4,3]</span><br><span class="line">           1</span><br><span class="line">    2            0</span><br><span class="line">通过一次向下调整就能保持堆的层级 </span><br><span class="line">        2</span><br><span class="line">    1        0</span><br><span class="line">step008  先让最大的下台 2下台了</span><br><span class="line">取树的最后一层的最后的孩子也就是0</span><br><span class="line">res = [9,8,7,6,5,4,3,2]</span><br><span class="line">        0</span><br><span class="line">    1        </span><br><span class="line">通过一次向下调整就能保持堆的层级</span><br><span class="line">        1</span><br><span class="line">    0 </span><br><span class="line">step008  先让最大的下台 1下台了</span><br><span class="line">取树的最后一层的最后的孩子也就是0</span><br><span class="line">res = [9,8,7,6,5,4,3,2,1] </span><br><span class="line">    0</span><br><span class="line">step008  先让最大的下台 0下台了</span><br><span class="line">res = [9,8,7,6,5,4,3,2,1,0]</span><br></pre></td></tr></table></figure>
<h3 id="构造堆"><a href="#构造堆" class="headerlink" title="构造堆"></a>构造堆</h3><ul>
<li>堆一开始是没有秩序的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">如</span><br><span class="line">                6</span><br><span class="line">        8               1</span><br><span class="line">    9       3          0  7</span><br><span class="line">   2  4    5</span><br><span class="line"></span><br><span class="line">先管理一个村 3</span><br><span class="line">3和5调换</span><br><span class="line">看前一个村 9发现是好的 </span><br><span class="line">                6</span><br><span class="line">        8               1</span><br><span class="line">    9       5          0  7</span><br><span class="line">   2  4    3</span><br><span class="line">村都好了</span><br><span class="line">管理县7</span><br><span class="line">                6</span><br><span class="line">        8               7</span><br><span class="line">    9       5          0  1</span><br><span class="line">   2  4    3</span><br><span class="line">管理前一个县8</span><br><span class="line">                6</span><br><span class="line">        9               7</span><br><span class="line">    8       5          0  1</span><br><span class="line">   2  4    3</span><br><span class="line">县管理好了，管理省6</span><br><span class="line">                9</span><br><span class="line">        8               7</span><br><span class="line">    6       5          0  1</span><br><span class="line">   2  4    3</span><br><span class="line">此时构造堆的过程就结束了</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结论就是：每次从最底层构建堆</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">管理村级别的最后一个村</span><br><span class="line">村级别都好了</span><br><span class="line">管理县级别的最后一个县</span><br><span class="line">县级别都好了</span><br><span class="line">管理省级别的最后一个省</span><br><span class="line">县级别都好了</span><br><span class="line">最后就成了一个堆</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/10/Py008-01-08堆和堆的向下调整/" data-id="cklhjp25t00krulfyt5ooqomy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/M08/">M08</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Py008-01-07堆排序前传树与二叉树" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/10/Py008-01-07堆排序前传树与二叉树/" class="article-date">
  <time datetime="2018-12-10T13:02:13.000Z" itemprop="datePublished">2018-12-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/10/Py008-01-07堆排序前传树与二叉树/">Py008-01-07堆排序前传树与二叉树</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><blockquote>
<p>树是一种数据结构</p>
</blockquote>
<p>比如：目录结构</p>
<ul>
<li>树是一种可以递归定义的数据结构</li>
<li>树由n个节点组成的集合<ul>
<li>如果n=0,那是一棵空树</li>
<li>如果n&gt;0,那存在一个节点作为树的根节点，其他节点可以分为m个集合，每个集合本身又是一棵树</li>
</ul>
</li>
</ul>
<h4 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h4><p><img src="https://raw.githubusercontent.com/slTrust/note/master/img/py/py008_01_0701.png" alt></p>
<blockquote>
<p>根节点，叶子节点</p>
</blockquote>
<ul>
<li>如上图，A就是根节点</li>
<li>不能分叉的节点就是叶子节点 如B,C,H,I,P,Q,K,L,M,N</li>
</ul>
<blockquote>
<p>树的深度(高度) </p>
</blockquote>
<ul>
<li>看它的递归深度  如上为 4</li>
</ul>
<blockquote>
<p>树的度</p>
</blockquote>
<ul>
<li>就是最大分叉的个数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如 E 的度是2</span><br><span class="line">如 F 的度是3</span><br><span class="line">如 A 的度是6</span><br><span class="line"></span><br><span class="line">所以如上图   树的度就是6</span><br></pre></td></tr></table></figure>
<blockquote>
<p>孩子节点，父节点</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E是I的父节点</span><br><span class="line">I是E的子节点</span><br></pre></td></tr></table></figure>
<blockquote>
<p>子树</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如 把 E,I,J,P,Q拎出来 E就是一个子树</span><br></pre></td></tr></table></figure>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ul>
<li>二叉树就是度不超过2的树</li>
<li>每个节点最多有两个子节点</li>
<li>两个孩子节点被区分为左孩子节点和右孩子节点</li>
</ul>
<p><img src="https://raw.githubusercontent.com/slTrust/note/master/img/py/py008_01_0702.png" alt></p>
<p><img src="https://raw.githubusercontent.com/slTrust/note/master/img/py/py008_01_0703.png" alt></p>
<blockquote>
<h4 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h4></blockquote>
<ul>
<li>链式存储方式</li>
<li>顺序存储方式(就是用一个列表来存储)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/slTrust/note/master/img/py/py008_01_0704.png" alt></p>
<blockquote>
<h4 id="思考：如果从孩子找父亲该怎么找？"><a href="#思考：如果从孩子找父亲该怎么找？" class="headerlink" title="思考：如果从孩子找父亲该怎么找？"></a>思考：如果从孩子找父亲该怎么找？</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如子节点下标为9</span><br><span class="line">(9-1)整除2=4</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/10/Py008-01-07堆排序前传树与二叉树/" data-id="cklhjp25s00kqulfyoj2w2tyt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/M08/">M08</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Py008-01-06快速排序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/09/Py008-01-06快速排序/" class="article-date">
  <time datetime="2018-12-09T03:45:23.000Z" itemprop="datePublished">2018-12-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/09/Py008-01-06快速排序/">Py008-01-06快速排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><blockquote>
<p>第一个实现方式</p>
</blockquote>
<p>非原地排序，非常费空间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line"># 非原地排序  每次都把列表分为左右两个区间</span><br><span class="line">def quickSort(arr):</span><br><span class="line">    if len(arr) &lt;= 1: return arr</span><br><span class="line"></span><br><span class="line">    # 取中间位</span><br><span class="line">    pivotIndex = math.ceil(len(arr) / 2);</span><br><span class="line">    pivot = arr[pivotIndex];</span><br><span class="line">    del arr[pivotIndex];</span><br><span class="line"></span><br><span class="line">    # 左右区间，用于存放排序后的数</span><br><span class="line">    left = [];</span><br><span class="line">    right = [];</span><br><span class="line">    for i in range(len(arr)):</span><br><span class="line">        print(&apos;分区操作的第 &apos; + str(i + 1) + &apos; 次循环：&apos;);</span><br><span class="line">        # 小于基准，放于左区间，大于基准，放于右区间</span><br><span class="line">        if arr[i] &lt; pivot:</span><br><span class="line">            left.append(arr[i]);</span><br><span class="line">            print(&apos;左边：&apos; + str(arr[i]))</span><br><span class="line">        else:</span><br><span class="line">            right.append(arr[i]);</span><br><span class="line">            print(&apos;右边：&apos; + str(arr[i]))</span><br><span class="line">    print(left, right)</span><br><span class="line">    return quickSort(left) + [pivot] + quickSort(right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arr = [14, 3, 15, 7, 2, 76, 11];</span><br><span class="line">print(quickSort(arr));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原地排序</p>
</blockquote>
<ul>
<li>以第一个值为起点 li[0] </li>
<li>从右开始找 li[len(li)-1] 比 li[0] 小则交换，索引往左移动一位。</li>
<li>然后从左往右找 比li[0]大 则交换，索引往右移动一位</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def partition(li,left,right):</span><br><span class="line">    tmp = li[left]</span><br><span class="line">    while left &lt; right:</span><br><span class="line">        while left &lt; right and li[right] &gt;= tmp: # 从右面找比tmp小的数</span><br><span class="line">            right -= 1 # 往左走一步</span><br><span class="line">            print(li,&apos;right&apos;)</span><br><span class="line">        li[left] = li[right] # 把右边的值填到左边的空位上</span><br><span class="line"></span><br><span class="line">        while left &lt; right and li[left] &lt;= tmp: # 从左面找比tmp大的数</span><br><span class="line">            left += 1 # 往右走一步</span><br><span class="line">            print(li,&apos;left&apos;)</span><br><span class="line">        li[right] = li[left] # 把左边的值填到右边的空位上</span><br><span class="line"></span><br><span class="line">    li[left] = tmp # 把tmp归位</span><br><span class="line">    return left # 返回中间值</span><br><span class="line"></span><br><span class="line">li = [5,7,4,6,3,1,2,9,8]</span><br><span class="line"></span><br><span class="line">print(li)</span><br><span class="line">partition(li,0,len(li)-1)</span><br><span class="line">print(li)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第二步，递归的方式来排序左面的和右边</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">def partition(li,left,right):</span><br><span class="line">    tmp = li[left]</span><br><span class="line">    while left &lt; right:</span><br><span class="line">        while left &lt; right and li[right] &gt;= tmp: # 从右面找比tmp小的数</span><br><span class="line">            right -= 1 # 往左走一步</span><br><span class="line">        li[left] = li[right] # 把右边的值填到左边的空位上</span><br><span class="line"></span><br><span class="line">        while left &lt; right and li[left] &lt;= tmp: # 从左面找比tmp大的数</span><br><span class="line">            left += 1 # 往右走一步</span><br><span class="line">        li[right] = li[left] # 把左边的值填到右边的空位上</span><br><span class="line"></span><br><span class="line">    li[left] = tmp # 把tmp归位</span><br><span class="line">    return left # 返回中间值</span><br><span class="line"></span><br><span class="line">def quick_sort(li,left,right):</span><br><span class="line">    if left&lt;right :# 至少两个元素</span><br><span class="line">        mid = partition(li,left,right)</span><br><span class="line">        quick_sort(li,left,mid-1)</span><br><span class="line">        quick_sort(li,mid+1,right)</span><br><span class="line"></span><br><span class="line">li = [5,7,4,6,3,1,2,9,8]</span><br><span class="line">quick_sort(li,0,len(li)-1)</span><br><span class="line">print(li)</span><br></pre></td></tr></table></figure>
<h4 id="快速排序的效率"><a href="#快速排序的效率" class="headerlink" title="快速排序的效率"></a>快速排序的效率</h4><ul>
<li>时间复杂度 O(n*log n)</li>
</ul>
<h4 id="快排的问题"><a href="#快排的问题" class="headerlink" title="快排的问题"></a>快排的问题</h4><ul>
<li>递归 (python有个递归层数的问题默认1000)</li>
<li>最坏情况</li>
</ul>
<blockquote>
<p>什么是最坏情况</p>
</blockquote>
<ul>
<li>当列表是 倒序排列的时候 [9,8,7,6,5,4,3,2,1]</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基本和冒泡一样了</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="解决方案就是随机一个数字-而不是固定取第一位"><a href="#解决方案就是随机一个数字-而不是固定取第一位" class="headerlink" title="解决方案就是随机一个数字,而不是固定取第一位"></a>解决方案就是随机一个数字,而不是固定取第一位</h4></blockquote>
<ul>
<li>随机快排</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/09/Py008-01-06快速排序/" data-id="cklhjp25r00knulfyl3kvw3do" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/M08/">M08</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/26/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="page-number" href="/page/26/">26</a><span class="page-number current">27</span><a class="page-number" href="/page/28/">28</a><a class="page-number" href="/page/29/">29</a><span class="space">&hellip;</span><a class="page-number" href="/page/55/">55</a><a class="extend next" rel="next" href="/page/28/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6速学/">ES6速学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS不知深浅/">JS不知深浅</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/M01/">M01</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/M02/">M02</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/M03/">M03</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/M04/">M04</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/M06/">M06</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/M07/">M07</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/M08/">M08</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/M09/">M09</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NodeWeb/">NodeWeb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node后端/">Node后端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ReactWheels/">ReactWheels</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React入门/">React入门</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TS入门/">TS入门</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/express/">express</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fullstack/">fullstack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jQuery/">jQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mobile/">mobile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb/">mongodb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/">node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node每日精进/">node每日精进</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oak/">oak</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tools/">tools</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/">vim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vultr/">vultr</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web性能优化/">web性能优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web面经/">web面经</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端知识点/">前端知识点</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 13.91px;">CSS</a> <a href="/tags/ES6速学/" style="font-size: 14.35px;">ES6速学</a> <a href="/tags/JS不知深浅/" style="font-size: 11.3px;">JS不知深浅</a> <a href="/tags/M01/" style="font-size: 13.48px;">M01</a> <a href="/tags/M02/" style="font-size: 15.22px;">M02</a> <a href="/tags/M03/" style="font-size: 15.65px;">M03</a> <a href="/tags/M04/" style="font-size: 16.09px;">M04</a> <a href="/tags/M06/" style="font-size: 18.26px;">M06</a> <a href="/tags/M07/" style="font-size: 17.83px;">M07</a> <a href="/tags/M08/" style="font-size: 16.96px;">M08</a> <a href="/tags/M09/" style="font-size: 11.74px;">M09</a> <a href="/tags/NodeWeb/" style="font-size: 15.65px;">NodeWeb</a> <a href="/tags/Node后端/" style="font-size: 18.7px;">Node后端</a> <a href="/tags/ReactWheels/" style="font-size: 16.52px;">ReactWheels</a> <a href="/tags/React入门/" style="font-size: 15.22px;">React入门</a> <a href="/tags/TS入门/" style="font-size: 14.78px;">TS入门</a> <a href="/tags/express/" style="font-size: 10.43px;">express</a> <a href="/tags/fullstack/" style="font-size: 17.83px;">fullstack</a> <a href="/tags/http/" style="font-size: 12.17px;">http</a> <a href="/tags/jQuery/" style="font-size: 10px;">jQuery</a> <a href="/tags/java/" style="font-size: 19.13px;">java</a> <a href="/tags/linux/" style="font-size: 10.87px;">linux</a> <a href="/tags/mobile/" style="font-size: 11.3px;">mobile</a> <a href="/tags/mongodb/" style="font-size: 12.61px;">mongodb</a> <a href="/tags/mysql/" style="font-size: 12.61px;">mysql</a> <a href="/tags/node/" style="font-size: 10.43px;">node</a> <a href="/tags/node每日精进/" style="font-size: 10px;">node每日精进</a> <a href="/tags/oak/" style="font-size: 20px;">oak</a> <a href="/tags/python/" style="font-size: 17.39px;">python</a> <a href="/tags/tools/" style="font-size: 10px;">tools</a> <a href="/tags/vim/" style="font-size: 10px;">vim</a> <a href="/tags/vue/" style="font-size: 13.04px;">vue</a> <a href="/tags/vultr/" style="font-size: 10px;">vultr</a> <a href="/tags/web性能优化/" style="font-size: 10px;">web性能优化</a> <a href="/tags/web面经/" style="font-size: 10px;">web面经</a> <a href="/tags/前端知识点/" style="font-size: 19.57px;">前端知识点</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/02/23/Node-web05-09-03博客系统使用nginx/">Node-web05-09-03博客系统使用nginx</a>
          </li>
        
          <li>
            <a href="/2021/02/22/Node-web05-09-02博客系统部署最新版流程/">Node-web05-09-02博客系统部署最新版流程</a>
          </li>
        
          <li>
            <a href="/2021/02/20/Node-web05-09-01博客统部署2/">Node-web05-09-01博客统部署优化解释</a>
          </li>
        
          <li>
            <a href="/2021/02/20/Node-web05-08博客统页面完善/">Node-web05-08博客统页面完善</a>
          </li>
        
          <li>
            <a href="/2021/02/19/Node-web05-07-03服务器端构建/">Node-web05-07-03服务器端构建</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Stevin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>