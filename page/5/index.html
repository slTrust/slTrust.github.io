<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Almost</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Almost">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="Almost">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Almost">
  
    <link rel="alternate" href="/atom.xml" title="Almost" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Almost</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Node-JS专精13-01类" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/06/Node-JS专精13-01类/" class="article-date">
  <time datetime="2020-03-06T05:24:53.000Z" itemprop="datePublished">2020-03-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/06/Node-JS专精13-01类/">Node-JS专精13_01类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="类知识简介"><a href="#类知识简介" class="headerlink" title="类知识简介"></a>类知识简介</h1><blockquote>
<p>为什么有类</p>
</blockquote>
<ul>
<li>不同对象的属性重复了，就有类</li>
</ul>
<blockquote>
<p>为什么有继承</p>
</blockquote>
<ul>
<li>不同的类的属性重复类，就有继承</li>
</ul>
<p><strong>大部分编程技巧，都是为了解决重复</strong></p>
<h3 id="对象的属性重复了"><a href="#对象的属性重复了" class="headerlink" title="对象的属性重复了"></a>对象的属性重复了</h3><ul>
<li>两个对象的属性重复</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let p1 = &#123;name:&apos;aa&apos;,age:18,sayHi()&#123;&#125;&#125;</span><br><span class="line">let p2 = &#123;name:&apos;bb&apos;,age:18,sayHi()&#123;&#125;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>于是有了类和构造函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Pserson &#123;</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">    sayHi()&#123;&#125;</span><br><span class="line">    constructor(name,age)&#123;</span><br><span class="line">        this.name = name</span><br><span class="line">        this.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p1 = new Person(&apos;aa&apos;,18)</span><br><span class="line">let p2 = new Person(&apos;bb&apos;,18)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>改写成TS</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    sayHi(): void &#123;&#125;</span><br><span class="line">    constructor(public name: string, public age: number)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p1 = new Person(&apos;aa&apos;,18)</span><br><span class="line">let p2 = new Person(&apos;bb&apos;,18)</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4></blockquote>
<p><strong>类</strong></p>
<ul>
<li>类就是把对象的属性提前写好，避免重复</li>
<li>类里面的字段会变成对象的属性</li>
<li>为了节约内存，所有函数都是 共用的</li>
<li>而非函数属性是各个对象自有的</li>
<li>使用 console.dir 可以看出来</li>
</ul>
<p><strong>构造函数</strong></p>
<ul>
<li>属性名虽然可以提前写好，但是属性值不行</li>
<li>所以需要构造函数接受参数，初始化属性值</li>
<li>构造函数不需要写 return , 默认会 return 新对象</li>
</ul>
<p><strong>语法</strong></p>
<ul>
<li>JS的所有 class 语法可以在 MDN上看</li>
<li>TS的所有 class 语法可以在 TS英文/中文 官网看</li>
</ul>
<blockquote>
<h4 id="不想所有函数都是共用的"><a href="#不想所有函数都是共用的" class="headerlink" title="不想所有函数都是共用的"></a>不想所有函数都是共用的</h4></blockquote>
<ul>
<li>写成箭头函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Pserson &#123;</span><br><span class="line">    sayHi()&#123;&#125; // 共用</span><br><span class="line">    myFn = () =&gt; &#123;&#125; // 自用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这玩意除了浪费内存还有啥用？</strong></p>
<ul>
<li>你必须<code>onclick 那里bind(this)</code>否则报错</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import ReactDOM from &quot;react-dom&quot;;</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  name = &quot;Frank&quot;;</span><br><span class="line">  sayHi()&#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">    console.log(`Hi, I&apos;m $&#123;this.name&#125;`);</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.sayHi.bind(this)&#125;&gt;say hi&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const rootElement = document.getElementById(&quot;root&quot;);</span><br><span class="line">ReactDOM.render(&lt;App /&gt;, rootElement);</span><br></pre></td></tr></table></figure>
<ul>
<li>而如果是各自的函数，就可以直接调用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import ReactDOM from &quot;react-dom&quot;;</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  name = &quot;Frank&quot;;</span><br><span class="line">  sayHi = () =&gt; &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">    console.log(`Hi, I&apos;m $&#123;this.name&#125;`);</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.sayHi&#125;&gt;say hi&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const rootElement = document.getElementById(&quot;root&quot;);</span><br><span class="line">ReactDOM.render(&lt;App /&gt;, rootElement);</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://codesandbox.io/s/muddy-snowflake-1ezyg" target="_blank" rel="noopener">代码地址</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/06/Node-JS专精13-01类/" data-id="ckl3ypv23009xsi91dniebpay" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node后端/">Node后端</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Node-JS专精12-01Eventloop" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/05/Node-JS专精12-01Eventloop/" class="article-date">
  <time datetime="2020-03-05T02:46:11.000Z" itemprop="datePublished">2020-03-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/05/Node-JS专精12-01Eventloop/">Node-JS专精12_01Eventloop</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="https://juejin.im/post/5ab7677f6fb9a028d56711d0" target="_blank" rel="noopener">Event Loop、计时器、nextTick</a></li>
</ul>
<h3 id="Eventloop-之前的前置内容"><a href="#Eventloop-之前的前置内容" class="headerlink" title="Eventloop 之前的前置内容"></a>Eventloop 之前的前置内容</h3><blockquote>
<p>操作系统相关</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">网页上有个输入框，当你按下键盘的 “J” 之后发生了什么</span><br><span class="line"></span><br><span class="line">实际 “J” 下面有一个非常复杂的电路</span><br><span class="line">当你按下 之后，会触发一个电流</span><br><span class="line">这个电流会触发一个你按键的信息 如 101</span><br><span class="line">然后把这个 信息 101 传递给 操作系统</span><br><span class="line">操作系统知道这个 按键信息之后，它就会通知给你的浏览器</span><br><span class="line">浏览器得到 “J” 按键信息之后，就会把这个 “J” 显示在你的输入框上</span><br></pre></td></tr></table></figure>
<p>为什么讲这个：<strong>浏览器它会接受到系统给它的一个事件</strong>用户不停的触发事件，浏览器就不停的把用户输入渲染到输入框里</p>
<p>这个东西呢就叫做 <strong>“事件”</strong></p>
<blockquote>
<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4></blockquote>
<p>接受各种外部设备发出的信号</p>
<ul>
<li>蓝牙事件</li>
<li>鼠标事件</li>
<li>键盘事件</li>
<li>USB事件</li>
</ul>
<blockquote>
<p>疑问？为什么你一插 USB操作系统马上就知道呢？有没有延迟呢？它是非常的快呢？还是一段时间一段时间的查呢？</p>
</blockquote>
<ul>
<li>非常遗憾的是，操作系统并没有你想想的那么聪明</li>
<li>它是如何知道 用户按下了 “J” 呢？</li>
</ul>
<p>它实际上是 <strong>不停的等键盘，可能每隔5毫秒查看一下有没有按下这个键</strong> 这个过程 叫做 <strong>“轮询”</strong></p>
<h3 id="接下来我们看一下-浏览器的内容"><a href="#接下来我们看一下-浏览器的内容" class="headerlink" title="接下来我们看一下 浏览器的内容"></a>接下来我们看一下 浏览器的内容</h3><ul>
<li>浏览器除了运行 JS 之外，还有些网络请求<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 假设你做了这样的事情</span><br><span class="line">console.log(1)</span><br><span class="line">console.log(2)</span><br><span class="line">console.log(3)</span><br><span class="line">...</span><br><span class="line">console.log(10)</span><br><span class="line">ajax(); </span><br><span class="line">console.log(11)</span><br><span class="line">console.log(12)</span><br><span class="line">...</span><br><span class="line">console.log(20)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当我们发送了请求之后，请求大概需要0.2秒得到结果，</span><br><span class="line">首先JS是单线程，那么在这请求 0.2 秒的时间内， ajax() 后面的代码有么有执行？</span><br><span class="line"></span><br><span class="line">有！！！ 执行了</span><br><span class="line"></span><br><span class="line">那么此时 ajax 请求的 0.2秒 是谁在等？</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>或者说 等待请求结果是谁在处理 / 谁在轮询</p>
</blockquote>
<ul>
<li>答案是：<strong>“C++”</strong>， 浏览器有一个轮询机制，每隔一段时间假设5毫秒就问 结果来了没？</li>
<li>反正始终有一个东西在轮询 ，我们不管到底是 浏览器还是 操作系统这些细节。 反正不是JS在等就好了</li>
</ul>
<p><strong>所有的事件 应该如何通知给 JS</strong></p>
<h3 id="这个轮询的规则是什么？"><a href="#这个轮询的规则是什么？" class="headerlink" title="这个轮询的规则是什么？"></a>这个轮询的规则是什么？</h3><p>搞清楚这些规则，你就明白什么是 <strong>Eventloop</strong></p>
<ul>
<li>刚刚的内容讲的是浏览器，我们必须要回到 Node.js 和浏览器是差不多的东西</li>
<li>Node.js 可以执行js代码，浏览器也可以执行 js代码，Eventloop 是 Node.js的概念而不是 浏览器。 所以我们来看 Node.js</li>
</ul>
<h4 id="回到-Node-js"><a href="#回到-Node-js" class="headerlink" title="回到 Node.js"></a>回到 Node.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">同样执行10行代码</span><br><span class="line">然后发起一个异步任务 耗时2秒 setTimeout(fn,2000)</span><br><span class="line">下面又执行20行代码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">那么这个  setTimeout 到底是谁在做呢？</span><br></pre></td></tr></table></figure>
<blockquote>
<p>引入 Eventloop</p>
</blockquote>
<ul>
<li>首先这个 Eventloop 会去监听这个 setTimeout，它会保证 一段时间后执行这个 fn</li>
</ul>
<blockquote>
<h4 id="Eventloop-之前的铺垫"><a href="#Eventloop-之前的铺垫" class="headerlink" title="Eventloop 之前的铺垫"></a>Eventloop 之前的铺垫</h4></blockquote>
<ul>
<li>Eventloop 到底是真实存在的对象，还是一个虚拟的概念？</li>
</ul>
<p>来个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">假设人是有轮回的？ 我们叫它 人生循环</span><br><span class="line">那么人生循环有那些阶段呢？</span><br><span class="line"></span><br><span class="line">生老病死 ==》 投胎 ==》 生老病死 ==》 投胎 。。。</span><br><span class="line">什么时候是尽头，除非宇宙毁灭，什么时候开始，也不要太关心。</span><br><span class="line"></span><br><span class="line">请问人生循环 是什么？</span><br><span class="line"></span><br><span class="line">人在一生中处于不同阶段的过程</span><br></pre></td></tr></table></figure>
<p><strong>事件循环不是循环，它是状态变化的过程</strong></p>
<h4 id="Eventloop-事件循环的阶段"><a href="#Eventloop-事件循环的阶段" class="headerlink" title="Eventloop 事件循环的阶段"></a>Eventloop 事件循环的阶段</h4><ul>
<li>times (前端需要知道)</li>
<li>I/O callbacks </li>
<li>idle , prepare</li>
<li>poll (前端需要知道)</li>
<li>check (前端需要知道)</li>
<li>close callbacks</li>
</ul>
<blockquote>
<p>我们只需要清楚 times / poll / check 就够了</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1 times</span><br><span class="line">2 poll</span><br><span class="line">3 check </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">times =&gt; poll 会停留一段事件</span><br><span class="line">poll =&gt; check</span><br><span class="line">check =&gt; times</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当我们执行 setTimeout(fn,2000) 时， 会把 fn 放入 times 的一个 数组里 (队列)同时记录 要在 2秒后执行 fn ,于是 js 就去做自己的事去了</span><br><span class="line"></span><br><span class="line">setTimeout(fn,2000) 之后就会进入 poll 阶段 等待的过程中 他会去看时间， </span><br><span class="line">刚才 js 说要在 2秒后执行 fn , 比如此时等了 500毫秒，发现不需要执行， 继续等 1000毫秒再去看， 继续等， 等到 2秒的时候 发现时间到了， </span><br><span class="line">赶紧进入 times 阶段执行 fn， 虽然 poll之后要经过 check 阶段 ，但稍后再说</span><br><span class="line">执行完 fn 之后 又回到 poll 阶段 继续等。 一般来说有最长等待时间 假设3秒 后就会进入 check 然后进入 times 然后继续进入 poll</span><br><span class="line">所以 大部分时间都是在 poll 阶段 用来等</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="check-阶段是什么？"><a href="#check-阶段是什么？" class="headerlink" title="check 阶段是什么？"></a>check 阶段是什么？</h4></blockquote>
<ul>
<li>Node.js 除了 setTimeout 还有 setImmediate(fn2) </li>
<li>当你调用 <code>setImmediate(fn2)</code> 的时候 你的 fn2 不会进入 times 阶段，会进入 check阶段</li>
<li>check 阶段也是有 一个队列的 主要是用来存 <code>setImmediate</code> 执行的函数的</li>
</ul>
<blockquote>
<p>来个考题, 先执行 fn 还是先执行 fn2</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(fn,0)</span><br><span class="line">setImmediate(fn2)</span><br><span class="line">// 答案是 fn2</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">setTimeout(fn,0) 执行后 会进入 times 阶段 把 fn 放入 times 的队列里 </span><br><span class="line">然后看到下一句代码</span><br><span class="line">setImmediate(fn2)  会把 fn2 放入 check 阶段的队列里 ， 并立即执行队列里的fn2。 </span><br><span class="line">于是JS开始做事了， 它看到 check 队列里有个需要立即执行的 于是就不停了 ，直接 fn2执行掉</span><br><span class="line">然后到 times 阶段 刚好发现 times 队列里 有个 0秒后执行，于是 执行 fn</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="一个坑-开启-Eventloop-这是需要消耗时间的"><a href="#一个坑-开启-Eventloop-这是需要消耗时间的" class="headerlink" title="一个坑 开启 Eventloop() 这是需要消耗时间的"></a>一个坑 开启 Eventloop() 这是需要消耗时间的</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 在 node环境下 运行这两句</span><br><span class="line">setTimeout(()=&gt;&#123;console.log(&apos;fn&apos;)&#125;,0)</span><br><span class="line">setImmediate(()=&gt;&#123;console.log(&apos;fn2&apos;)&#125;)</span><br><span class="line"></span><br><span class="line">// 你会惊讶的发现 有的时候 fn fn2 有的时候 fn2 fn</span><br><span class="line"></span><br><span class="line">// 为什么？</span><br><span class="line">如果说 开启 Eventloop 很快 那么就是你分析的顺序 fn2 fn</span><br><span class="line">如果 Eventloop 开启很慢 我们在执行js的时候 可能还没进入 times 实际上是先把 fn 加到 times 队列里 然后在开始第一阶段</span><br><span class="line"></span><br><span class="line">这就刚好解释了 为什么顺序是不确定的？</span><br><span class="line">就是看 进入 times 阶段的时候 fn 就存在 还是 进入 times 阶段的时候 fn 不存在</span><br></pre></td></tr></table></figure>
<p>如何解决这种情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;console.log(&apos;fn&apos;)&#125;,0)</span><br><span class="line">    setImmediate(()=&gt;&#123;console.log(&apos;fn2&apos;)&#125;)</span><br><span class="line">&#125;,1000)</span><br><span class="line"></span><br><span class="line">// 这样每次都是  fn2 fn</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="process-nextTick-是放到什么阶段"><a href="#process-nextTick-是放到什么阶段" class="headerlink" title="process.nextTick 是放到什么阶段"></a>process.nextTick 是放到什么阶段</h4></blockquote>
<ul>
<li>首先它不属于 Eventloop 的任何一个阶段，官网说的，其他都是瞎扯的</li>
<li>process.nextTick 意思就是 当前阶段结束后马上执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;console.log(&apos;fn&apos;)&#125;,0)</span><br><span class="line">    setImmediate(()=&gt;&#123;console.log(&apos;fn2&apos;)&#125;)</span><br><span class="line">    process.nextTick(()=&gt;&#123;console.log(&apos;fn3&apos;)&#125;)</span><br><span class="line">&#125;,1000)</span><br><span class="line"></span><br><span class="line">// 注意！！！ nextTick 不属于 Eventloop 任何阶段 ， 它的意思是当前阶段马上执行</span><br><span class="line">//  setImmediate 会在 setTimeout之前</span><br><span class="line">// setImmediate 是从 poll 阶段 进入 check 才执行</span><br><span class="line">// nextTick 是当前阶段 poll 所以先 nextTick 在 check 阶段里的 然后 times 里的</span><br><span class="line">/*</span><br><span class="line">fn3</span><br><span class="line">fn2</span><br><span class="line">fn</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(()=&#123;</span><br><span class="line">    console.log(&quot;setImmediate1&quot;)</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">        console.log(&quot;setTimeout1&quot;)</span><br><span class="line">        </span><br><span class="line">    &#125;,0)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(()=&#123;</span><br><span class="line">    console.log(&quot;setTimeout2&quot;)</span><br><span class="line">    setImmediate(()=&gt;&#123;</span><br><span class="line">        console.log(&quot;setImmediate2&quot;)</span><br><span class="line">        </span><br><span class="line">    &#125;,0)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">答案是：</span><br><span class="line">setImmediate1</span><br><span class="line">setTimeout2</span><br><span class="line">setTimeout1</span><br><span class="line">setImmediate2</span><br><span class="line"></span><br><span class="line">// 务必画图分析</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>Eventloop 状态转移</p>
</blockquote>
<ul>
<li>Node.js 有六个阶段 简化为三个 <ul>
<li>times</li>
<li>poll</li>
<li>check</li>
</ul>
</li>
<li>Chrome （一会，马上）(宏任务，微任务)</li>
</ul>
<blockquote>
<p>Node.js</p>
</blockquote>
<ul>
<li>setTimeout =&gt; times</li>
<li>setImmediate =&gt; check</li>
<li>nextTick =&gt; 当前阶段结束后执行</li>
</ul>
<blockquote>
<p>Chrome</p>
</blockquote>
<ul>
<li>setTimeout =&gt; 宏任务</li>
<li>promise.then =&gt; 微任务<ul>
<li>注意！ 面试喜欢问 await <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">await 转换成 promise</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>面试题</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">async function async1()&#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">    await async2()</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function async2()&#123;</span><br><span class="line">    console.log(3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line">new Promise(function(resolve)&#123;</span><br><span class="line">    console.log(4)</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(function()&#123;</span><br><span class="line">    console.log(5)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p><strong>首先改写所有的 await</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">async function async1()&#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">    async2().then(f1)</span><br><span class="line">    function f1()&#123;</span><br><span class="line">        console.log(2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function async2()&#123;</span><br><span class="line">    console.log(3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line">new Promise(function(resolve)&#123;</span><br><span class="line">    console.log(4)</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(f2)</span><br><span class="line"></span><br><span class="line">function f2()&#123;</span><br><span class="line">    console.log(5)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">在看 首先 async1()执行 打印1</span><br><span class="line">async2() 执行 打印3</span><br><span class="line">async2().then() 把 f1 存入 微任务 </span><br><span class="line">new Promsie 开始 打印4</span><br><span class="line">把 new Promise().then(f2) 的 f2 存入 微任务</span><br><span class="line">开始执行微任务队列里的内容</span><br><span class="line">f1 执行 打印 2</span><br><span class="line">f2 执行 打印 5</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<blockquote>
<p>面试</p>
</blockquote>
<ul>
<li>一定要画图</li>
<li>一定要画图</li>
<li>一定要画图</li>
</ul>
<h4 id="个性化题目的面试如何处理"><a href="#个性化题目的面试如何处理" class="headerlink" title="个性化题目的面试如何处理"></a>个性化题目的面试如何处理</h4><p>只有某些公司会问，80%的公司不会问的题</p>
<ul>
<li>PWA</li>
<li>echarts / d3.js</li>
<li>three.js</li>
<li>flutter</li>
<li>SSR</li>
</ul>
<blockquote>
<h4 id="如何准备"><a href="#如何准备" class="headerlink" title="如何准备"></a>如何准备</h4></blockquote>
<p><strong>平时用不到，公司太小众了， 但是面试问？</strong></p>
<ul>
<li>先看公司招聘启事，如果明确说了，用到某某技术，你就去看文档，搞出一个 hello world</li>
<li>因为大部分跟你一起面试的人根本就不会对这些东西做任何准备，你只要比他们多准备一点点，就可以了</li>
<li>你不在乎你比别人多厉害，而在乎只要比别人厉害一点</li>
<li>如果你没做，被问到，你连接话的地方都没有那岂不是很尴尬。所以你做个Hello World 都能改善局面</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/05/Node-JS专精12-01Eventloop/" data-id="ckl3ypv22009usi91supzwuhk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node后端/">Node后端</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Node-JS专精11-04async-await问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/04/Node-JS专精11-04async-await问题/" class="article-date">
  <time datetime="2020-03-04T09:53:22.000Z" itemprop="datePublished">2020-03-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/04/Node-JS专精11-04async-await问题/">Node-JS专精11_04async_await问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="问题整理"><a href="#问题整理" class="headerlink" title="问题整理"></a>问题整理</h3><blockquote>
<h4 id="async-await-是-promise-的语法糖如何用-promise-实现-async-await"><a href="#async-await-是-promise-的语法糖如何用-promise-实现-async-await" class="headerlink" title="async / await 是 promise 的语法糖如何用 promise 实现 async/await"></a>async / await 是 promise 的语法糖如何用 promise 实现 async/await</h4></blockquote>
<ul>
<li>答：有的语法糖好改写，有的语法糖不好改写。这个语法糖就不好改写，因为这是语言层面的改动，而不是API层面的。可以举例说明</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// API层面语法糖</span><br><span class="line">如 promise 的 catch 改写成  promise.then(null,fn)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// await 改写</span><br><span class="line">async function fn()&#123;</span><br><span class="line">    const res = await ajax();</span><br><span class="line">    console.log(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn2()&#123;</span><br><span class="line">    ajax().then((res)=&gt;&#123;</span><br><span class="line">        console.log(res)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="有些-await-需要等待上一个-await-的结果，有些不用，如何让不用同步的-await-异步执行"><a href="#有些-await-需要等待上一个-await-的结果，有些不用，如何让不用同步的-await-异步执行" class="headerlink" title="有些 await 需要等待上一个 await 的结果，有些不用，如何让不用同步的 await 异步执行"></a>有些 await 需要等待上一个 await 的结果，有些不用，如何让不用同步的 await 异步执行</h4></blockquote>
<ul>
<li>答：其实非常简单</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">async function fn()&#123;</span><br><span class="line">    await getUser()</span><br><span class="line">    await getProducts();</span><br><span class="line">    // 你想要 getOthers 不等前两个同步结果，非常简单 把它放到 前面就行了</span><br><span class="line">    getOthers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 处理方式</span><br><span class="line">async function fn2()&#123;</span><br><span class="line">    getOthers();</span><br><span class="line">    await getUser()</span><br><span class="line">    await getProducts();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="如何实现一个监控，调用异步请求一直等待，监控某个值变了就执行回调"><a href="#如何实现一个监控，调用异步请求一直等待，监控某个值变了就执行回调" class="headerlink" title="如何实现一个监控，调用异步请求一直等待，监控某个值变了就执行回调"></a>如何实现一个监控，调用异步请求一直等待，监控某个值变了就执行回调</h4></blockquote>
<ul>
<li>答：不太清楚你的场景，不过 Vue2 已经做到了这一点，用 Object.defineProperty ,也可以用Proxy方案</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ajax = function()&#123;</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        resolve(&#123;</span><br><span class="line">            data:&#123;name:&apos;a&apos;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var data =&#123;</span><br><span class="line">  name:&apos;sss&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var vm = &#123;&#125;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(vm,&apos;name&apos;,&#123;</span><br><span class="line">  set(newValue)&#123;</span><br><span class="line">    data.name = newValue</span><br><span class="line">  &#125;,</span><br><span class="line">  get()&#123;</span><br><span class="line">      return data.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ajax().then(res=&gt;&#123;</span><br><span class="line">   console.log(res.data);</span><br><span class="line">   vm.name = res.data.name</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="代码题"><a href="#代码题" class="headerlink" title="代码题"></a>代码题</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let a = 0;</span><br><span class="line">let test = async()=&gt;&#123;</span><br><span class="line">    a = a + await 10;</span><br><span class="line">    console.log(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(); </span><br><span class="line">console.log(++a);</span><br><span class="line"></span><br><span class="line">// test 是个异步的 所以不会执行 先去打印</span><br></pre></td></tr></table></figure>
<ul>
<li>答：倒数第二行有坑</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">答案是 </span><br><span class="line">1</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">为什么？是10 你一定认为是 11</span><br><span class="line"></span><br><span class="line">// 改写下代码继续运行 打印 test时 a + </span><br><span class="line">let a = 0;</span><br><span class="line">let test = async()=&gt;&#123;</span><br><span class="line">    a = (console.log(&apos;a:&apos;+ a),a) + await 10;</span><br><span class="line">    console.log(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(); </span><br><span class="line">console.log(++a);</span><br><span class="line"></span><br><span class="line">// 原因就是 我们一直认为 await 的右边会立刻执行 await 是等一会执行的</span><br><span class="line">但是如果他用 加号的时候 就不能这样算 因为你不是 `a + await 10` 而是先确定 a的值</span><br></pre></td></tr></table></figure>
<h4 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h4><ul>
<li><a href="https://juejin.im/post/5cd8e7e251882568b664f459" target="_blank" rel="noopener">async/await 之于 Promise，正如 do 之于 monad（译文）</a></li>
<li>结论就是 Promise 是JS里非常重要的概念，所以我们更应该理解 Promise 而不是 await async</li>
</ul>
<blockquote>
<p>只有在一行代码的情况下</p>
</blockquote>
<ul>
<li>用 await 最好的</li>
<li>如果情况变复杂了，还是要 Promise</li>
<li>并行的情况，也要用 Promise.all</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/04/Node-JS专精11-04async-await问题/" data-id="ckl3ypv20009psi91r0n4yn4g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node后端/">Node后端</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Node-JS专精11-03async-await" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/04/Node-JS专精11-03async-await/" class="article-date">
  <time datetime="2020-03-04T06:15:12.000Z" itemprop="datePublished">2020-03-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/04/Node-JS专精11-03async-await/">Node-JS专精11_03async_await</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="async-await"><a href="#async-await" class="headerlink" title="async / await"></a>async / await</h3><blockquote>
<p>常用用法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const fn = async () =&gt; &#123;</span><br><span class="line">    // makePromise 返回 promise的函数</span><br><span class="line">    const temp = await makePromise()</span><br><span class="line">    return temp + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这个 makePromise 如果成功了就会返回一个值</span><br><span class="line">// 如果失败了，就会报错，你就必须用 try / catch 才能拿到那个值，但是也不一定后面会说</span><br></pre></td></tr></table></figure>
<blockquote>
<p>优点</p>
</blockquote>
<ul>
<li>完全没有缩进，就像是写同步代码</li>
</ul>
<h4 id="封装一个-async-函数"><a href="#封装一个-async-函数" class="headerlink" title="封装一个 async 函数"></a>封装一个 async 函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">async function 摇骰子()&#123;</span><br><span class="line">  return Math.floor(Math.random()*6)+1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果需要 reject , 直接 throw Error(&apos;xxx&apos;)</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line"></span><br><span class="line">async function fn()&#123;</span><br><span class="line">  const result = await 摇骰子();</span><br><span class="line">  console.log(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果需要处理错误，可以 try catch</span><br><span class="line"></span><br><span class="line">fn(); // 直接打印摇骰子结果</span><br></pre></td></tr></table></figure>
<p><strong>但是如果想要 3秒后得到摇骰子的结果 就就没法直接写，必须有一个 Promise</strong></p>
<blockquote>
<p>实现3秒后摇骰子</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function 摇骰子3秒后()&#123;</span><br><span class="line">  return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">      setTimeout(()=&gt;&#123;</span><br><span class="line">          resolve(Math.floor(Math.random()*6)+1)</span><br><span class="line">      &#125;,3000)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function fn2()&#123;</span><br><span class="line">  const result = await 摇骰子3秒后();</span><br><span class="line">  console.log(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn2()</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="抛出错误-解惑错误"><a href="#抛出错误-解惑错误" class="headerlink" title="抛出错误 / 解惑错误"></a>抛出错误 / 解惑错误</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">async function 摇骰子()&#123;</span><br><span class="line">    throw new Error(&apos;骰子坏了&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function fn()&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        var result = await 摇骰子()</span><br><span class="line">        console.log(result);</span><br><span class="line">    &#125; catch(e)&#123;</span><br><span class="line">        console.log(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>
<h4 id="为什么需要-async"><a href="#为什么需要-async" class="headerlink" title="为什么需要 async"></a>为什么需要 async</h4><ul>
<li>await 所在的函数不就是 async 函数吗？ 但是为什么还是要加上 async声明</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function 摇骰子()&#123;</span><br><span class="line">    throw new Error(&apos;骰子坏了&apos;)</span><br><span class="line">&#125;</span><br><span class="line">// 删掉 async</span><br><span class="line">function fn()&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        var result = await 摇骰子()</span><br><span class="line">        console.log(result);</span><br><span class="line">    &#125; catch(e)&#123;</span><br><span class="line">        console.log(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>
<ul>
<li>原因是在 await出现之前，有些人自己写了 await</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 旧代码，自己实现的 await</span><br><span class="line">function fn()&#123;</span><br><span class="line">    var res = await(摇骰子())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么加了 async</p>
</blockquote>
<ul>
<li>由于那些自己实现 await 的人来说 ，如果 await 不配合 async 直接发布它的代码就不能用，<strong>不兼容</strong></li>
<li>如何兼容呢？ 于是JS设计者想到的是 在外面包一层 来加以区别</li>
<li>最终原因只有一个：<strong>兼容旧代码里，普通函数里的 await(xxx)</strong> 所以在所有出现 await 的地方外面加了一个 async</li>
</ul>
<h4 id="await的错误处理"><a href="#await的错误处理" class="headerlink" title="await的错误处理"></a>await的错误处理</h4><blockquote>
<p>常见方式</p>
</blockquote>
<ul>
<li>一个字：丑</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fn()&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        var result = await axios.get(&apos;/xxx&apos;)</span><br><span class="line">        console.log(result);</span><br><span class="line">    &#125; catch(e)&#123;</span><br><span class="line">        console.log(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="正确姿势"><a href="#正确姿势" class="headerlink" title="正确姿势"></a>正确姿势</h4></blockquote>
<ul>
<li>then 和 await 结合使用，在 then 里处理异步错误， await只接受成功的结果</li>
<li>能处理90%的情况</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const result = await axios.get(&apos;/xxx&apos;).then(null,errorHandler)</span><br><span class="line">console.log(result)</span><br><span class="line">// 错误处理放在 then里面</span><br></pre></td></tr></table></figure>
<blockquote>
<p>细节</p>
</blockquote>
<ul>
<li>可以把 4xx/5xx等常见错误用拦截器全局处理</li>
<li>await只关心成功，失败全部交给 errorHandler</li>
<li>errorHandler 也可以放在拦截器里</li>
</ul>
<p><strong>示例代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ajax = function()&#123;</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        /*</span><br><span class="line">        // 成功处理</span><br><span class="line">        resolve(&#123;</span><br><span class="line">            data:&#123;name:&apos;a&apos;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        */</span><br><span class="line">        reject(&#123;</span><br><span class="line">            response:&#123;status:403&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var error = (e)=&gt;&#123;</span><br><span class="line">    console.log(e)</span><br><span class="line">    console.log(&apos;提示用户没有权限&apos;)</span><br><span class="line">    throw e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function fn()&#123;</span><br><span class="line">    const response = await ajax().then(null,error)</span><br><span class="line">    console.log(response) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>
<h4 id="await-的传染性"><a href="#await-的传染性" class="headerlink" title="await 的传染性"></a>await 的传染性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(1)</span><br><span class="line">await console.log(2)</span><br><span class="line">console.log(3)</span><br><span class="line"></span><br><span class="line">导致 3 要等一会才被打印，因为有 await, 导致它下面的代码变成异步任务</span><br></pre></td></tr></table></figure>
<blockquote>
<p>分析</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(3) 变成异步任务了</span><br><span class="line">Promise 同样具有传染性 (同步变异步)</span><br><span class="line">谁没有传染性 ： 回调</span><br></pre></td></tr></table></figure>
<h4 id="await-应用场景"><a href="#await-应用场景" class="headerlink" title="await 应用场景"></a>await 应用场景</h4><blockquote>
<p>多次处理一个结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const s1 = await makePromise();</span><br><span class="line">const s2 = handlerR1(r1)</span><br><span class="line">const s3 = handlerR2(r2)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>串行</p>
</blockquote>
<ul>
<li><p>天生串行</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async function fn()&#123;</span><br><span class="line">    await ajax1();</span><br><span class="line">    await ajax2();</span><br><span class="line">    await ajax3();</span><br><span class="line">    await ajax4();</span><br><span class="line">    await ajax5();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>循环的时候有 bug </p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 实际上它是并行的</span><br><span class="line">async function fn()&#123;</span><br><span class="line">    var array = [ajax1, ajax2, ajax3]</span><br><span class="line">    for(let i=0;i&lt;array.length;i++)&#123;</span><br><span class="line">        await array[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">跟你直接这样 不一样</span><br><span class="line">await ajax1();</span><br><span class="line">await ajax2();</span><br><span class="line">await ajax3();</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 用 await 循环</span><br><span class="line">搜索关键字 for-await-of</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>并行</p>
</blockquote>
<ul>
<li>await Promise.all() 就是并行了</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/04/Node-JS专精11-03async-await/" data-id="ckl3ypv1z009nsi918b1kg315" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node后端/">Node后端</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Node-JS专精11-02Promise使用场景" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/04/Node-JS专精11-02Promise使用场景/" class="article-date">
  <time datetime="2020-03-04T03:23:03.000Z" itemprop="datePublished">2020-03-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/04/Node-JS专精11-02Promise使用场景/">Node-JS专精11_02Promise使用场景</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Promise使用场景"><a href="#Promise使用场景" class="headerlink" title="Promise使用场景"></a>Promise使用场景</h3><h4 id="多次处理一个结果"><a href="#多次处理一个结果" class="headerlink" title="多次处理一个结果"></a>多次处理一个结果</h4><ul>
<li><code>摇骰子.then(v =&gt; v1).then(v1 =&gt; v2)</code><ul>
<li>1 2 3 返回小 / 4 5 6 返回大</li>
</ul>
</li>
<li>在BOSS直聘上投递阿里简历流程： <ul>
<li>必须先有网</li>
<li>有网才能使用 BOSS直聘app或 pc</li>
<li>登录</li>
<li>从众多公司里搜索 阿里的 岗位</li>
<li>投递简历</li>
</ul>
</li>
</ul>
<h4 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h4><blockquote>
<p>一道网传面试题</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">页面有两个按A和B,以及一个输入框，</span><br><span class="line">A按钮点击后发送一个请求，返回一个字符串A</span><br><span class="line">B按钮点击后也发送一个请求，返回一个字符串B</span><br><span class="line">返回后会把返回的字符串赋值给输入框，但是 A 和 B发送的请求时间点不同，</span><br><span class="line">点击按钮的顺序也不一定，B要比A先返回，而最终效果要求是 输入框字符的顺序是 AB</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这道题实际就是日常你做的如下需求</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">你打开了  百度搜索，先输入 vue,(此时已经发送了 请求a ) ,然后输入 react (此时已经发送了 请求b)</span><br><span class="line"></span><br><span class="line">好巧不巧的是  请求a 10秒返回结果  请求b 1秒返回结果</span><br><span class="line">此时 你如果按照正常的展示逻辑</span><br><span class="line"></span><br><span class="line">你肯定先展示 react的结果 ， 然后在展示 vue的结果</span><br><span class="line">此时用户觉得你神经病 ， 我明明搜的 react 你给我展示 vue的结果</span><br><span class="line"></span><br><span class="line">此时你就要保证就算 react的结果先回来，我也要等到 vue的结果展示了之后在展示</span><br></pre></td></tr></table></figure>
<p>正确处理的姿势：只要有一个结果返回了 就把之前的请求取消掉 ajax.cancel</p>
<blockquote>
<p>生活中的高铁进站例子</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a 和 b 两个人，分别去高铁app上买了去 北京的票 如C2212</span><br><span class="line">b 比 a先买到票，但是检票的时候，a站在 b前面。</span><br><span class="line">所以 无论如何，b都要在 a之后进入车厢</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码实例</p>
</blockquote>
<ul>
<li>点击 a 按钮后立刻点击 b按钮</li>
<li>3秒后 输入框显示 “bbb”  </li>
<li>5秒后显示 “aaa”</li>
</ul>
<p><strong>我们想要的结果是，不管那个结果回来，都最后显示”bbb”</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button id=&quot;a&quot;&gt;a&lt;/button&gt;</span><br><span class="line">&lt;button id=&quot;b&quot;&gt;b&lt;/button&gt;</span><br><span class="line">&lt;input id=&quot;input&quot; type=&quot;text&quot;&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">let ajax1 = function()&#123;</span><br><span class="line">  return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">      resolve(&quot;aaa&quot;)</span><br><span class="line">    &#125;,5000)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let ajax2 = function()&#123;</span><br><span class="line">  return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">      resolve(&quot;bbbb&quot;)</span><br><span class="line">    &#125;,3000)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.onclick = ()=&gt;&#123;</span><br><span class="line">  ajax1().then((s)=&gt;&#123;</span><br><span class="line">    input.value = s</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b.onclick = ()=&gt;&#123;</span><br><span class="line">  ajax2().then((s)=&gt;&#123;</span><br><span class="line">    input.value = s</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;  </span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>生活中的点餐取餐例子</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">餐厅有两个窗口 点餐 / 取餐</span><br><span class="line">a 和 b 两个人 先后进入餐厅的点餐队列进行点餐 a 在 b 之前点餐了</span><br><span class="line">a 点餐制作耗时 15分钟</span><br><span class="line">b 点餐制作耗时 10分钟</span><br><span class="line"></span><br><span class="line">a 和 b 点餐完成后， 又依次站在 取餐队列里 a在 b之前</span><br><span class="line">10分钟后 b的餐好了，</span><br><span class="line">但是 a 在 b之前， b 无法取餐</span><br><span class="line">15分钟 a 的餐好了</span><br><span class="line">a 取餐成功</span><br><span class="line">于是轮到 b ， b取餐成功</span><br></pre></td></tr></table></figure>
<p>代码示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button id=&quot;a&quot;&gt;a&lt;/button&gt;</span><br><span class="line">&lt;button id=&quot;b&quot;&gt;b&lt;/button&gt;</span><br><span class="line">&lt;input id=&quot;input&quot; type=&quot;text&quot;&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">let ajax1 = function()&#123;</span><br><span class="line">  return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">      resolve(&quot;aaa&quot;)</span><br><span class="line">    &#125;,5000)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let ajax2 = function()&#123;</span><br><span class="line">  return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">      resolve(&quot;bbbb&quot;)</span><br><span class="line">    &#125;,3000)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var 取餐队伍 = [];</span><br><span class="line">var 吧台 = [];</span><br><span class="line">var 问 = ()=&gt;&#123;</span><br><span class="line">  var lastN = 吧台[吧台.length -1][0];</span><br><span class="line">  var lastS = 吧台[吧台.length -1][1];</span><br><span class="line">  if(取餐队伍[0][0] === lastN)&#123;</span><br><span class="line">    取餐队伍[0][1](lastS);</span><br><span class="line">    取餐队伍.shift();</span><br><span class="line">    吧台.pop();</span><br><span class="line">    问();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.onclick = ()=&gt;&#123;</span><br><span class="line">  let n = Math.random();</span><br><span class="line">  ajax1().then((s)=&gt;&#123;</span><br><span class="line">    吧台.push([n,s])</span><br><span class="line">    问();</span><br><span class="line">  &#125;)</span><br><span class="line">  取餐队伍.push([n,(s)=&gt;&#123;</span><br><span class="line">    input.value = s;</span><br><span class="line">  &#125;])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b.onclick = ()=&gt;&#123;</span><br><span class="line">  let n = Math.random();</span><br><span class="line">  ajax2().then((s)=&gt;&#123;</span><br><span class="line">    吧台.push([n,s])</span><br><span class="line">    问();</span><br><span class="line">  &#125;)</span><br><span class="line">  取餐队伍.push([n,(s)=&gt;&#123;</span><br><span class="line">    input.value = s;</span><br><span class="line">  &#125;])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h4 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h4><ul>
<li>Promise.all([task1,task2]) 不好用(可以自己写一个，参考上一篇文章)</li>
<li>Promise.allSettled 又太新</li>
</ul>
<h3 id="Promise的错误处理"><a href="#Promise的错误处理" class="headerlink" title="Promise的错误处理"></a>Promise的错误处理</h3><blockquote>
<p>其实挺好用的</p>
</blockquote>
<ul>
<li>promise.then(s1,f1) 即可</li>
<li>如果我想全局处理(以 axios 为例 参考它的拦截器)<ul>
<li><a href="https://juejin.im/post/5a9cddb46fb9a028bc2d3c2f" target="_blank" rel="noopener">axios 作弊表</a> 拦截器章节<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.response.use(function (response) &#123;</span><br><span class="line">    // Do something with response data</span><br><span class="line">    return response;</span><br><span class="line">&#125;, function (error) &#123;</span><br><span class="line">    // Do something with response error</span><br><span class="line">    return Promise.reject(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>语法糖</p>
</blockquote>
<ul>
<li><code>promise.then(s1).catch(f1)</code></li>
</ul>
<blockquote>
<p>错误处理之后</p>
</blockquote>
<ul>
<li>如果你没有继续抛错，那么错误不再出现</li>
<li>如果你继续抛出错误， 那么后续回调就继续处理错误</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// </span><br><span class="line">Promise.resolve(`&#123;&apos;name&apos;:&apos;frank&apos;&#125;`)</span><br><span class="line">    .then( s =&gt; JSON.parse(s)) // parse 失败 json 的 key必须是双引号</span><br><span class="line">    .then( null, (reason) =&gt; console.log(&quot;err:&quot; + reason)) // 继续 promise 里处理</span><br></pre></td></tr></table></figure>
<h4 id="但是有人对-Promise-不满意"><a href="#但是有人对-Promise-不满意" class="headerlink" title="但是有人对 Promise 不满意"></a>但是有人对 Promise 不满意</h4><ul>
<li><a href="https://blog.fundebug.com/2017/04/04/nodejs-async-await/" target="_blank" rel="noopener">Async/Await替代Promise的6个理由</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/04/Node-JS专精11-02Promise使用场景/" data-id="ckl3ypv1y009ksi916mklz0zb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node后端/">Node后端</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Node-JS专精11-01Promise精讲" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/04/Node-JS专精11-01Promise精讲/" class="article-date">
  <time datetime="2020-03-04T01:33:52.000Z" itemprop="datePublished">2020-03-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/04/Node-JS专精11-01Promise精讲/">Node-JS专精11_01Promise精讲</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><blockquote>
<p>先看代码</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function 摇骰子()&#123;</span><br><span class="line">    return new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            const result = Math.floor(Math.random()*6+1)</span><br><span class="line">            resolve(result)</span><br><span class="line">        &#125;, 3000);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 摇骰子() // 此时返回的是一个 promise</span><br><span class="line"></span><br><span class="line">摇骰子().then((res)=&gt;&#123;console.log(res)&#125;) // 3秒后返回摇骰子的结果</span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="这是一个异步任务，那么问题来了-异步任务什么时候执行？"><a href="#这是一个异步任务，那么问题来了-异步任务什么时候执行？" class="headerlink" title="这是一个异步任务，那么问题来了 异步任务什么时候执行？"></a>这是一个异步任务，那么问题来了 异步任务什么时候执行？</h3></blockquote>
<ul>
<li>改写了一下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function 摇骰子()&#123;</span><br><span class="line">    return new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">        const result = Math.floor(Math.random()*6+1)</span><br><span class="line">        resolve(result)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">摇骰子().then((res)=&gt;&#123;console.log(res)&#125;)  // 会立刻返回 摇骰子的结果，但是它是什么时候开始呢？</span><br></pre></td></tr></table></figure>
<h3 id="面试中的-微任务-宏任务"><a href="#面试中的-微任务-宏任务" class="headerlink" title="面试中的 微任务/宏任务"></a>面试中的 微任务/宏任务</h3><p>看这样一段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button id=&quot;btn1&quot;&gt;btn1&lt;/button&gt;</span><br><span class="line">&lt;button id=&quot;btn2&quot;&gt;btn2&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">// Promise</span><br><span class="line">function 摇骰子()&#123;</span><br><span class="line">  return new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">      const result = Math.floor(Math.random()*6+1)</span><br><span class="line">      resolve(result)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btn1.onclick=()=&gt;&#123;</span><br><span class="line">  摇骰子().then(n=&gt;console.log(`摇到了$&#123;n&#125;`))</span><br><span class="line">  console.log(&quot;end&quot;);</span><br><span class="line">  // 执行结果：很明显 我们知道  摇骰子 是异步任务 所以会晚于 同步代码 console.log</span><br><span class="line">  /*</span><br><span class="line">  &quot;end&quot;</span><br><span class="line">  &quot;摇到了1&quot;</span><br><span class="line">  */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btn2.onclick=()=&gt;&#123;</span><br><span class="line">  setTimeout(()=&gt;&#123;console.log(&quot;timeout1&quot;),0&#125;)</span><br><span class="line">  摇骰子().then(n=&gt;console.log(`摇到了$&#123;n&#125;`))</span><br><span class="line">  setTimeout(()=&gt;&#123;console.log(&quot;timeout2&quot;),0&#125;)</span><br><span class="line">  // 执行结果</span><br><span class="line">  // 如果我们还有其他的异步任务 比如 setTimeout 那么谁会优先呢？</span><br><span class="line">  // 答案是 先打出骰子的点数</span><br><span class="line">  /*</span><br><span class="line">  &quot;摇到了1&quot;</span><br><span class="line">  &quot;timeout1&quot;</span><br><span class="line">  &quot;timeout2&quot;</span><br><span class="line">  */</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h4 id="微任务-宏任务这些前端名词的前因后果"><a href="#微任务-宏任务这些前端名词的前因后果" class="headerlink" title="微任务/宏任务这些前端名词的前因后果"></a>微任务/宏任务这些前端名词的前因后果</h4><ul>
<li>本来是没有 Promise的 在 ES6之前，ES6之后才有了 Promise这种异步</li>
<li>以前的JS非常单纯只有两个东西<ul>
<li>当前任务 执行的代码(同步代码) </li>
<li>延时任务 setTimeout / setInterval</li>
</ul>
</li>
</ul>
<blockquote>
<h4 id="ES6以前"><a href="#ES6以前" class="headerlink" title="ES6以前"></a>ES6以前</h4></blockquote>
<ul>
<li>当前代码 如<code>console.log(1)</code></li>
<li>异步队列 setTimeout </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">console.log(1)</span><br><span class="line">console.log(2)</span><br><span class="line">setTimeout(()=&gt;&#123;console.log(&quot;timeout 1&quot;)&#125;,0)</span><br><span class="line">setTimeout(()=&gt;&#123;console.log(&quot;timeout 2&quot;)&#125;,0)</span><br><span class="line">console.log(3)</span><br><span class="line">console.log(4)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">timeout 1</span><br><span class="line">timeout 2</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">两次 setTimeout 不会立刻执行，而是放入异步队列里</span><br><span class="line">当前代码执行完了 就去看异步队列了</span><br></pre></td></tr></table></figure>
<p><strong>所以以前的js非常好理解，就是我有个当前要执行的任务，和有个等待执行的任务</strong></p>
<blockquote>
<h4 id="ES6之后"><a href="#ES6之后" class="headerlink" title="ES6之后"></a>ES6之后</h4></blockquote>
<p>前端觉得回调太蛋疼了，于是加了个 Promise</p>
<ul>
<li>宏任务 – 异步队列1（原来的异步队列 setTimeout）</li>
<li>微任务 – 异步队列2 (Promise 使用)</li>
<li>同步代码 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 伪代码</span><br><span class="line">ajax.then(s1)</span><br><span class="line">setTimeout(()=&gt;&#123;console.log(&quot;timeout&quot;)&#125;,0)</span><br><span class="line">console.log(1);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">依然  console.log 放入同步任务</span><br><span class="line">setTimeout 放入异步任务</span><br><span class="line"></span><br><span class="line">此时 ，如果不引入其他东西 ajax.then(s1) 就显得特别智障</span><br><span class="line">    假设只有一个异步任务 那么实际就是 把 s1 加入异步队列1 ， 然后把第二行的 setTimeout 加入异步队列1 s1之后</span><br><span class="line"></span><br><span class="line">    于是你惊讶的发现，那我要 then 干什么，有病吧？ 直接 setTimeout(s1,0) 不就完了</span><br><span class="line"></span><br><span class="line">所以他们就想了一个 让我们的 then 更有用的办法 ，在加一个 异步队列2</span><br><span class="line"></span><br><span class="line">于是乎上面的代码</span><br><span class="line">s1 放入 异步队列2</span><br><span class="line">setTimeout 放入 异步队列1</span><br><span class="line"></span><br><span class="line">当 同步代码执行完</span><br><span class="line">先去读取 异步队列2 里的任务 去执行</span><br><span class="line">等 异步队列2 里的任务执行完了， 再去读取 异步队列1 里的任务 去执行</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p><strong>于是分别给 异步队列1 / 异步队列2 取了个名字叫做 宏任务 / 微任务</strong></p>
<p><strong>如果队列里有任务，先把 微任务 做完，再去做 宏任务</strong></p>
<h3 id="Promise-其他API"><a href="#Promise-其他API" class="headerlink" title="Promise 其他API"></a>Promise 其他API</h3><blockquote>
<p>继续以摇骰子为例</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function 摇骰子()&#123;</span><br><span class="line">  return new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">      const result = Math.floor(Math.random()*6+1)</span><br><span class="line">      resolve(result)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// 随机的</span><br><span class="line">摇骰子().then((res)=&gt;&#123;console.log(res)&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Promise.resolve(result) 制造一个成功(或失败)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 制造成功</span><br><span class="line">// 你想造假一直 摇6</span><br><span class="line"></span><br><span class="line">function 摇6的骰子()&#123;</span><br><span class="line">  return new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">      resolve(6)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function 摇6的骰子2()&#123;</span><br><span class="line">  return  Promise.resolve(6)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 摇6的骰子</span><br><span class="line">// 摇6的骰子().then((res)=&gt;&#123;console.log(res)&#125;)</span><br><span class="line">// 摇6的骰子2().then((res)=&gt;&#123;console.log(res)&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 制造失败</span><br><span class="line">function 摇骰子返回失败()&#123;</span><br><span class="line">  return  Promise.resolve(</span><br><span class="line">              new Promise((resolve,reject)=&gt;reject())</span><br><span class="line">          )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">摇骰子返回失败().then((res)=&gt;&#123;console.log(res)&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Promise.reject(reason) 制造一个失败</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function 摇坏的骰子()&#123;</span><br><span class="line">    return new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">        reject(&apos;坏了&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function 摇坏的骰子2()&#123;</span><br><span class="line">    return Promise.reject(&apos;坏了&apos;)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">摇坏的骰子().then(null,(reason)=&gt;console.log(reason))</span><br><span class="line">摇坏的骰子2().then(null,(reason)=&gt;console.log(reason))</span><br></pre></td></tr></table></figure>
</li>
<li><p>Promise.all(数组) 等待全部成功，或有一个失败</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 所有人都成功了，才叫成功 返回所有成功的结果</span><br><span class="line">Promise.all([Promise.resolve(1),Promise.resolve(2),Promise.resolve(3)]).then((res)=&gt;&#123;console.log(res)&#125;)</span><br><span class="line">// 打印 [1,2,3]</span><br><span class="line"></span><br><span class="line">// 某个失败 返回失败</span><br><span class="line">Promise.all([Promise.resolve(1),Promise.resolve(2),Promise.reject(&apos;错了3&apos;)]).then((res)=&gt;&#123;console.log(res)&#125;,(err)=&gt;&#123;console.log(err)&#125;)</span><br><span class="line">// 打印 &quot;错了3&quot;</span><br><span class="line"></span><br><span class="line">Promise.all([Promise.resolve(1&quot;),Promise.reject(&apos;错了2&apos;),Promise.reject(&apos;错了3&apos;)]).then((res)=&gt;&#123;console.log(res)&#125;,(err)=&gt;&#123;console.log(err)&#125;)</span><br><span class="line">// 打印 &quot;错了2&quot;</span><br><span class="line"></span><br><span class="line">Promise.all([Promise.reject(&quot;错了1&quot;),Promise.reject(&apos;错了2&apos;),Promise.reject(&apos;错了3&apos;)]).then((res)=&gt;&#123;console.log(res)&#125;,(err)=&gt;&#123;console.log(err)&#125;)</span><br><span class="line">// 打印 &quot;错了1&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>所以 Promise.all 非常没用,因为有一个失败就返回了不等所有的结果</li>
<li>请使用 <code>Promise.allSettled</code></li>
</ul>
</li>
<li><p>Promise.race(数组) 等待第一个状态改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同时发很多请求，只要又一个成功了，就成功，或者一个失败了就失败</span><br></pre></td></tr></table></figure>
</li>
<li><p>Promise.allSettled(数组) 等待全部状态改变,目前处于 Stage-4(板上钉钉的实现)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Promise.allSettled([Promise.resolve(1),Promise.resolve(2),Promise.resolve(3)]).then((res)=&gt;&#123;console.log(res)&#125;,(err)=&gt;&#123;console.log(err)&#125;)</span><br><span class="line">// resolve 打印</span><br><span class="line">/*</span><br><span class="line">[</span><br><span class="line">  &#123;status: &quot;fulfilled&quot;, value: 1&#125;,</span><br><span class="line">  &#123;status: &quot;fulfilled&quot;, value: 2&#125;,</span><br><span class="line">  &#123;status: &quot;fulfilled&quot;, value: 3&#125;</span><br><span class="line">]</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">Promise.allSettled([Promise.resolve(1),Promise.reject(&apos;错了2&apos;),Promise.resolve(3)]).then((res)=&gt;&#123;console.log(res)&#125;,(err)=&gt;&#123;console.log(err)&#125;)</span><br><span class="line">// reject 打印</span><br><span class="line">/*</span><br><span class="line">[</span><br><span class="line">  &#123;status: &quot;fulfilled&quot;, value: 1&#125;,</span><br><span class="line">  &#123;status: &quot;rejected&quot;, reason: &quot;错了2&quot;&#125;,</span><br><span class="line">  &#123;status: &quot;fulfilled&quot;, value: 3&#125;</span><br><span class="line">]</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">Promise.allSettled([Promise.reject(&quot;错了1&quot;),Promise.reject(&apos;错了2&apos;),Promise.reject(&apos;错了3&apos;)]).then((res)=&gt;&#123;console.log(res)&#125;,(err)=&gt;&#123;console.log(err)&#125;)</span><br><span class="line"></span><br><span class="line">// reject 打印</span><br><span class="line">/*</span><br><span class="line">[</span><br><span class="line">  &#123;status: &quot;rejected&quot;, reason: &quot;错了1&quot;&#125;,</span><br><span class="line">  &#123;status: &quot;rejected&quot;, reason: &quot;错了2&quot;&#125;,</span><br><span class="line">  &#123;status: &quot;rejected&quot;, reason: &quot;错了3&quot;&#125;</span><br><span class="line">]</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>由于<code>Promise.allSettled</code>很多浏览器不支持，我们依旧无法使用</p>
</blockquote>
<p>所以用 Promise.all 实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">// 假设还是三个 promise 任务  第一个和第二个会失败</span><br><span class="line">task1 = () =&gt; new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">  setTimeout(()=&gt;&#123;</span><br><span class="line">    reject(&quot;第一扇门关了&quot;)</span><br><span class="line">  &#125;,3000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">task2 = () =&gt; new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">  setTimeout(()=&gt;&#123;</span><br><span class="line">    reject(&quot;第二扇门关了&quot;)</span><br><span class="line">  &#125;,4000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">task3 = () =&gt; new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">  setTimeout(()=&gt;&#123;</span><br><span class="line">    resolve(&quot;第三扇门开了&quot;)</span><br><span class="line">  &#125;,5000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 如果这样</span><br><span class="line">// 发现第一个失败就 结束了</span><br><span class="line">Promise.all([task1(),task2(),task3()])</span><br><span class="line">  .then(null,(reason)=&gt;console.log(reason))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 正确姿势 把每个任务都 then一下 因为 Promise.then 会返回新的 promise</span><br><span class="line">Promise.all([</span><br><span class="line">          task1().then(()=&gt;(&#123;&quot;status&quot;:&quot;ok&quot;&#125;),()=&gt;(&#123;status:&quot;not ok&quot;&#125;)),</span><br><span class="line">          task2().then(()=&gt;(&#123;&quot;status&quot;:&quot;ok&quot;&#125;),()=&gt;(&#123;status:&quot;not ok&quot;&#125;)),</span><br><span class="line">          task3().then(()=&gt;(&#123;&quot;status&quot;:&quot;ok&quot;&#125;),()=&gt;(&#123;status:&quot;not ok&quot;&#125;)),</span><br><span class="line">          ])</span><br><span class="line">  .then((result)=&gt;console.log(result))</span><br><span class="line">/*</span><br><span class="line">[</span><br><span class="line">  &#123;status: &quot;not ok&quot;&#125;,</span><br><span class="line">  &#123;status: &quot;not ok&quot;&#125;,</span><br><span class="line">  &#123;status: &quot;ok&quot;&#125;</span><br><span class="line">]</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 优化代码 因为写的太重复了  </span><br><span class="line">setSuccessResult = (promise) =&gt; promise.then(</span><br><span class="line">                                        (value)=&gt;(&#123;status:&quot;ok&quot;,value&#125;),</span><br><span class="line">                                        (reason)=&gt;(&#123;status:&quot;not ok&quot;,reason&#125;),</span><br><span class="line">                                        )</span><br><span class="line">Promise.all([</span><br><span class="line">          setSuccessResult(task1()),</span><br><span class="line">          setSuccessResult(task2()),</span><br><span class="line">          setSuccessResult(task3()),</span><br><span class="line">          ])</span><br><span class="line">  .then((result)=&gt;console.log(result))                                     </span><br><span class="line">// 打印结果</span><br><span class="line">/*</span><br><span class="line">[</span><br><span class="line">  &#123;status: &quot;not ok&quot;, reason: &quot;第一扇门关了&quot;&#125;</span><br><span class="line">  &#123;status: &quot;not ok&quot;, reason: &quot;第二扇门关了&quot;&#125;</span><br><span class="line">  &#123;status: &quot;ok&quot;, value: &quot;第三扇门开了&quot;&#125;</span><br><span class="line">]</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 还能再次简化</span><br><span class="line">setSuccessResultList = (promiseList) =&gt; promiseList.map(</span><br><span class="line">  promise =&gt; promise.then(</span><br><span class="line">                         (value)=&gt;(&#123;status:&quot;ok&quot;,value&#125;),</span><br><span class="line">                         (reason)=&gt;(&#123;status:&quot;not ok&quot;,reason&#125;)</span><br><span class="line">                        )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">Promise.all(setSuccessResultList([task1(),task2(),task3()]))</span><br><span class="line">  .then((result)=&gt;console.log(result))  </span><br><span class="line"></span><br><span class="line">// 再次简化 你不是不支持  Promise.allSettled 吗？</span><br><span class="line">Promise.allSettled2 = function(promiseList)&#123;</span><br><span class="line">  return Promise.all(setSuccessResultList(promiseList))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这其实就是 allSettled2 的实现</span><br><span class="line">Promise.allSettled2([task1(),task2(),task3()])</span><br><span class="line">  .then((result)=&gt;console.log(result))</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/04/Node-JS专精11-01Promise精讲/" data-id="ckl3ypv1x009isi912z1u15wg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node后端/">Node后端</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Node-JS专精10-02在浏览器支持nextTick" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/03/Node-JS专精10-02在浏览器支持nextTick/" class="article-date">
  <time datetime="2020-03-03T14:41:09.000Z" itemprop="datePublished">2020-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/03/Node-JS专精10-02在浏览器支持nextTick/">Node-JS专精10_02在浏览器支持nextTick</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a><a href="https://github.com/slTrust/promise-2/tree/58a31c016d2f5e6d38cf763c5db98ea0cd061b79" target="_blank" rel="noopener">代码仓库</a></h3><blockquote>
<h4 id="我们使用了-process-nextTick-代替-setTimeout"><a href="#我们使用了-process-nextTick-代替-setTimeout" class="headerlink" title="我们使用了 process.nextTick 代替 setTimeout"></a>我们使用了 process.nextTick 代替 setTimeout</h4></blockquote>
<ul>
<li>浏览器不支持 nextTick</li>
<li>如果你用过vue, 你知道vue提供了一个 nextTick,那么 vue是如何做到即支持 node又支持 浏览器呢？<ul>
<li><a href="https://juejin.im/entry/5aced80b518825482e39441e" target="_blank" rel="noopener">参考链接:全面解析Vue.nextTick实现原理</a></li>
<li>通过他的文章我们知道有 MutationObserver 这么一个东西，它比 setTimeout 的优先级更高</li>
<li>看看它的API<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver" target="_blank" rel="noopener">MutationObserver mdn</a></li>
</ul>
</li>
</ul>
<blockquote>
<h4 id="MutationObserver"><a href="#MutationObserver" class="headerlink" title="MutationObserver"></a>MutationObserver</h4></blockquote>
<p>它本来是监听 DOM树 的更新的，它有一个特别厉害的地方就是 当DOM树更新就会调用一个异步的回调，而这个回调的优先级比 setTimeout 要高</p>
<p><strong>示例代码</strong></p>
<ul>
<li>你可以拷贝代码在 <a href="https://jsbin.com/" target="_blank" rel="noopener">jsbin里运行</a></li>
<li>通过实例可以看到无论 setTimeout 在 span改变之前还是之后都没 MutationObserver 的优先级高</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;span id=&quot;aaa&quot;&gt;1&lt;/span&gt;</span><br><span class="line">  &lt;br&gt;</span><br><span class="line">  &lt;button id=&quot;btn&quot;&gt;+1&lt;/button&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">  </span><br><span class="line">  var span = document.getElementById(&apos;aaa&apos;);</span><br><span class="line"></span><br><span class="line">  var config = &#123; attributes: true, childList: true, subtree: true &#125;;</span><br><span class="line"></span><br><span class="line">  var callback = function() &#123;</span><br><span class="line">      console.log(&quot;observer&quot;)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  var observer = new MutationObserver(callback);</span><br><span class="line">  observer.observe(span, config);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  btn.onclick = function()&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;console.log(&quot;timeout1&quot;)&#125;,0)</span><br><span class="line">    span.innerText += &quot;s&quot;;</span><br><span class="line">    setTimeout(()=&gt;&#123;console.log(&quot;timeout2&quot;)&#125;,0)</span><br><span class="line">  &#125;</span><br><span class="line">  /*</span><br><span class="line">  每次点击button 始终打印</span><br><span class="line">  observer</span><br><span class="line">  timeout1</span><br><span class="line">  timeout2</span><br><span class="line">  */</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们自己实现一个 nextTick</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;button id=&quot;btn&quot;&gt;+1&lt;/button&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line"> </span><br><span class="line">  btn.onclick = function()&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;console.log(&quot;timeout1&quot;)&#125;,0)</span><br><span class="line">    nextTick(()=&gt;&#123;console.log(&quot;nextTick&quot;)&#125;)</span><br><span class="line">    setTimeout(()=&gt;&#123;console.log(&quot;timeout2&quot;)&#125;,0)</span><br><span class="line">  &#125;</span><br><span class="line">  /*</span><br><span class="line">  每次点击button 始终打印</span><br><span class="line">  nextTick</span><br><span class="line">  timeout1</span><br><span class="line">  timeout2</span><br><span class="line">  */</span><br><span class="line">  </span><br><span class="line">  function nextTick(fn)&#123;</span><br><span class="line">    var counter = 1</span><br><span class="line">    var observer = new MutationObserver(fn)</span><br><span class="line">    var textNode = document.createTextNode(String(counter))</span><br><span class="line">    observer.observe(textNode, &#123;characterData: true&#125;)</span><br><span class="line"></span><br><span class="line">    // 更改文本内容触发 dom树更新 触发回调</span><br><span class="line">    counter = counter + 1</span><br><span class="line">    textNode.data = String(counter)</span><br><span class="line">  &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h4 id="兼容node和浏览器的nextTick"><a href="#兼容node和浏览器的nextTick" class="headerlink" title="兼容node和浏览器的nextTick"></a>兼容node和浏览器的nextTick</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function nextTick(fn)&#123;</span><br><span class="line">    if( process !== undefined &amp;&amp; typeof process.nextTick === &apos;function&apos;)&#123;</span><br><span class="line">        return process.nextTick(fn);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        var counter = 1</span><br><span class="line">        var observer = new MutationObserver(fn)</span><br><span class="line">        var textNode = document.createTextNode(String(counter))</span><br><span class="line">        observer.observe(textNode, &#123;characterData: true&#125;)</span><br><span class="line">        // 更改文本内容触发 dom树更新 触发回调</span><br><span class="line">        counter = counter + 1</span><br><span class="line">        textNode.data = String(counter)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码仓库-1"><a href="#代码仓库-1" class="headerlink" title="代码仓库"></a>代码仓库</h4><ul>
<li><a href="https://github.com/slTrust/promise-2/tree/72c88d0b1bb1ea257da8529bfaeda61938b9cb32" target="_blank" rel="noopener">https://github.com/slTrust/promise-2/</a></li>
</ul>
<h3 id="重构代码"><a href="#重构代码" class="headerlink" title="重构代码"></a>重构代码</h3><ul>
<li>注意每次优化都跑一下测试用例保证代码正确性</li>
<li>注意每次优化都跑一下测试用例保证代码正确性</li>
<li>注意每次优化都跑一下测试用例保证代码正确性</li>
</ul>
<p>src/promise.ts</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">class Promise2&#123;</span><br><span class="line">    state = &quot;pending&quot;;</span><br><span class="line">    callbacks = [];</span><br><span class="line">    private resolveOrReject(state, data, i)&#123;</span><br><span class="line">        if(this.state !== &quot;pending&quot;) return;</span><br><span class="line">        this.state = state;</span><br><span class="line">        nextTick(() =&gt; &#123;</span><br><span class="line">            this.callbacks.forEach(handle=&gt;&#123;</span><br><span class="line">                if(typeof handle[i] === &quot;function&quot;)&#123;</span><br><span class="line">                    let x;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        x = handle[i].call(undefined,data);</span><br><span class="line">                    &#125; catch (e) &#123;</span><br><span class="line">                        return handle[2].reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    handle[2].resolveWith(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)  </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(result)&#123;</span><br><span class="line">        this.resolveOrReject(&quot;fulfilled&quot;,result,0);</span><br><span class="line">    &#125;</span><br><span class="line">    reject(reason)&#123;</span><br><span class="line">        this.resolveOrReject(&quot;rejected&quot;,reason,1);</span><br><span class="line">    &#125;</span><br><span class="line">    constructor(fn)&#123;</span><br><span class="line">        if(typeof fn !== &apos;function&apos;)&#123;</span><br><span class="line">            throw new Error(&quot;我只接受函数&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        fn(this.resolve.bind(this), this.reject.bind(this));</span><br><span class="line">    &#125;</span><br><span class="line">    then(succeed?,fail?)&#123;</span><br><span class="line">        // handle除了记录成功和失败 还要记录成功和失败的后续</span><br><span class="line">        const handle = [];</span><br><span class="line">        if(typeof succeed === &apos;function&apos;)&#123;</span><br><span class="line">            handle[0] = succeed;</span><br><span class="line">        &#125;</span><br><span class="line">        if(typeof fail === &apos;function&apos;)&#123;</span><br><span class="line">            handle[1] = fail;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 记录then之后的后续</span><br><span class="line">        handle[2] = new Promise2(()=&gt;&#123;&#125;);</span><br><span class="line">        </span><br><span class="line">        this.callbacks.push(handle); </span><br><span class="line">        // 把函数推进 callBacks 里面</span><br><span class="line"></span><br><span class="line">        return handle[2];</span><br><span class="line">    &#125;</span><br><span class="line">    resolveWithSelf()&#123;</span><br><span class="line">        this.reject(new TypeError())</span><br><span class="line">    &#125;</span><br><span class="line">    resolveWithPromise(x)&#123;</span><br><span class="line">        x.then(</span><br><span class="line">            (result)=&gt;&#123;</span><br><span class="line">                this.resolve(result)</span><br><span class="line">            &#125;,</span><br><span class="line">            (reason)=&gt;&#123;</span><br><span class="line">                this.reject(reason)</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    private getThen(x)&#123;</span><br><span class="line">        let then;</span><br><span class="line">        try&#123;</span><br><span class="line">            then = x.then;</span><br><span class="line">        &#125;catch(e)&#123;</span><br><span class="line">            return this.reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">        return then;</span><br><span class="line">    &#125;</span><br><span class="line">    resolveWithThenable(x)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            x.then(</span><br><span class="line">                y =&gt; &#123;</span><br><span class="line">                this.resolveWith(y)</span><br><span class="line">                &#125;,</span><br><span class="line">                r =&gt;&#123;</span><br><span class="line">                    this.reject(r);</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">            this.reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resolveWithObject(x)&#123;</span><br><span class="line">        let then = this.getThen(x);</span><br><span class="line">        if(then instanceof Function)&#123;</span><br><span class="line">            this.resolveWithThenable(x);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.resolve(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resolveWith(x)&#123;</span><br><span class="line">        if( this === x)&#123;</span><br><span class="line">           this.resolveWithSelf();</span><br><span class="line">        &#125; else if ( x instanceof Promise2)&#123;</span><br><span class="line">            this.resolveWithPromise(x);</span><br><span class="line">        &#125; else if ( x instanceof Object)&#123;</span><br><span class="line">            this.resolveWithObject(x);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.resolve(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Promise2</span><br><span class="line"></span><br><span class="line">function nextTick(fn)&#123;</span><br><span class="line">    if( process !== undefined &amp;&amp; typeof process.nextTick === &apos;function&apos;)&#123;</span><br><span class="line">        return process.nextTick(fn);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        var counter = 1</span><br><span class="line">        var observer = new MutationObserver(fn)</span><br><span class="line">        var textNode = document.createTextNode(String(counter))</span><br><span class="line">        observer.observe(textNode, &#123;characterData: true&#125;)</span><br><span class="line">        // 更改文本内容触发 dom树更新 触发回调</span><br><span class="line">        counter = counter + 1</span><br><span class="line">        textNode.data = String(counter)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区分宏任务和微任务"><a href="#区分宏任务和微任务" class="headerlink" title="区分宏任务和微任务"></a>区分宏任务和微任务</h3><blockquote>
<p>MacroTask</p>
</blockquote>
<ul>
<li>setTimeout</li>
</ul>
<blockquote>
<p>MicroTask(优先级高)</p>
</blockquote>
<ul>
<li>process.nextTick(nodeJS里用) / MutationObserver(浏览器里用)</li>
<li>setImmediate(只能在IE浏览器里用，nodeJS虽然也有这个API但是兼容性不好)</li>
</ul>
<h4 id="整体完成后的代码"><a href="#整体完成后的代码" class="headerlink" title="整体完成后的代码"></a>整体完成后的代码</h4><ul>
<li><a href="https://github.com/slTrust/promise-2" target="_blank" rel="noopener">https://github.com/slTrust/promise-2/</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/03/Node-JS专精10-02在浏览器支持nextTick/" data-id="ckl3ypv1w009dsi91w7i9ftyv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node后端/">Node后端</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Node-JS专精10-01Promise2-7之后的规范" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/03/Node-JS专精10-01Promise2-7之后的规范/" class="article-date">
  <time datetime="2020-03-03T04:40:56.000Z" itemprop="datePublished">2020-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/03/Node-JS专精10-01Promise2-7之后的规范/">Node-JS专精10_01Promise2_7之后的规范</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="参考规范文档"><a href="#参考规范文档" class="headerlink" title="参考规范文档"></a>参考规范文档</h1><ul>
<li><a href="https://segmentfault.com/a/1190000015914967" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015914967</a></li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>src/promise.ts</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">class Promise2&#123;</span><br><span class="line"></span><br><span class="line">    succeed = null;</span><br><span class="line">    fail = null;</span><br><span class="line">    state = &quot;pending&quot;;</span><br><span class="line">    callbacks = [];</span><br><span class="line"></span><br><span class="line">    resolve(result)&#123;</span><br><span class="line">        if(this.state !== &quot;pending&quot;) return;</span><br><span class="line">        this.state = &quot;fulfilled&quot;;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            // 遍历 callbacks 调用所有的 handle[0]</span><br><span class="line">            this.callbacks.forEach(handle=&gt;&#123;</span><br><span class="line">                if(typeof handle[0] === &quot;function&quot;)&#123;</span><br><span class="line">                    // x 是之前成功的返回值</span><br><span class="line">                    const x = handle[0].call(undefined,result);</span><br><span class="line">                    handle[2].resolveWith(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)  </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    reject(reason)&#123;</span><br><span class="line">        if(this.state !== &quot;pending&quot;) return;</span><br><span class="line">        this.state = &quot;rejected&quot;;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            this.callbacks.forEach(handle=&gt;&#123;</span><br><span class="line">                if(typeof handle[1] === &quot;function&quot;)&#123;</span><br><span class="line">                    // x 是之前失败的返回值</span><br><span class="line">                    const x = handle[1].call(undefined,reason);</span><br><span class="line">                    handle[2].resolveWith(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    constructor(fn)&#123;</span><br><span class="line">        if(typeof fn !== &apos;function&apos;)&#123;</span><br><span class="line">            throw new Error(&quot;我只接受函数&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        fn(this.resolve.bind(this), this.reject.bind(this));</span><br><span class="line">    &#125;</span><br><span class="line">    then(succeed?,fail?)&#123;</span><br><span class="line">        // handle除了记录成功和失败 还要记录成功和失败的后续</span><br><span class="line">        const handle = [];</span><br><span class="line">        if(typeof succeed === &apos;function&apos;)&#123;</span><br><span class="line">            handle[0] = succeed;</span><br><span class="line">        &#125;</span><br><span class="line">        if(typeof fail === &apos;function&apos;)&#123;</span><br><span class="line">            handle[1] = fail;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 记录then之后的后续</span><br><span class="line">        handle[2] = new Promise2(()=&gt;&#123;&#125;);</span><br><span class="line">        </span><br><span class="line">        this.callbacks.push(handle); </span><br><span class="line">        // 把函数推进 callBacks 里面</span><br><span class="line"></span><br><span class="line">        return handle[2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    resolveWith(x)&#123;</span><br><span class="line">        if( this === x)&#123;</span><br><span class="line">            this.reject(new TypeError())</span><br><span class="line">        &#125; else if ( x instanceof Promise2)&#123;</span><br><span class="line">            x.then(</span><br><span class="line">                (result)=&gt;&#123;</span><br><span class="line">                    this.resolve(result)</span><br><span class="line">                &#125;,</span><br><span class="line">                (reason)=&gt;&#123;</span><br><span class="line">                    this.reject(reason)</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125; else if ( x instanceof Object)&#123;</span><br><span class="line">            let then;</span><br><span class="line">            try&#123;</span><br><span class="line">                then = x.then;</span><br><span class="line">            &#125;catch(e)&#123;</span><br><span class="line">                this.reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">            if(then instanceof Function)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    x.then(</span><br><span class="line">                        y =&gt; &#123;</span><br><span class="line">                        this.resolveWith(y)</span><br><span class="line">                        &#125;,</span><br><span class="line">                        r =&gt;&#123;</span><br><span class="line">                            this.reject(r);</span><br><span class="line">                        &#125;</span><br><span class="line">                    );</span><br><span class="line">                &#125; catch (error) &#123;</span><br><span class="line">                    this.reject(error)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.resolve(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.resolve(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Promise2</span><br></pre></td></tr></table></figure>
<p>test/index.ts</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line">import * as chai from &quot;chai&quot;;</span><br><span class="line">import * as sinon from &quot;sinon&quot;;</span><br><span class="line">import * as sinonChai from &quot;sinon-chai&quot;;</span><br><span class="line">chai.use(sinonChai);</span><br><span class="line">const assert = chai.assert;</span><br><span class="line">import Promise from &quot;../src/promise&quot;;</span><br><span class="line"></span><br><span class="line">describe(&quot;Promise&quot;,()=&gt;&#123;</span><br><span class="line">    it(&quot;是一个类&quot;,()=&gt;&#123;</span><br><span class="line">        assert.isFunction(Promise);</span><br><span class="line">        assert.isObject(Promise.prototype);</span><br><span class="line">    &#125;)</span><br><span class="line">    it(&quot;new Promise() 如果接受的不是一个函数就报错&quot;,()=&gt;&#123;</span><br><span class="line">        assert.throw(()=&gt;&#123;</span><br><span class="line">            // @ts-ignore</span><br><span class="line">            new Promise();</span><br><span class="line">        &#125;)</span><br><span class="line">        assert.throw(()=&gt;&#123;</span><br><span class="line">            // @ts-ignore</span><br><span class="line">            new Promise(1);</span><br><span class="line">        &#125;)</span><br><span class="line">        assert.throw(()=&gt;&#123;</span><br><span class="line">            // @ts-ignore</span><br><span class="line">            new Promise(false);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;new Promise(fn) 会生成一个对象，对象有 then 方法&quot;,()=&gt;&#123;</span><br><span class="line">        const promise = new Promise(()=&gt;&#123;&#125;)</span><br><span class="line">        assert.isFunction(promise.then);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;new Promise(fn) 中的 fn立即执行&quot;,()=&gt;&#123;</span><br><span class="line">        let fn = sinon.fake();</span><br><span class="line">        new Promise(fn);</span><br><span class="line">        assert(fn.called);</span><br><span class="line">    &#125;)</span><br><span class="line">    it(&quot;new Promise(fn) 中的 fn 执行的时候接受 resolve 和 reject 两个函数&quot;,(done)=&gt;&#123;</span><br><span class="line">        new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            assert.isFunction(resolve);</span><br><span class="line">            assert.isFunction(reject);</span><br><span class="line">            done();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;promise.then(success) 重的 success 会在 resolve 被调用的时候执行&quot;,(done)=&gt;&#123;</span><br><span class="line">        const success = sinon.fake();</span><br><span class="line">        const promise = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            // 该函数没有执行</span><br><span class="line">            assert.isFalse(success.called);</span><br><span class="line">            resolve();</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">                // 该函数执行了</span><br><span class="line">                assert.isTrue(success.called);</span><br><span class="line">                done();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">        // @ts-ignore</span><br><span class="line">        promise.then(success);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;promise.then(null,fail) 重的 fail 会在 reject 被调用的时候执行&quot;,(done)=&gt;&#123;</span><br><span class="line">        const fail = sinon.fake();</span><br><span class="line">        const promise = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            // 该函数没有执行</span><br><span class="line">            assert.isFalse(fail.called);</span><br><span class="line">            reject();</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">                // 该函数执行了</span><br><span class="line">                assert.isTrue(fail.called);</span><br><span class="line">                done();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">        // @ts-ignore</span><br><span class="line">        promise.then(null,fail);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;2.2.1&quot;,()=&gt;&#123;</span><br><span class="line">        const promise = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;)</span><br><span class="line">        promise.then(false,null);</span><br><span class="line">        assert(1 === 1);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;2.2.2&quot;,(done)=&gt;&#123;</span><br><span class="line">        const success = sinon.fake();</span><br><span class="line">        const promise = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            assert.isFalse(success.called); </span><br><span class="line">            resolve(233);</span><br><span class="line">            resolve(2333);</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">                assert(promise.state === &quot;fulfilled&quot;)</span><br><span class="line">                assert.isTrue(success.called); </span><br><span class="line">                assert.isTrue(success.calledOnce); </span><br><span class="line">                assert(success.calledWith(233));</span><br><span class="line">                done();</span><br><span class="line">            &#125;,0);</span><br><span class="line">        &#125;)</span><br><span class="line">        promise.then(success);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;2.2.3&quot;,(done)=&gt;&#123;</span><br><span class="line">        const fail = sinon.fake();</span><br><span class="line">        const promise = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            assert.isFalse(fail.called); </span><br><span class="line">            reject(233);</span><br><span class="line">            reject(2333);</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">                assert(promise.state === &quot;rejected&quot;)</span><br><span class="line">                assert.isTrue(fail.called); </span><br><span class="line">                assert.isTrue(fail.calledOnce); </span><br><span class="line">                assert(fail.calledWith(233));</span><br><span class="line">                done();</span><br><span class="line">            &#125;,0);</span><br><span class="line">        &#125;)</span><br><span class="line">        promise.then(null,fail);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;2.2.4 在我的代码执行完之前，不得调用 then 后面的两个函数 success&quot;,(done)=&gt;&#123;</span><br><span class="line">        const success = sinon.fake();</span><br><span class="line">        const promise = new Promise((resolve)=&gt;&#123;</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;)</span><br><span class="line">        promise.then(success);</span><br><span class="line">        assert.isFalse(success.called);</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            assert.isTrue(success.called);</span><br><span class="line">            done();</span><br><span class="line">        &#125;, 0);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;2.2.4 在我的代码执行完之前，不得调用 then 后面的两个函数 fail&quot;,(done)=&gt;&#123;</span><br><span class="line">        const fail = sinon.fake();</span><br><span class="line">        const promise = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            reject();</span><br><span class="line">        &#125;)</span><br><span class="line">        promise.then(null,fail);</span><br><span class="line">        assert.isFalse(fail.called);</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            assert.isTrue(fail.called);</span><br><span class="line">            done();</span><br><span class="line">        &#125;, 0);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;2.2.5 不带入额外的this&quot;,(done)=&gt;&#123;</span><br><span class="line">        const fn = sinon.fake();</span><br><span class="line">        const promise = new Promise((resolve)=&gt;&#123;</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;)</span><br><span class="line">        promise.then(function()&#123;</span><br><span class="line">            &quot;use strict&quot;;</span><br><span class="line">            assert(this === undefined);</span><br><span class="line">            done();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;2.2.6 then可以在同一个promise里被多次调用(链式调用)&quot;,(done)=&gt;&#123;</span><br><span class="line">        const promise = new Promise((resolve)=&gt;&#123;</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;)</span><br><span class="line">        const callbacks = [sinon.fake(),sinon.fake(),sinon.fake()]</span><br><span class="line">        promise.then(callbacks[0]);</span><br><span class="line">        promise.then(callbacks[1]);</span><br><span class="line">        promise.then(callbacks[2]);</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            assert(callbacks[0].called);</span><br><span class="line">            assert(callbacks[1].called);</span><br><span class="line">            assert(callbacks[2].called);</span><br><span class="line">            assert(callbacks[1].calledAfter(callbacks[0]));</span><br><span class="line">            assert(callbacks[2].calledAfter(callbacks[1]));</span><br><span class="line"></span><br><span class="line">            done();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;2.2.6.2 then可以在同一个promise里被多次调用(链式调用) reject&quot;,(done)=&gt;&#123;</span><br><span class="line">        const promise = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            reject();</span><br><span class="line">        &#125;)</span><br><span class="line">        const callbacks = [sinon.fake(),sinon.fake(),sinon.fake()]</span><br><span class="line">        promise.then(null,callbacks[0]);</span><br><span class="line">        promise.then(null,callbacks[1]);</span><br><span class="line">        promise.then(null,callbacks[2]);</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            assert(callbacks[0].called);</span><br><span class="line">            assert(callbacks[1].called);</span><br><span class="line">            assert(callbacks[2].called);</span><br><span class="line">            assert(callbacks[1].calledAfter(callbacks[0]));</span><br><span class="line">            assert(callbacks[2].calledAfter(callbacks[1]));</span><br><span class="line"></span><br><span class="line">            done();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;2.2.7 then必须返回一个 promise &quot;,()=&gt;&#123;</span><br><span class="line">        const promise = new Promise((resolve)=&gt;&#123;</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;)</span><br><span class="line">        const promise2 = promise.then(()=&gt;&#123;&#125;,()=&gt;&#123;&#125;);</span><br><span class="line">        assert(promise2 instanceof Promise);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    it(&quot;2.2.7.1 如果onFulfilled或onRejected返回一个值x, 运行Promise Resolution Procedure [[Resolve]](promise2, x)&quot;,(done)=&gt;&#123;</span><br><span class="line">        const promise1 = new Promise((resolve)=&gt;&#123;</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;)</span><br><span class="line">        promise1.then(()=&gt;&quot;成功&quot;,()=&gt;&#123;&#125;).then(result=&gt;&#123;</span><br><span class="line">            assert.equal(result,&quot;成功&quot;);</span><br><span class="line">            done();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;2.2.7.2  x 是一个 Promise实例&quot;,(done)=&gt;&#123;</span><br><span class="line">        const promise1 = new Promise((resolve)=&gt;&#123;</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;)</span><br><span class="line">        const fn = sinon.fake();</span><br><span class="line">        const promise2 = promise1.then(()=&gt; new Promise(resolve=&gt;resolve()),()=&gt;&#123;&#125;)</span><br><span class="line">        promise2.then(fn);</span><br><span class="line"></span><br><span class="line">        /* </span><br><span class="line">        注意 setTimeout 里的 延时时间 </span><br><span class="line">            如果是0 测试不通过</span><br><span class="line">            如果是10 就通过</span><br><span class="line">            因为这里涉及 js 的 宏任务 微任务</span><br><span class="line">            宏任务一般是：包括整体代码script，setTimeout，setInterval。</span><br><span class="line">            微任务：Promise，process.nextTick(node实现的)  / setImmediate(这个是IE实现的)</span><br><span class="line">        */</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            assert(fn.called);</span><br><span class="line">            done();</span><br><span class="line">        &#125;,10);</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="宏任务-微任务"><a href="#宏任务-微任务" class="headerlink" title="宏任务/微任务"></a>宏任务/微任务</h3><blockquote>
<p>上述实现的一个测试代码</p>
</blockquote>
<ul>
<li>由于我们的 Promise 使用的 setTimeout 实现的</li>
<li>所以测试的时候那个 setTimeout 里的 延时时间设置为0会不通过</li>
<li>因为微任务比宏任务的优先级更高</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">it(&quot;2.2.7.2  x 是一个 Promise实例&quot;,(done)=&gt;&#123;</span><br><span class="line">    const promise1 = new Promise((resolve)=&gt;&#123;</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;)</span><br><span class="line">    const fn = sinon.fake();</span><br><span class="line">    const promise2 = promise1.then(()=&gt; new Promise(resolve=&gt;resolve()),()=&gt;&#123;&#125;)</span><br><span class="line">    promise2.then(fn);</span><br><span class="line"></span><br><span class="line">    /* </span><br><span class="line">    注意 setTimeout 里的 延时时间 </span><br><span class="line">        如果是0 测试不通过</span><br><span class="line">        如果是10 就通过</span><br><span class="line">        因为这里涉及 js 的 宏任务 微任务</span><br><span class="line">        宏任务一般是：包括整体代码script，setTimeout，setInterval。</span><br><span class="line">        微任务：Promise，process.nextTick(node实现的)  / setImmediate(这个是IE实现的)</span><br><span class="line">    */</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        assert(fn.called);</span><br><span class="line">        done();</span><br><span class="line">    &#125;,10);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="改用node环境来写代码"><a href="#改用node环境来写代码" class="headerlink" title="改用node环境来写代码"></a>改用node环境来写代码</h4></blockquote>
<ul>
<li>使用<code>process.nextTick</code> 代替 <code>setTimeout</code></li>
<li><code>yarn add --dev @types/node</code></li>
<li>添加一个配置，告诉ts你写的是node应用,参考<a href="http://www.typescriptlang.org/docs/handbook/tsconfig-json.html" target="_blank" rel="noopener">ts官网</a></li>
<li>tsconfig.json  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;types&quot; : [&quot;node&quot;, &quot;mocha&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>src/promise_node.ts</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">class Promise2&#123;</span><br><span class="line">    state = &quot;pending&quot;;</span><br><span class="line">    callbacks = [];</span><br><span class="line"></span><br><span class="line">    resolve(result)&#123;</span><br><span class="line">        if(this.state !== &quot;pending&quot;) return;</span><br><span class="line">        this.state = &quot;fulfilled&quot;;</span><br><span class="line">        process.nextTick(() =&gt; &#123;</span><br><span class="line">            // 遍历 callbacks 调用所有的 handle[0]</span><br><span class="line">            this.callbacks.forEach(handle=&gt;&#123;</span><br><span class="line">                if(typeof handle[0] === &quot;function&quot;)&#123;</span><br><span class="line">                    let x;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        // x 是之前成功的返回值</span><br><span class="line">                        x = handle[0].call(undefined,result);</span><br><span class="line">                    &#125; catch (e) &#123;</span><br><span class="line">                        return handle[2].reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    handle[2].resolveWith(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)  </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    reject(reason)&#123;</span><br><span class="line">        if(this.state !== &quot;pending&quot;) return;</span><br><span class="line">        this.state = &quot;rejected&quot;;</span><br><span class="line">        process.nextTick(() =&gt; &#123;</span><br><span class="line">            this.callbacks.forEach(handle=&gt;&#123;</span><br><span class="line">                if(typeof handle[1] === &quot;function&quot;)&#123;</span><br><span class="line">                    let x;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        // x 是之前失败的返回值</span><br><span class="line">                        x = handle[1].call(undefined,reason);</span><br><span class="line">                    &#125; catch (e) &#123;</span><br><span class="line">                        return handle[2].reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    handle[2].resolveWith(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    constructor(fn)&#123;</span><br><span class="line">        if(typeof fn !== &apos;function&apos;)&#123;</span><br><span class="line">            throw new Error(&quot;我只接受函数&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        fn(this.resolve.bind(this), this.reject.bind(this));</span><br><span class="line">    &#125;</span><br><span class="line">    then(succeed?,fail?)&#123;</span><br><span class="line">        // handle除了记录成功和失败 还要记录成功和失败的后续</span><br><span class="line">        const handle = [];</span><br><span class="line">        if(typeof succeed === &apos;function&apos;)&#123;</span><br><span class="line">            handle[0] = succeed;</span><br><span class="line">        &#125;</span><br><span class="line">        if(typeof fail === &apos;function&apos;)&#123;</span><br><span class="line">            handle[1] = fail;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 记录then之后的后续</span><br><span class="line">        handle[2] = new Promise2(()=&gt;&#123;&#125;);</span><br><span class="line">        </span><br><span class="line">        this.callbacks.push(handle); </span><br><span class="line">        // 把函数推进 callBacks 里面</span><br><span class="line"></span><br><span class="line">        return handle[2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    resolveWith(x)&#123;</span><br><span class="line">        if( this === x)&#123;</span><br><span class="line">            this.reject(new TypeError())</span><br><span class="line">        &#125; else if ( x instanceof Promise2)&#123;</span><br><span class="line">            x.then(</span><br><span class="line">                (result)=&gt;&#123;</span><br><span class="line">                    this.resolve(result)</span><br><span class="line">                &#125;,</span><br><span class="line">                (reason)=&gt;&#123;</span><br><span class="line">                    this.reject(reason)</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125; else if ( x instanceof Object)&#123;</span><br><span class="line">            let then;</span><br><span class="line">            try&#123;</span><br><span class="line">                then = x.then;</span><br><span class="line">            &#125;catch(e)&#123;</span><br><span class="line">                this.reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">            if(then instanceof Function)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    x.then(</span><br><span class="line">                        y =&gt; &#123;</span><br><span class="line">                        this.resolveWith(y)</span><br><span class="line">                        &#125;,</span><br><span class="line">                        r =&gt;&#123;</span><br><span class="line">                            this.reject(r);</span><br><span class="line">                        &#125;</span><br><span class="line">                    );</span><br><span class="line">                &#125; catch (error) &#123;</span><br><span class="line">                    this.reject(error)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.resolve(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.resolve(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Promise2</span><br></pre></td></tr></table></figure>
<p>test/index_node.ts</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">import * as chai from &quot;chai&quot;;</span><br><span class="line">import * as sinon from &quot;sinon&quot;;</span><br><span class="line">import * as sinonChai from &quot;sinon-chai&quot;;</span><br><span class="line">chai.use(sinonChai);</span><br><span class="line">const assert = chai.assert;</span><br><span class="line">import Promise from &quot;../src/promise_node&quot;;</span><br><span class="line"></span><br><span class="line">describe(&quot;Promise&quot;,()=&gt;&#123;</span><br><span class="line">    it(&quot;2.2.7.1 如果onFulfilled或onRejected返回一个值x, 运行Promise Resolution Procedure [[Resolve]](promise2, x)&quot;,(done)=&gt;&#123;</span><br><span class="line">        const promise1 = new Promise((resolve)=&gt;&#123;</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;)</span><br><span class="line">        promise1.then(()=&gt;&quot;成功&quot;,()=&gt;&#123;&#125;).then(result=&gt;&#123;</span><br><span class="line">            assert.equal(result,&quot;成功&quot;);</span><br><span class="line">            done();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;2.2.7.1.2 success 的返回值是一个 Promise实例&quot;,(done)=&gt;&#123;</span><br><span class="line">        const promise1 = new Promise((resolve)=&gt;&#123;</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;)</span><br><span class="line">        const fn = sinon.fake();</span><br><span class="line">        const promise2 = promise1.then(()=&gt; new Promise(resolve=&gt;resolve()),()=&gt;&#123;&#125;)</span><br><span class="line">        promise2.then(fn);</span><br><span class="line"></span><br><span class="line">        /* </span><br><span class="line">        注意 setTimeout 里的 延时时间 </span><br><span class="line">            如果是0 测试不通过</span><br><span class="line">            如果是10 就通过</span><br><span class="line">            因为这里涉及 js 的 宏任务 微任务</span><br><span class="line">            宏任务一般是：包括整体代码script，setTimeout，setInterval。</span><br><span class="line">            微任务：Promise，process.nextTick(node实现的)  / setImmediate(这个是IE实现的)</span><br><span class="line">        */</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            assert(fn.called);</span><br><span class="line">            done();</span><br><span class="line">        &#125;,0);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;2.2.7.1.2 success 的返回值是一个 Promise实例 且失败了&quot;,(done)=&gt;&#123;</span><br><span class="line">        const promise1 = new Promise((resolve)=&gt;&#123;</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;)</span><br><span class="line">        const fn = sinon.fake();</span><br><span class="line">        const promise2 = promise1.then(()=&gt; new Promise((resolve,reject)=&gt;reject()),()=&gt;&#123;&#125;)</span><br><span class="line">        promise2.then(null,fn);</span><br><span class="line"></span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            assert(fn.called);</span><br><span class="line">            done();</span><br><span class="line">        &#125;,0);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;2.2.7.1.2 fail 的返回值是一个 Promise实例&quot;,(done)=&gt;&#123;</span><br><span class="line">        const promise1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            reject();</span><br><span class="line">        &#125;);</span><br><span class="line">        const fn = sinon.fake();</span><br><span class="line">        const promise2 = promise1</span><br><span class="line">                            .then(</span><br><span class="line">                                null,</span><br><span class="line">                                ()=&gt; new Promise(resolve=&gt;resolve())</span><br><span class="line">                            )</span><br><span class="line">        promise2.then(fn,null);</span><br><span class="line"></span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            assert(fn.called);</span><br><span class="line">            done();</span><br><span class="line">        &#125;,0);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;2.2.7.1.2 fail 的返回值是一个 Promise实例 且失败了&quot;,(done)=&gt;&#123;</span><br><span class="line">        const promise1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            reject();</span><br><span class="line">        &#125;);</span><br><span class="line">        const fn = sinon.fake();</span><br><span class="line">        const promise2 = promise1</span><br><span class="line">                            .then(</span><br><span class="line">                                null,</span><br><span class="line">                                ()=&gt; new Promise((resolve,reject)=&gt;reject())</span><br><span class="line">                            )</span><br><span class="line">        promise2.then(null, fn);</span><br><span class="line"></span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            assert(fn.called);</span><br><span class="line">            done();</span><br><span class="line">        &#125;,0);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;2.2.7.1.2 如果 success 抛出一个异常e , promise2 必须被拒绝&quot;,(done)=&gt;&#123;</span><br><span class="line">        const promise1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;);</span><br><span class="line">        const fn = sinon.fake();</span><br><span class="line">        const error = new Error();</span><br><span class="line">        const promise2 = promise1</span><br><span class="line">                            .then(</span><br><span class="line">                                ()=&gt; new Promise(()=&gt;&#123;</span><br><span class="line">                                    throw error;</span><br><span class="line">                                &#125;)</span><br><span class="line">                            )</span><br><span class="line">        promise2.then(null, fn);</span><br><span class="line"></span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            assert(fn.called);</span><br><span class="line">            assert(fn.calledWith(error));</span><br><span class="line">            done();</span><br><span class="line">        &#125;,0);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;2.2.7.1.2 如果 fail 抛出一个异常e , promise2 必须被拒绝&quot;,(done)=&gt;&#123;</span><br><span class="line">        const promise1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            reject();</span><br><span class="line">        &#125;);</span><br><span class="line">        const fn = sinon.fake();</span><br><span class="line">        const error = new Error();</span><br><span class="line">        const promise2 = promise1</span><br><span class="line">                            .then(</span><br><span class="line">                                null,</span><br><span class="line">                                ()=&gt; new Promise(()=&gt;&#123;</span><br><span class="line">                                    throw error;</span><br><span class="line">                                &#125;)</span><br><span class="line">                            )</span><br><span class="line">        promise2.then(null, fn);</span><br><span class="line"></span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            assert(fn.called);</span><br><span class="line">            assert(fn.calledWith(error));</span><br><span class="line">            done();</span><br><span class="line">        &#125;,0);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a><a href="https://github.com/slTrust/promise-2/tree/58a31c016d2f5e6d38cf763c5db98ea0cd061b79" target="_blank" rel="noopener">代码仓库</a></h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/03/Node-JS专精10-01Promise2-7之后的规范/" data-id="ckl3ypv1w009fsi91rptdw49l" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node后端/">Node后端</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Node-JS专精09-03参考Promise规范完成Promise" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/02/Node-JS专精09-03参考Promise规范完成Promise/" class="article-date">
  <time datetime="2020-03-02T04:38:43.000Z" itemprop="datePublished">2020-03-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/02/Node-JS专精09-03参考Promise规范完成Promise/">Node-JS专精09_03参考Promise规范完成Promise</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="参考规范"><a href="#参考规范" class="headerlink" title="参考规范"></a>参考<a href="https://segmentfault.com/a/1190000015914967" target="_blank" rel="noopener">规范</a></h3><p>src/promise.ts</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class Promise2&#123;</span><br><span class="line"></span><br><span class="line">    succeed = null;</span><br><span class="line">    fail = null;</span><br><span class="line">    state = &quot;pending&quot;;</span><br><span class="line">    callbacks = [];</span><br><span class="line"></span><br><span class="line">    resolve(result)&#123;</span><br><span class="line">        if(this.state !== &quot;pending&quot;) return;</span><br><span class="line">        this.state = &quot;fulfilled&quot;;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            // 遍历 callbacks 调用所有的 handle[0]</span><br><span class="line">            this.callbacks.forEach(handle=&gt;&#123;</span><br><span class="line">                if(typeof handle[0] === &quot;function&quot;)&#123;</span><br><span class="line">                    handle[0].call(undefined,result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)  </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    reject(reason)&#123;</span><br><span class="line">        if(this.state !== &quot;pending&quot;) return;</span><br><span class="line">        this.state = &quot;rejected&quot;;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            this.callbacks.forEach(handle=&gt;&#123;</span><br><span class="line">                if(typeof handle[1] === &quot;function&quot;)&#123;</span><br><span class="line">                    handle[1].call(undefined,reason);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    constructor(fn)&#123;</span><br><span class="line">        if(typeof fn !== &apos;function&apos;)&#123;</span><br><span class="line">            throw new Error(&quot;我只接受函数&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        fn(this.resolve.bind(this), this.reject.bind(this));</span><br><span class="line">    &#125;</span><br><span class="line">    then(succeed?,fail?)&#123;</span><br><span class="line">        const handle = [];</span><br><span class="line">        if(typeof succeed === &apos;function&apos;)&#123;</span><br><span class="line">            handle[0] = succeed;</span><br><span class="line">        &#125;</span><br><span class="line">        if(typeof fail === &apos;function&apos;)&#123;</span><br><span class="line">            handle[1] = fail;</span><br><span class="line">        &#125;</span><br><span class="line">        this.callbacks.push(handle); </span><br><span class="line">        // 把函数推进 callBacks 里面</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Promise2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>测试代码</p>
</blockquote>
<p>test/index.ts</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line">import * as chai from &quot;chai&quot;;</span><br><span class="line">import * as sinon from &quot;sinon&quot;;</span><br><span class="line">import * as sinonChai from &quot;sinon-chai&quot;;</span><br><span class="line">chai.use(sinonChai);</span><br><span class="line">const assert = chai.assert;</span><br><span class="line">import Promise from &quot;../src/promise&quot;;</span><br><span class="line"></span><br><span class="line">describe(&quot;Promise&quot;,()=&gt;&#123;</span><br><span class="line">    it(&quot;是一个类&quot;,()=&gt;&#123;</span><br><span class="line">        assert.isFunction(Promise);</span><br><span class="line">        assert.isObject(Promise.prototype);</span><br><span class="line">    &#125;)</span><br><span class="line">    it(&quot;new Promise() 如果接受的不是一个函数就报错&quot;,()=&gt;&#123;</span><br><span class="line">        assert.throw(()=&gt;&#123;</span><br><span class="line">            // @ts-ignore</span><br><span class="line">            new Promise();</span><br><span class="line">        &#125;)</span><br><span class="line">        assert.throw(()=&gt;&#123;</span><br><span class="line">            // @ts-ignore</span><br><span class="line">            new Promise(1);</span><br><span class="line">        &#125;)</span><br><span class="line">        assert.throw(()=&gt;&#123;</span><br><span class="line">            // @ts-ignore</span><br><span class="line">            new Promise(false);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;new Promise(fn) 会生成一个对象，对象有 then 方法&quot;,()=&gt;&#123;</span><br><span class="line">        const promise = new Promise(()=&gt;&#123;&#125;)</span><br><span class="line">        assert.isFunction(promise.then);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;new Promise(fn) 中的 fn立即执行&quot;,()=&gt;&#123;</span><br><span class="line">        let fn = sinon.fake();</span><br><span class="line">        new Promise(fn);</span><br><span class="line">        assert(fn.called);</span><br><span class="line">    &#125;)</span><br><span class="line">    it(&quot;new Promise(fn) 中的 fn 执行的时候接受 resolve 和 reject 两个函数&quot;,(done)=&gt;&#123;</span><br><span class="line">        new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            assert.isFunction(resolve);</span><br><span class="line">            assert.isFunction(reject);</span><br><span class="line">            done();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;promise.then(success) 重的 success 会在 resolve 被调用的时候执行&quot;,(done)=&gt;&#123;</span><br><span class="line">        const success = sinon.fake();</span><br><span class="line">        const promise = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            // 该函数没有执行</span><br><span class="line">            assert.isFalse(success.called);</span><br><span class="line">            resolve();</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">                // 该函数执行了</span><br><span class="line">                assert.isTrue(success.called);</span><br><span class="line">                done();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">        // @ts-ignore</span><br><span class="line">        promise.then(success);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;promise.then(null,fail) 重的 fail 会在 reject 被调用的时候执行&quot;,(done)=&gt;&#123;</span><br><span class="line">        const fail = sinon.fake();</span><br><span class="line">        const promise = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            // 该函数没有执行</span><br><span class="line">            assert.isFalse(fail.called);</span><br><span class="line">            reject();</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">                // 该函数执行了</span><br><span class="line">                assert.isTrue(fail.called);</span><br><span class="line">                done();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">        // @ts-ignore</span><br><span class="line">        promise.then(null,fail);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;2.2.1&quot;,()=&gt;&#123;</span><br><span class="line">        const promise = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;)</span><br><span class="line">        promise.then(false,null);</span><br><span class="line">        assert(1 === 1);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;2.2.2&quot;,(done)=&gt;&#123;</span><br><span class="line">        const success = sinon.fake();</span><br><span class="line">        const promise = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            assert.isFalse(success.called); </span><br><span class="line">            resolve(233);</span><br><span class="line">            resolve(2333);</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">                assert(promise.state === &quot;fulfilled&quot;)</span><br><span class="line">                assert.isTrue(success.called); </span><br><span class="line">                assert.isTrue(success.calledOnce); </span><br><span class="line">                assert(success.calledWith(233));</span><br><span class="line">                done();</span><br><span class="line">            &#125;,0);</span><br><span class="line">        &#125;)</span><br><span class="line">        promise.then(success);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;2.2.3&quot;,(done)=&gt;&#123;</span><br><span class="line">        const fail = sinon.fake();</span><br><span class="line">        const promise = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            assert.isFalse(fail.called); </span><br><span class="line">            reject(233);</span><br><span class="line">            reject(2333);</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">                assert(promise.state === &quot;rejected&quot;)</span><br><span class="line">                assert.isTrue(fail.called); </span><br><span class="line">                assert.isTrue(fail.calledOnce); </span><br><span class="line">                assert(fail.calledWith(233));</span><br><span class="line">                done();</span><br><span class="line">            &#125;,0);</span><br><span class="line">        &#125;)</span><br><span class="line">        promise.then(null,fail);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;2.2.4 在我的代码执行完之前，不得调用 then 后面的两个函数 success&quot;,(done)=&gt;&#123;</span><br><span class="line">        const success = sinon.fake();</span><br><span class="line">        const promise = new Promise((resolve)=&gt;&#123;</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;)</span><br><span class="line">        promise.then(success);</span><br><span class="line">        assert.isFalse(success.called);</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            assert.isTrue(success.called);</span><br><span class="line">            done();</span><br><span class="line">        &#125;, 0);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;2.2.4 在我的代码执行完之前，不得调用 then 后面的两个函数 fail&quot;,(done)=&gt;&#123;</span><br><span class="line">        const fail = sinon.fake();</span><br><span class="line">        const promise = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            reject();</span><br><span class="line">        &#125;)</span><br><span class="line">        promise.then(null,fail);</span><br><span class="line">        assert.isFalse(fail.called);</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            assert.isTrue(fail.called);</span><br><span class="line">            done();</span><br><span class="line">        &#125;, 0);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;2.2.5 不带入额外的this&quot;,(done)=&gt;&#123;</span><br><span class="line">        const fn = sinon.fake();</span><br><span class="line">        const promise = new Promise((resolve)=&gt;&#123;</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;)</span><br><span class="line">        promise.then(function()&#123;</span><br><span class="line">            &quot;use strict&quot;;</span><br><span class="line">            assert(this === undefined);</span><br><span class="line">            done();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;2.2.6 then可以在同一个promise里被多次调用(链式调用)&quot;,(done)=&gt;&#123;</span><br><span class="line">        const promise = new Promise((resolve)=&gt;&#123;</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;)</span><br><span class="line">        const callbacks = [sinon.fake(),sinon.fake(),sinon.fake()]</span><br><span class="line">        promise.then(callbacks[0]);</span><br><span class="line">        promise.then(callbacks[1]);</span><br><span class="line">        promise.then(callbacks[2]);</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            assert(callbacks[0].called);</span><br><span class="line">            assert(callbacks[1].called);</span><br><span class="line">            assert(callbacks[2].called);</span><br><span class="line">            assert(callbacks[1].calledAfter(callbacks[0]));</span><br><span class="line">            assert(callbacks[2].calledAfter(callbacks[1]));</span><br><span class="line"></span><br><span class="line">            done();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;2.2.6.2 then可以在同一个promise里被多次调用(链式调用) reject&quot;,(done)=&gt;&#123;</span><br><span class="line">        const promise = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            reject();</span><br><span class="line">        &#125;)</span><br><span class="line">        const callbacks = [sinon.fake(),sinon.fake(),sinon.fake()]</span><br><span class="line">        promise.then(null,callbacks[0]);</span><br><span class="line">        promise.then(null,callbacks[1]);</span><br><span class="line">        promise.then(null,callbacks[2]);</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            assert(callbacks[0].called);</span><br><span class="line">            assert(callbacks[1].called);</span><br><span class="line">            assert(callbacks[2].called);</span><br><span class="line">            assert(callbacks[1].calledAfter(callbacks[0]));</span><br><span class="line">            assert(callbacks[2].calledAfter(callbacks[1]));</span><br><span class="line"></span><br><span class="line">            done();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h3></blockquote>
<ul>
<li><a href="https://github.com/slTrust/promise-1" target="_blank" rel="noopener">https://github.com/slTrust/promise-1</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/02/Node-JS专精09-03参考Promise规范完成Promise/" data-id="ckl3ypv1v009asi9117sifa1b" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node后端/">Node后端</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Node-JS专精09-02使用chai和sinon" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/01/Node-JS专精09-02使用chai和sinon/" class="article-date">
  <time datetime="2020-03-01T06:37:25.000Z" itemprop="datePublished">2020-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/01/Node-JS专精09-02使用chai和sinon/">Node-JS专精09_02使用chai和sinon</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="使用chai进行测试"><a href="#使用chai进行测试" class="headerlink" title="使用chai进行测试"></a>使用chai进行测试</h1><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul>
<li><code>yarn global add typescript ts-node mocha</code> 全局安装</li>
<li>创建目录 promise-demo</li>
<li><code>yarn init -y / npm init -y</code></li>
<li><code>yarn add chai mocha --dev</code></li>
<li><code>yarn add @types/chai @types/mocha --dev</code> 添加对应库的类型声明文件</li>
<li><p>创建 test/index.ts</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import * as chai from &quot;chai&quot;;</span><br><span class="line"></span><br><span class="line">const assert = chai.assert;</span><br><span class="line"></span><br><span class="line">describe(&quot;Chai 的使用&quot;,()=&gt;&#123;</span><br><span class="line">    it(&quot;可以测试相等&quot;,()=&gt;&#123;</span><br><span class="line">        assert(1 === 1);</span><br><span class="line"></span><br><span class="line">        // 因为我们用的是 ts, 你在任何一行在上 // @ts-ignore 那么ts就不会管这行符合不符合逻辑</span><br><span class="line">        // 之前如果不加会报错， 因为 2 永远不等于 3 ，你这样写是没意义的</span><br><span class="line">        // 由于你是在测试，所以经常会写这种代码</span><br><span class="line">        // @ts-ignore</span><br><span class="line">        assert( 2 === 3)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加运行命令 <code>mocha -r ts-node/register test/**/*.ts</code> 运行测试</p>
</li>
</ul>
<blockquote>
<p>简要说明</p>
</blockquote>
<ul>
<li>mocha 是用来提供 describe / it这两个函数 以及，yarn test 后命令行里的漂亮输出的</li>
<li>chai 是用来提供 assert 的</li>
</ul>
<blockquote>
<p>为了以后方便把 测试命令添加到 package.json里</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;:&#123;</span><br><span class="line">    &quot;test&quot;:&quot;mocha -r ts-node/register test/**/*.ts&quot;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">// 然后运行 yarn test 结果报错了</span><br><span class="line">// 因为开始的时候 我们是全局安装的 我们直接输入命令会在全局找</span><br><span class="line">// 而 yarn test 会默认从本地找模块 </span><br><span class="line"></span><br><span class="line">// 所以要把依赖加入本地</span><br><span class="line"></span><br><span class="line">yarn add typescript ts-node --dev</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="完善基本功能"><a href="#完善基本功能" class="headerlink" title="完善基本功能"></a>完善基本功能</h4></blockquote>
<p>src/promise.ts</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Promise2&#123;</span><br><span class="line">    succeed = null;</span><br><span class="line">    fail = null;</span><br><span class="line">    resolve()&#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            this.succeed();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    reject()&#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            this.fail();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    constructor(fn)&#123;</span><br><span class="line">        if(typeof fn !== &apos;function&apos;)&#123;</span><br><span class="line">            throw new Error(&quot;我只接受函数&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        fn(this.resolve.bind(this), this.reject.bind(this));</span><br><span class="line">    &#125;</span><br><span class="line">    then(succeed,fail)&#123;</span><br><span class="line">        this.succeed = succeed;</span><br><span class="line">        this.fail = fail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Promise2</span><br></pre></td></tr></table></figure>
<p>test/index.ts</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">import * as chai from &quot;chai&quot;;</span><br><span class="line"></span><br><span class="line">const assert = chai.assert;</span><br><span class="line">import Promise from &quot;../src/promise&quot;;</span><br><span class="line"></span><br><span class="line">describe(&quot;Promise&quot;,()=&gt;&#123;</span><br><span class="line">    it(&quot;是一个类&quot;,()=&gt;&#123;</span><br><span class="line">        assert.isFunction(Promise);</span><br><span class="line">        assert.isObject(Promise.prototype);</span><br><span class="line">    &#125;)</span><br><span class="line">    it(&quot;new Promise() 如果接受的不是一个函数就报错&quot;,()=&gt;&#123;</span><br><span class="line">        assert.throw(()=&gt;&#123;</span><br><span class="line">            // @ts-ignore</span><br><span class="line">            new Promise();</span><br><span class="line">        &#125;)</span><br><span class="line">        assert.throw(()=&gt;&#123;</span><br><span class="line">            // @ts-ignore</span><br><span class="line">            new Promise(1);</span><br><span class="line">        &#125;)</span><br><span class="line">        assert.throw(()=&gt;&#123;</span><br><span class="line">            // @ts-ignore</span><br><span class="line">            new Promise(false);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;new Promise(fn) 会生成一个对象，对象有 then 方法&quot;,()=&gt;&#123;</span><br><span class="line">        const promise = new Promise(()=&gt;&#123;&#125;)</span><br><span class="line">        assert.isFunction(promise.then);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;new Promise(fn) 中的 fn立即执行&quot;,()=&gt;&#123;</span><br><span class="line">        let called = false;</span><br><span class="line">        const promise = new Promise(()=&gt;&#123;</span><br><span class="line">            called = true;</span><br><span class="line">        &#125;)</span><br><span class="line">        // @ts-ignore</span><br><span class="line">        assert(called === true);</span><br><span class="line">    &#125;)</span><br><span class="line">    it(&quot;new Promise(fn) 中的 fn 执行的时候接受 resolve 和 reject 两个函数&quot;,()=&gt;&#123;</span><br><span class="line">        let called = false;</span><br><span class="line">        const promise = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            called = true;</span><br><span class="line">            assert.isFunction(resolve);</span><br><span class="line">            assert.isFunction(reject);</span><br><span class="line">        &#125;)</span><br><span class="line">        // @ts-ignore</span><br><span class="line">        assert(called === true);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;promise.then(success) 重的 success 会在 resolve 被调用的时候执行&quot;,(done)=&gt;&#123;</span><br><span class="line">        let called = false;</span><br><span class="line">        const promise = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            // 该函数没有执行</span><br><span class="line">            assert(called === false);</span><br><span class="line">            resolve();</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">                // 该函数执行了</span><br><span class="line">                assert(called === true);  </span><br><span class="line">                done();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">        // @ts-ignore</span><br><span class="line">        promise.then(()=&gt;&#123;</span><br><span class="line">            called = true;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="使用-sinon-测试函数"><a href="#使用-sinon-测试函数" class="headerlink" title="使用 sinon 测试函数"></a>使用 sinon 测试函数</h3><blockquote>
<p>上面我们经常这样来检查函数是不是被调用</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">it(&quot;new Promise(fn) 中的 fn立即执行&quot;,()=&gt;&#123;</span><br><span class="line">    let called = false;</span><br><span class="line">    const promise = new Promise(()=&gt;&#123;</span><br><span class="line">        called = true;</span><br><span class="line">    &#125;)</span><br><span class="line">    // @ts-ignore</span><br><span class="line">    assert(called === true);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4></blockquote>
<ul>
<li><code>yarn add sinon sinon-chai --dev</code></li>
<li><code>yarn add @types/sinon @types/sinon-chai --dev</code></li>
</ul>
<blockquote>
<p>基本用法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import * as chai from &quot;chai&quot;;</span><br><span class="line">import * as sinon from &quot;sinon&quot;;</span><br><span class="line">import * as sinonChai from &quot;sinon-chai&quot;;</span><br><span class="line">chai.use(sinonChai);</span><br><span class="line">const assert = chai.assert;</span><br><span class="line"></span><br><span class="line">it(&quot;new Promise(fn) 中的 fn立即执行&quot;,()=&gt;&#123;</span><br><span class="line">    let fn = sinon.fake();</span><br><span class="line">    new Promise(fn);</span><br><span class="line">    assert(fn.called);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用 chai 改写测试用例</p>
</blockquote>
<p>test/index.ts</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">import * as chai from &quot;chai&quot;;</span><br><span class="line">import * as sinon from &quot;sinon&quot;;</span><br><span class="line">import * as sinonChai from &quot;sinon-chai&quot;;</span><br><span class="line">chai.use(sinonChai);</span><br><span class="line">const assert = chai.assert;</span><br><span class="line">import Promise from &quot;../src/promise&quot;;</span><br><span class="line">import Sinon = require(&quot;sinon&quot;);</span><br><span class="line"></span><br><span class="line">describe(&quot;Promise&quot;,()=&gt;&#123;</span><br><span class="line">    it(&quot;是一个类&quot;,()=&gt;&#123;</span><br><span class="line">        assert.isFunction(Promise);</span><br><span class="line">        assert.isObject(Promise.prototype);</span><br><span class="line">    &#125;)</span><br><span class="line">    it(&quot;new Promise() 如果接受的不是一个函数就报错&quot;,()=&gt;&#123;</span><br><span class="line">        assert.throw(()=&gt;&#123;</span><br><span class="line">            // @ts-ignore</span><br><span class="line">            new Promise();</span><br><span class="line">        &#125;)</span><br><span class="line">        assert.throw(()=&gt;&#123;</span><br><span class="line">            // @ts-ignore</span><br><span class="line">            new Promise(1);</span><br><span class="line">        &#125;)</span><br><span class="line">        assert.throw(()=&gt;&#123;</span><br><span class="line">            // @ts-ignore</span><br><span class="line">            new Promise(false);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;new Promise(fn) 会生成一个对象，对象有 then 方法&quot;,()=&gt;&#123;</span><br><span class="line">        const promise = new Promise(()=&gt;&#123;&#125;)</span><br><span class="line">        assert.isFunction(promise.then);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;new Promise(fn) 中的 fn立即执行&quot;,()=&gt;&#123;</span><br><span class="line">        let fn = sinon.fake();</span><br><span class="line">        new Promise(fn);</span><br><span class="line">        assert(fn.called);</span><br><span class="line">    &#125;)</span><br><span class="line">    it(&quot;new Promise(fn) 中的 fn 执行的时候接受 resolve 和 reject 两个函数&quot;,(done)=&gt;&#123;</span><br><span class="line">        new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            assert.isFunction(resolve);</span><br><span class="line">            assert.isFunction(reject);</span><br><span class="line">            done();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&quot;promise.then(success) 重的 success 会在 resolve 被调用的时候执行&quot;,(done)=&gt;&#123;</span><br><span class="line">        const success = sinon.fake();</span><br><span class="line">        const promise = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            // 该函数没有执行</span><br><span class="line">            assert.isFalse(success.called);</span><br><span class="line">            resolve();</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">                // 该函数执行了</span><br><span class="line">                assert.isTrue(success.called);</span><br><span class="line">                done();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">        // @ts-ignore</span><br><span class="line">        promise.then(success);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">describe(&quot;Chai 的使用&quot;,()=&gt;&#123;</span><br><span class="line">    it(&quot;可以测试相等&quot;,()=&gt;&#123;</span><br><span class="line">        assert(1 === 1);</span><br><span class="line">        </span><br><span class="line">        // 因为我们用的是 ts, 你在任何一行在上 // @ts-ignore 那么ts就不会管这行符合不符合逻辑</span><br><span class="line">        // 之前如果不加会报错， 因为 2 永远不等于 3 ，你这样写是没意义的</span><br><span class="line">        // 由于你是在测试，所以经常会写这种代码</span><br><span class="line"></span><br><span class="line">        // @ts-ignore</span><br><span class="line">        assert( 2 === 3)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/01/Node-JS专精09-02使用chai和sinon/" data-id="ckl3ypv1r0095si91tsbemfjm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node后端/">Node后端</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/53/">53</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6速学/">ES6速学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS不知深浅/">JS不知深浅</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/M01/">M01</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/M02/">M02</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/M03/">M03</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/M04/">M04</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/M06/">M06</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/M07/">M07</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/M08/">M08</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/M09/">M09</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NodeWeb/">NodeWeb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node后端/">Node后端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ReactWheels/">ReactWheels</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React入门/">React入门</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TS入门/">TS入门</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/express/">express</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fullstack/">fullstack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jQuery/">jQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mobile/">mobile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb/">mongodb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/">node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node每日精进/">node每日精进</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oak/">oak</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tools/">tools</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/">vim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vultr/">vultr</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web性能优化/">web性能优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web面经/">web面经</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端知识点/">前端知识点</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 13.91px;">CSS</a> <a href="/tags/ES6速学/" style="font-size: 14.35px;">ES6速学</a> <a href="/tags/JS不知深浅/" style="font-size: 11.3px;">JS不知深浅</a> <a href="/tags/M01/" style="font-size: 13.48px;">M01</a> <a href="/tags/M02/" style="font-size: 15.22px;">M02</a> <a href="/tags/M03/" style="font-size: 15.65px;">M03</a> <a href="/tags/M04/" style="font-size: 16.09px;">M04</a> <a href="/tags/M06/" style="font-size: 18.26px;">M06</a> <a href="/tags/M07/" style="font-size: 17.83px;">M07</a> <a href="/tags/M08/" style="font-size: 16.96px;">M08</a> <a href="/tags/M09/" style="font-size: 11.74px;">M09</a> <a href="/tags/NodeWeb/" style="font-size: 12.17px;">NodeWeb</a> <a href="/tags/Node后端/" style="font-size: 18.7px;">Node后端</a> <a href="/tags/ReactWheels/" style="font-size: 16.52px;">ReactWheels</a> <a href="/tags/React入门/" style="font-size: 15.22px;">React入门</a> <a href="/tags/TS入门/" style="font-size: 14.78px;">TS入门</a> <a href="/tags/express/" style="font-size: 10.43px;">express</a> <a href="/tags/fullstack/" style="font-size: 17.83px;">fullstack</a> <a href="/tags/http/" style="font-size: 12.17px;">http</a> <a href="/tags/jQuery/" style="font-size: 10px;">jQuery</a> <a href="/tags/java/" style="font-size: 19.13px;">java</a> <a href="/tags/linux/" style="font-size: 10.87px;">linux</a> <a href="/tags/mobile/" style="font-size: 11.3px;">mobile</a> <a href="/tags/mongodb/" style="font-size: 12.61px;">mongodb</a> <a href="/tags/mysql/" style="font-size: 12.61px;">mysql</a> <a href="/tags/node/" style="font-size: 10.43px;">node</a> <a href="/tags/node每日精进/" style="font-size: 10px;">node每日精进</a> <a href="/tags/oak/" style="font-size: 20px;">oak</a> <a href="/tags/python/" style="font-size: 17.39px;">python</a> <a href="/tags/tools/" style="font-size: 10px;">tools</a> <a href="/tags/vim/" style="font-size: 10px;">vim</a> <a href="/tags/vue/" style="font-size: 13.04px;">vue</a> <a href="/tags/vultr/" style="font-size: 10px;">vultr</a> <a href="/tags/web性能优化/" style="font-size: 10px;">web性能优化</a> <a href="/tags/web面经/" style="font-size: 10px;">web面经</a> <a href="/tags/前端知识点/" style="font-size: 19.57px;">前端知识点</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/01/20/HTTP06密码学到https流程/">HTTP06密码学到https流程</a>
          </li>
        
          <li>
            <a href="/2021/01/19/HTTP05缓存控制/">HTTP05缓存控制</a>
          </li>
        
          <li>
            <a href="/2021/01/18/HTTP04报文和http状态码/">HTTP04报文和http状态码</a>
          </li>
        
          <li>
            <a href="/2021/01/17/HTTP03http常用方法/">HTTP03http常用方法</a>
          </li>
        
          <li>
            <a href="/2021/01/16/HTTP02三次握手四度挥手/">HTTP02三次握手四度挥手</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Stevin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>