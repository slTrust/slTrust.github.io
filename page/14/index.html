
 <!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  
    <title>Almost</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Stevin">
    

    
    <meta property="og:type" content="website">
<meta property="og:title" content="Almost">
<meta property="og:url" content="http://yoursite.com/page/14/index.html">
<meta property="og:site_name" content="Almost">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Almost">

    
    <link rel="alternative" href="/atom.xml" title="Almost" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>
</html>
  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Almost" title="Almost"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Almost">Almost</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/07/16/ZB-017-java包管理和maven/" title="ZB-017-java包管理和maven" itemprop="url">ZB-017-java包管理和maven</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Stevin" target="_blank" itemprop="author">Stevin</a>
		
  <p class="article-time">
    <time datetime="2019-07-16T12:47:35.000Z" itemprop="datePublished"> Published 2019-07-16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="什么是包"><a href="#什么是包" class="headerlink" title="什么是包"></a>什么是包</h3><ul>
<li>JVM的⼯作被设计地相当简单：<ol>
<li>执⾏⼀个类的字节码</li>
<li>假如这个过程中碰到了新的类，加载它，然后回到第一步，这样循环往复</li>
</ol>
</li>
</ul>
<blockquote>
<p>那么，去哪⾥加载这些类呢？</p>
</blockquote>
<ul>
<li>答案是 classpath<strong>类路径</strong></li>
</ul>
<h3 id="类路径（Classpath）"><a href="#类路径（Classpath）" class="headerlink" title="类路径（Classpath）"></a>类路径（Classpath）</h3><ul>
<li>在哪⾥可以找到类<ul>
<li>-classpath/-cp</li>
</ul>
</li>
<li>类的全限定类名（⽬录层级）唯⼀确定了⼀个类</li>
<li>包就是把许多类放在⼀起打的压缩包 <strong>jar 包</strong></li>
</ul>
<p>每次 IDEA 运行java项目显示的命令行</p>
<p><strong>程序运行时：会挨个在 classpath路径里找。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/bin/java &quot;-javaagent:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=51272:</span><br><span class="line">/Applications/IntelliJ IDEA.app/Contents/bin&quot; </span><br><span class="line">-Dfile.encoding=UTF-8 </span><br><span class="line">-classpath </span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/charsets.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/deploy.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/ext/dnsns.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/ext/jaccess.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/ext/localedata.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/ext/nashorn.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/ext/sunec.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/ext/zipfs.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/javaws.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/jce.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/jfr.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/jfxswt.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/jsse.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/management-agent.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/plugin.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/resources.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/rt.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/lib/dt.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/lib/javafx-mx.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/lib/jconsole.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/lib/packager.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/lib/sa-jdi.jar:</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/lib/tools.jar:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 当前目录的 target/classes 就是本项目里的 类文件</span><br><span class="line"></span><br><span class="line">/Users/huangjiaxi/Desktop/java-fork-process/target/classes </span><br><span class="line"></span><br><span class="line">com.github.hcsp.shell.Fork</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="什么是-jar-文件"><a href="#什么是-jar-文件" class="headerlink" title="什么是 jar 文件"></a>什么是 jar 文件</h4></blockquote>
<ul>
<li>实际就是 跟<code>zip</code>一样压缩后的文件，只不过这里叫 <code>jar包</code></li>
</ul>
<h5 id="每当-JVM-需要一个类时，它就会在当前的-classpath里-按照这个类的全限定类名挨个找，如果是jar包就解压缩然后在解压缩后的目录里找，如果是一个文件夹就直接按照目录找，找不到就抛出-classNotFound"><a href="#每当-JVM-需要一个类时，它就会在当前的-classpath里-按照这个类的全限定类名挨个找，如果是jar包就解压缩然后在解压缩后的目录里找，如果是一个文件夹就直接按照目录找，找不到就抛出-classNotFound" class="headerlink" title="每当 JVM 需要一个类时，它就会在当前的 classpath里 按照这个类的全限定类名挨个找，如果是jar包就解压缩然后在解压缩后的目录里找，如果是一个文件夹就直接按照目录找，找不到就抛出 classNotFound"></a>每当 JVM 需要一个类时，它就会在当前的 classpath里 按照这个类的全限定类名挨个找，如果是jar包就解压缩然后在解压缩后的目录里找，如果是一个文件夹就直接按照目录找，找不到就抛出 classNotFound</h5><blockquote>
<p>如果你依赖的类中还依赖了别的包呢？</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A 依赖 B , B 依赖 C , C 又依赖 D</span><br><span class="line">D 从那里找呢？</span><br></pre></td></tr></table></figure>
<p>这就是 <strong>传递性依赖</strong> ,这就是为什么上面的命令行里 classpach 那么长的原因，要把所有依赖的path 添加进来</p>
<p>一个简单的项目命令行尚且如此之长，而一个真实项目可能有成百上千的依赖，如果你手动拼接，肯定又各种各样的问题，这就是为什么使用自动化工具的原因。</p>
<p>自动化的本质就是：帮我们把一些很啰嗦很累赘变成自动化</p>
<h3 id="别急，还没完"><a href="#别急，还没完" class="headerlink" title="别急，还没完"></a>别急，还没完</h3><blockquote>
<p>没有maven时，你要手动导入jar包还有相关依赖，多人协作的时候非常麻烦。</p>
</blockquote>
<ul>
<li>传递性依赖<ul>
<li>你依赖的类还依赖了别的类</li>
</ul>
</li>
<li>Classpath hell<ul>
<li>全限定类名是类的唯⼀标识</li>
<li>当多个同名类同时出现在Classpath中，就是噩梦的开始</li>
</ul>
</li>
</ul>
<blockquote>
<h4 id="当你的-classpath里包含了相同包，但是版本不同会发生什么"><a href="#当你的-classpath里包含了相同包，但是版本不同会发生什么" class="headerlink" title="当你的 classpath里包含了相同包，但是版本不同会发生什么"></a>当你的 classpath里包含了相同包，但是版本不同会发生什么</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-classpath </span><br><span class="line">xxx.5.0.0.jar:</span><br><span class="line">xxx.4.0.0.jar</span><br></pre></td></tr></table></figure>
<ul>
<li>此时两个jar包里 有同名类 a</li>
<li>在你程序运行时 会引用那个 类？</li>
</ul>
<p>答案是 <strong>谁在前面用谁</strong></p>
<blockquote>
<h4 id="问题升级，引入版本不同，但是同名的jar包"><a href="#问题升级，引入版本不同，但是同名的jar包" class="headerlink" title="问题升级，引入版本不同，但是同名的jar包"></a>问题升级，引入版本不同，但是同名的jar包</h4></blockquote>
<ul>
<li>版本不同的时候，代码可能是不一样的，以致于你的程序看上去可以运行。突然三天或三年后的某一天突然运行到一个地方出错了。你就很懵  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-classpath </span><br><span class="line">xxx.4.0.0.jar: </span><br><span class="line">xxx.5.0.0.jar</span><br><span class="line"></span><br><span class="line"># 4.0.0 是你实际使用的jar包</span><br><span class="line"># 5.0.0 是更新后的一个大版本修复了4.0.0的某些bug, 可能一些方法 API 已经变的面目全非了。</span><br><span class="line">但是在你看在程序还是正常的跑，只是没运行到出bug的地方</span><br><span class="line">你的项目如期上线，然后某天爆出个bug</span><br><span class="line">这个情况就叫 Classpath hell 依赖地狱</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="什么是包管理"><a href="#什么是包管理" class="headerlink" title="什么是包管理"></a>什么是包管理</h3><ul>
<li>你要使⽤⼀些第三⽅类，总要告诉JVM从哪⾥找吧？</li>
<li>包管理的本质就是告诉JVM如何找到所需的第三⽅类库</li>
<li>以及成功地解决其中的冲突问题</li>
</ul>
<h3 id="没有Maven的蛮荒年代"><a href="#没有Maven的蛮荒年代" class="headerlink" title="没有Maven的蛮荒年代"></a>没有Maven的蛮荒年代</h3><blockquote>
<p>以前怎么做的这些依赖</p>
</blockquote>
<h4 id="黑暗时代"><a href="#黑暗时代" class="headerlink" title="黑暗时代"></a>黑暗时代</h4><ul>
<li>⼿动写命令进⾏编译运⾏</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javac -cp  xx.jar xx2.jar Main.java</span><br><span class="line">java -cp xx.jar xx2.jar Main</span><br><span class="line"></span><br><span class="line"># 假设此时 jar包成百上千呢？</span><br></pre></td></tr></table></figure>
<h4 id="启蒙时代"><a href="#启蒙时代" class="headerlink" title="启蒙时代"></a>启蒙时代</h4><ul>
<li>Apache Ant<ul>
<li>⼿动下载jar包，放在⼀个⽬录中</li>
<li>写XML配置，指定编译的源代码⽬录、依赖的jar包、输出<br>⽬录等</li>
</ul>
</li>
<li>缺点<ul>
<li>每个⼈都要⾃⼰造⼀套轮⼦<ol>
<li>我的放在 libs</li>
<li>你的放在 sources</li>
<li>他的放在 libaray </li>
</ol>
</li>
<li>依赖的第三⽅类库都需要⼿动下载，费时费⼒<ul>
<li>假如你的应⽤依赖了⼀万个第三⽅的类库呢？都需要把依赖的库挨个下载下来</li>
</ul>
</li>
<li>没有解决Classpath地狱的问题，碰上重复的库你就完蛋了</li>
</ul>
</li>
</ul>
<h4 id="Maven——划时代的包管理"><a href="#Maven——划时代的包管理" class="headerlink" title="Maven——划时代的包管理"></a>Maven——划时代的包管理</h4><ul>
<li>Convention over configuration</li>
<li>约定优于配置</li>
<li>必须强调，Maven远远不⽌是包管理⼯具</li>
<li>Maven的中央仓库<ul>
<li>按照⼀定的约定存储包（坐标）</li>
</ul>
</li>
<li>Maven的本地仓库<ul>
<li>默认位于~/.m2</li>
<li>下载的第三⽅包放在这⾥进⾏缓存</li>
</ul>
</li>
<li>Maven的包<ul>
<li>按照约定为所有的包编号，⽅便检索</li>
<li>groupId/artifactId/version<ul>
<li>扩展：语义化版本</li>
</ul>
</li>
<li>SNAPSHOT快照版本</li>
</ul>
</li>
</ul>
<blockquote>
<p>当你不知道一个包的坐标你就搜 </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xxx.xxx.xxx maven 通常第一个就是包的正确的名字</span><br><span class="line"></span><br><span class="line">每个包有自己的版本</span><br><span class="line">如 junit-jupiter-api 5.5.0</span><br><span class="line">它会不停的升级。版本一旦发布，maven的约定是不能更改只能继续升级。 </span><br><span class="line">目的是 maven 想要实现一个可重现的构建，就是你机子上跑的和我机子上跑的 是一样的。 </span><br><span class="line"></span><br><span class="line">因为一旦同版本允许修改，就可能你跑的时候是好的，我跑的时候是坏的</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="maven-为什么知道包从哪里下载呢？"><a href="#maven-为什么知道包从哪里下载呢？" class="headerlink" title="maven 为什么知道包从哪里下载呢？"></a>maven 为什么知道包从哪里下载呢？</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">当你引入依赖</span><br><span class="line"></span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-api --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.4.2&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">maven 就会去它的主仓库 https://repo1.maven.org/maven2/</span><br><span class="line">按照你的 groupId 里的路径 </span><br><span class="line">https://repo1.maven.org/maven2/org</span><br><span class="line">https://repo1.maven.org/maven2/org/junit/</span><br><span class="line">https://repo1.maven.org/maven2/org/junit/jupiter</span><br><span class="line"></span><br><span class="line">然后按照 artifactId 找路径</span><br><span class="line">https://repo1.maven.org/maven2/org/junit/jupiter/junit-jupiter-engine/</span><br><span class="line"></span><br><span class="line">然后按照版本号 5.4.2</span><br><span class="line">https://repo1.maven.org/maven2/org/junit/jupiter/junit-jupiter-engine/5.4.2/</span><br></pre></td></tr></table></figure>
<p>里面有一堆文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">junit-jupiter-engine-5.4.2-javadoc.jar            2019-04-07 17:29    683506      </span><br><span class="line">junit-jupiter-engine-5.4.2-javadoc.jar.asc        2019-04-07 17:29       821      </span><br><span class="line">junit-jupiter-engine-5.4.2-javadoc.jar.asc.md...  2019-04-07 17:29        32      </span><br><span class="line">junit-jupiter-engine-5.4.2-javadoc.jar.asc.sh...  2019-04-07 17:29        40      </span><br><span class="line">junit-jupiter-engine-5.4.2-javadoc.jar.md5        2019-04-07 17:29        32      </span><br><span class="line">junit-jupiter-engine-5.4.2-javadoc.jar.sha1       2019-04-07 17:29        40    </span><br><span class="line"># 源代码  </span><br><span class="line">junit-jupiter-engine-5.4.2-sources.jar            2019-04-07 17:29    110900      </span><br><span class="line">junit-jupiter-engine-5.4.2-sources.jar.asc        2019-04-07 17:29       821      </span><br><span class="line">junit-jupiter-engine-5.4.2-sources.jar.asc.md...  2019-04-07 17:29        32      </span><br><span class="line">junit-jupiter-engine-5.4.2-sources.jar.asc.sh...  2019-04-07 17:29        40      </span><br><span class="line">junit-jupiter-engine-5.4.2-sources.jar.md5        2019-04-07 17:29        32      </span><br><span class="line">junit-jupiter-engine-5.4.2-sources.jar.sha1       2019-04-07 17:29        40      </span><br><span class="line"># 真正的 jar包</span><br><span class="line">junit-jupiter-engine-5.4.2.jar                    2019-04-07 17:29    177798      </span><br><span class="line">junit-jupiter-engine-5.4.2.jar.asc                2019-04-07 17:29       821      </span><br><span class="line">junit-jupiter-engine-5.4.2.jar.asc.md5            2019-04-07 17:29        32      </span><br><span class="line">junit-jupiter-engine-5.4.2.jar.asc.sha1           2019-04-07 17:29        40      </span><br><span class="line">junit-jupiter-engine-5.4.2.jar.md5                2019-04-07 17:29        32      </span><br><span class="line">junit-jupiter-engine-5.4.2.jar.sha1               2019-04-07 17:29        40    </span><br><span class="line"># 当前包所依赖的包  </span><br><span class="line">junit-jupiter-engine-5.4.2.pom                    2019-04-07 17:29      2395      </span><br><span class="line">junit-jupiter-engine-5.4.2.pom.asc                2019-04-07 17:29       821      </span><br><span class="line">junit-jupiter-engine-5.4.2.pom.asc.md5            2019-04-07 17:29        32      </span><br><span class="line">junit-jupiter-engine-5.4.2.pom.asc.sha1           2019-04-07 17:29        40      </span><br><span class="line">junit-jupiter-engine-5.4.2.pom.md5                2019-04-07 17:29        32      </span><br><span class="line">junit-jupiter-engine-5.4.2.pom.sha1               2019-04-07 17:29        40</span><br></pre></td></tr></table></figure>
<p>这样就实现了。你pom引入了一个junit-jupiter-engine-5.4.2的依赖，然后它下载后根据junit-jupiter-engine-5.4.2.pom文件去下载 当前包的依赖(传递性依赖)</p>
<p><strong>这样就形成了一颗依赖树</strong>，你可以在 IDEA maven工具栏的<code>Dependencies</code> 里看到</p>
<p><code>pom.xml</code>里的aliyun镜像,就是为了下载更快。也可以配置到你本地安装的maven里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;repositories&gt;</span><br><span class="line">    &lt;repository&gt;</span><br><span class="line">        &lt;id&gt;alimaven&lt;/id&gt;</span><br><span class="line">        &lt;name&gt;aliyun maven&lt;/name&gt;</span><br><span class="line">        &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;</span><br><span class="line">    &lt;/repository&gt;</span><br><span class="line">&lt;/repositories&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="Maven的包"><a href="#Maven的包" class="headerlink" title="Maven的包"></a>Maven的包</h4></blockquote>
<ul>
<li>按照约定为所有的包编号，⽅便检索</li>
<li>groupId/artifactId/version<ul>
<li>扩展：<a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener">语义化版本 x.y.z</a></li>
</ul>
</li>
<li>SNAPSHOT快照版本  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">https://repo1.maven.org/maven2/org/junit/jupiter/junit-jupiter-engine/</span><br><span class="line"></span><br><span class="line">里 你开发的包可能不会立马上线，需要一直测一直改一直发布。但是总不能每次都发布一个版本吧！ </span><br><span class="line">5.0.0/                                            2017-09-10 18:09         -      </span><br><span class="line">5.0.0-M1/                                         2016-07-07 09:05         -      </span><br><span class="line">5.0.0-M2/                                         2016-07-23 18:14         -      </span><br><span class="line">5.0.0-M3/                                         2016-11-30 09:06         -      </span><br><span class="line">5.0.0-M4/                                         2017-04-01 19:23         -      </span><br><span class="line">5.0.0-M5/                                         2017-07-04 16:39         -      </span><br><span class="line">5.0.0-M6/                                         2017-07-18 19:27         -      </span><br><span class="line"># RC叫做 发布准备版 但是它们都不是 SNAPSHOT快照版本，也基本不会在中央仓库里放置</span><br><span class="line"># 中央仓库都是放成熟的。</span><br><span class="line">5.0.0-RC1/                                        2017-07-30 19:13         -      </span><br><span class="line">5.0.0-RC2/                                        2017-07-30 20:37         -</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>maven 默认会帮你下载字节码的包，如需看源码 可以在 IDEA 点击下载 </p>
<h4 id="包冲突"><a href="#包冲突" class="headerlink" title="包冲突"></a>包冲突</h4><blockquote>
<p>当你看到如下的异常的时候，<strong>包冲突发生了</strong></p>
<ul>
<li>AbstractMethodError</li>
<li>NoClassDefFoundError</li>
<li>ClassNotFoundException</li>
<li>LinkageError</li>
</ul>
</blockquote>
<blockquote>
<p>举个例子</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">你的项目里</span><br><span class="line">依赖了 A</span><br><span class="line">依赖了 D</span><br><span class="line"></span><br><span class="line">A 又依赖了 B , B又依赖了 C</span><br><span class="line">D 又依赖了 C</span><br><span class="line"></span><br><span class="line">|A</span><br><span class="line">--|B</span><br><span class="line">--|--|C 1.0</span><br><span class="line"></span><br><span class="line">|D</span><br><span class="line">--|C 2.0</span><br><span class="line"></span><br><span class="line">此时 两个 C 就导致了 包冲突</span><br><span class="line"></span><br><span class="line">-classpath A:B:C1.0:D:C2.0</span><br><span class="line"></span><br><span class="line"># 因为之前说了 classpath hell 依赖地狱</span><br><span class="line">由于全限定类名是类的唯一标识，此时如果存在两个同名不同版本的库 同时出现在 classpath 中 那么噩梦开始了</span><br><span class="line"></span><br><span class="line">如果有同名的库出现在 classpath 中 JVM 会选择靠前的那个 也就是 C1.0</span><br><span class="line"></span><br><span class="line">但是 靠前的那个 C1.0 不一定是你想要的那个，有可能只是你忘了。</span><br></pre></td></tr></table></figure>
<p><strong>对此</strong> maven 的原则是</p>
<ul>
<li>传递性依赖的⾃动管理<ul>
<li>原则：绝对不允许最终的classpath出现同名不同版本的jar包</li>
</ul>
</li>
<li><p>依赖冲突的解决：原则：<strong>最近的胜出</strong> </p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">你的项目里</span><br><span class="line">依赖了 A</span><br><span class="line">依赖了 D</span><br><span class="line"></span><br><span class="line">A 又依赖了 B , B又依赖了 C</span><br><span class="line">D 又依赖了 C</span><br><span class="line"></span><br><span class="line">|A</span><br><span class="line">--|B</span><br><span class="line">--|--|C 1.0</span><br><span class="line"></span><br><span class="line">|D</span><br><span class="line">--|C 2.0</span><br><span class="line"></span><br><span class="line">C2.0 更加离 依赖树的根更近</span><br><span class="line">也就是 C2.0 获胜，淘汰 C1.0</span><br><span class="line">-classpath A:B:D:C2.0</span><br></pre></td></tr></table></figure>
<ul>
<li>这个过程绝大多数是可以正常工作的，但是</li>
<li><code>mvn dependency:tree</code>  </li>
</ul>
</li>
<li>依赖的scope</li>
</ul>
<blockquote>
<h4 id="实战：解决包冲突"><a href="#实战：解决包冲突" class="headerlink" title="实战：解决包冲突"></a>实战：解决包冲突</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">你的项目依赖了 A / D</span><br><span class="line"></span><br><span class="line">|A 0.1</span><br><span class="line">--|B 0.1</span><br><span class="line">--|--|C 0.2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">|D 0.1</span><br><span class="line">--|C 0.1 </span><br><span class="line"></span><br><span class="line">此时 maven 帮你淘汰了 C0.2 版本 因为它离得太远</span><br><span class="line">-classpath A0.1:D0.1:B0.1:C0.1</span><br><span class="line"></span><br><span class="line">此时就有 bug ,因为你想要的是 C0.2</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="为什么会干掉-C0-2-而不是C0-1"><a href="#为什么会干掉-C0-2-而不是C0-1" class="headerlink" title="为什么会干掉 C0.2,而不是C0.1"></a>为什么会干掉 C0.2,而不是C0.1</h4></blockquote>
<ul>
<li>答案是 <strong>maven就是这样设计的，它不分析语义版本，对于人类我们知道 0.2&gt;0.1,但是maven在设计上的原则是谁离得更近，Gradle的策略是选择版本高的，但这也不是万能的。</strong></li>
<li>很多时候还是要人工介入</li>
</ul>
<blockquote>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4></blockquote>
<ol>
<li><p>强行引入 C0.2版本</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|A 0.1</span><br><span class="line">--|B 0.1</span><br><span class="line">--|--|C 0.2</span><br><span class="line"></span><br><span class="line">|D 0.1</span><br><span class="line">--|C 0.1 </span><br><span class="line"></span><br><span class="line">|C0.2</span><br><span class="line"></span><br><span class="line">C0.2 离得比 C0.1近。所以淘汰 C0.1</span><br></pre></td></tr></table></figure>
</li>
<li><p>exclusion 排除指定依赖</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">|A 0.1</span><br><span class="line">--|B 0.1</span><br><span class="line">--|--|C 0.2</span><br><span class="line"></span><br><span class="line">|D 0.1</span><br><span class="line">--|C 0.1 </span><br><span class="line">通过 exclusion 来告诉 maven 忽略某个依赖 的子依赖</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;xxx.xxx&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;D&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.1&lt;/version&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;groupId&gt;yyy.yyyy&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;C&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;0.1&lt;/version&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个IDEA 插件 <code>maven helper</code></p>
<ul>
<li>能帮你分析当前的依赖树 和被淘汰的依赖标红显示</li>
<li>你想排除指定版本只需要选中依赖 点击 <code>Exclude</code></li>
<li>一目了然帮你看到依赖树</li>
</ul>
</li>
</ol>
<blockquote>
<h4 id="如下依赖谁会被淘汰"><a href="#如下依赖谁会被淘汰" class="headerlink" title="如下依赖谁会被淘汰"></a>如下依赖谁会被淘汰</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">|A </span><br><span class="line">--|B </span><br><span class="line">--|--|C0.1</span><br><span class="line"></span><br><span class="line">|D</span><br><span class="line">--|E </span><br><span class="line">----|C0.2</span><br><span class="line"></span><br><span class="line">C0.1 获胜，因为C0.1 路径相同则选择靠前的那个</span><br></pre></td></tr></table></figure>
<h4 id="依赖的-scope"><a href="#依赖的-scope" class="headerlink" title="依赖的 scope"></a>依赖的 scope</h4><blockquote>
<p>实现代码的隔离</p>
</blockquote>
<ul>
<li><code>&lt;scope&gt;test&lt;/scope&gt;</code> 代表只在 src/test目录可见</li>
<li><code>&lt;scope&gt;compile&lt;/scope&gt;</code> 在 src/main 和 src/test 都有效</li>
<li><code>&lt;scope&gt;provided&lt;/scope&gt;</code> 只在编译的时候有效<ol>
<li>我们运行java的时候 右键 run 会先编译，此时会把依赖包在 -classpath 里体现</li>
<li>而在运行的时候 -classpath 不包含依赖包的路径</li>
<li>它的意思就是 编译的时候需要，运行的时候别人帮我提供，你不需要帮我加,防止包冲突。 最经典的就是 tomcat ，你的项目编译后会放在 tomcat容器里，tomcat 会帮你提供这些依赖包<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.4.2&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.4.2&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h3 id="maven-不仅仅是包管理工具还是一个自动化构建工具"><a href="#maven-不仅仅是包管理工具还是一个自动化构建工具" class="headerlink" title="maven 不仅仅是包管理工具还是一个自动化构建工具"></a>maven 不仅仅是包管理工具还是一个自动化构建工具</h3><blockquote>
<p>推荐一本书 Maven实战 google搜 <a href="https://github.com/skyformat99/books-1/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E2%97%8F%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E2%97%8F%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/Maven%E5%AE%9E%E6%88%98.pdf" target="_blank" rel="noopener">Maven实战 site:github.com</a></p>
</blockquote>
<ul>
<li>Maven实战哪些章节是值得看的？<ul>
<li>1 简介可以看看</li>
<li>3.1-3.4 代码是过时的</li>
<li>4 可以看 背景案例也是过时的 看场景</li>
<li>5  </li>
<li>6</li>
<li>7 </li>
<li>8</li>
<li>其他选看</li>
</ul>
</li>
<li>Maven项⽬的基本结构（传世经典）</li>
<li>基本概念：坐标和依赖/⽣命周期/仓库/聚合和继承</li>
<li>使⽤Maven进⾏测试</li>
<li>如果需要开发插件的话：</li>
<li>Maven的插件</li>
</ul>
<h3 id="真实世界中的Maven"><a href="#真实世界中的Maven" class="headerlink" title="真实世界中的Maven"></a>真实世界中的Maven</h3><ul>
<li>分析若⼲真实世界的Maven仓库</li>
<li>pom的含义 <strong>project object model</strong> 项目说明书</li>
</ul>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ol>
<li><a href="https://github.com/hcsp/fix-commons-lang-pom" target="_blank" rel="noopener">修复commons-lang项目的pom文件</a><br> <a href="https://github.com/hcsp/fix-commons-lang-pom/pull/6" target="_blank" rel="noopener">我的pr</a></li>
<li><a href="https://github.com/hcsp/resolve-package-conflict" target="_blank" rel="noopener">解决包冲突</a><br> <a href="https://github.com/hcsp/resolve-package-conflict/pull/4" target="_blank" rel="noopener">我的pr</a></li>
<li><a href="https://github.com/hcsp/implement-sem-version" target="_blank" rel="noopener">实现语义化版本</a><br> <a href="https://github.com/hcsp/implement-sem-version/pull/1" target="_blank" rel="noopener">我的pr</a></li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/oak/">oak</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/07/15/ZB-016-命令行详解02/" title="ZB-016-命令行详解02" itemprop="url">ZB-016-命令行详解02</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Stevin" target="_blank" itemprop="author">Stevin</a>
		
  <p class="article-time">
    <time datetime="2019-07-15T13:41:27.000Z" itemprop="datePublished"> Published 2019-07-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="输⼊与输出"><a href="#输⼊与输出" class="headerlink" title="输⼊与输出"></a>输⼊与输出</h3><blockquote>
<p>进程启动之后有三个要素，它们不和任何编程语言绑定，而且任何编程语言里都有这样的概念</p>
</blockquote>
<ul>
<li>标准输⼊ stdin</li>
<li>标准输出 stdout</li>
<li>标准错误 stderr</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        // 标准输出</span><br><span class="line">        System.out.println(&quot;output&quot;)</span><br><span class="line">        // 标准错误</span><br><span class="line">        System.err.println(&quot;error&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行我们的 java</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javac Main.java &amp;&amp; java Main</span><br><span class="line">输出</span><br><span class="line">output</span><br><span class="line">error</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在操作系统中</p>
</blockquote>
<ul>
<li>stdout 叫做 “文件描述符1”</li>
<li>stderr 叫做 “文件描述符2”</li>
</ul>
<blockquote>
<p>将输出放到文件里</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">java Main &gt; output.txt</span><br><span class="line"># 发现少了一行，因为输出默认会把标准输出重定向到文件里</span><br><span class="line">&gt; error </span><br><span class="line"></span><br><span class="line"># 一个 “&gt;” 代表重写覆盖， 两个&quot;&gt;&gt;&quot;代表追加</span><br><span class="line"></span><br><span class="line">重定向的 &quot;&gt;&quot; 默认等价于 &quot;文件描述符1&quot;</span><br><span class="line"></span><br><span class="line"># 执行 文件描述符2</span><br><span class="line">java Main 2&gt; output.txt</span><br><span class="line"># error 写在了 文件里</span><br><span class="line">&gt; output</span><br><span class="line"></span><br><span class="line"># 如何把 标准输出和 标准错误 同时输出到一个文件里</span><br><span class="line">java Main &gt; output 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line"># 顺序写反是无效的</span><br><span class="line">java Main &gt; output 1&gt;&amp;2</span><br><span class="line">error</span><br><span class="line"></span><br><span class="line"># 现在会同时打印 标准输出和标准错误， 此时我只想要 标准输出,不要标准错误</span><br><span class="line">java Main 2&gt; /dev/null</span><br><span class="line"># 意思是把 错误输出丢到垃圾桶里</span><br></pre></td></tr></table></figure>
<ul>
<li>输出的重定向<ul>
<li>覆盖⽂件</li>
<li>追加⽂件</li>
<li>改变流向</li>
<li>/dev/null</li>
</ul>
</li>
</ul>
<h4 id="Linux常⽤命令"><a href="#Linux常⽤命令" class="headerlink" title="Linux常⽤命令"></a>Linux常⽤命令</h4><ul>
<li>进⼊⽬录 cd (change directory)</li>
<li>展示⽂件 ls/ll/ls -alth (list)</li>
<li>移动/重命名⽂件 mv (move)</li>
<li>删除⽂件 rm/rm -r/rm -rf (remove)</li>
<li>拷⻉⽂件 cp/cp -r (copy)</li>
<li>显示变量 echo</li>
<li>导出变量 export</li>
<li>Git系列操作 git pull/push/add/commit/…</li>
</ul>
<h4 id="Linux常⽤命令-1"><a href="#Linux常⽤命令-1" class="headerlink" title="Linux常⽤命令"></a>Linux常⽤命令</h4><ul>
<li>新建⽬录 mkdir/mkdir -p (make directory)</li>
<li>当前⽬录 pwd (print working directory)</li>
<li>显示⽂件 cat (concatenate and print files)</li>
<li>编辑⽂件 vi</li>
</ul>
<h4 id="怎么才能掌握命令行？"><a href="#怎么才能掌握命令行？" class="headerlink" title="怎么才能掌握命令行？"></a>怎么才能掌握命令行？</h4><blockquote>
<p>以下方式逐级晋升</p>
</blockquote>
<ul>
<li>⾃⼰对着书敲命令</li>
<li>尽可能地在开发中使⽤命令⾏</li>
<li>vi/git/mkdir, etc.</li>
<li>使⽤命令⾏的各种⼩⼯具</li>
<li>开发命令⾏的程序</li>
<li>⾃⾏在云服务器上开发部署博客</li>
<li>⾃⾏在云服务器上进⾏持续集成实战</li>
<li>⽇常使⽤Linux进⾏开发</li>
</ul>
<h4 id="使用命令编译java程序"><a href="#使用命令编译java程序" class="headerlink" title="使用命令编译java程序"></a>使用命令编译java程序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 环境变量 </span><br><span class="line">System.getenv(&quot;aaa&quot;)</span><br><span class="line"></span><br><span class="line">// 系统属性 只在 jvm 中有效</span><br><span class="line">System.getProperty(&quot;xxx&quot;)</span><br><span class="line">System.getProperty(&quot;java.version&quot;)</span><br><span class="line">System.getProperty(&quot;user.dir&quot;)</span><br></pre></td></tr></table></figure>
<p>Main.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(&quot;args:&quot;+ java.util.Arrays.toString(args));</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;env:&quot;+System.getenv(&quot;AAA&quot;));</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;java version:&quot;+System.getProperty(&quot;java.version&quot;));</span><br><span class="line">        // System.getProperty(&quot;user.dir&quot;)</span><br><span class="line"></span><br><span class="line">         System.out.println(&quot;system property:&quot;+System.getProperty(&quot;BBB&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">javac Main.java &amp;&amp; java Main 1 2 3</span><br><span class="line"></span><br><span class="line">args:[1,2,3]</span><br><span class="line">env: null</span><br><span class="line">java version:1.8.0...</span><br><span class="line">system property:null</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 传递 系统属性</span><br><span class="line">export AAA=123</span><br><span class="line">java -DBBB=789 Main </span><br><span class="line"></span><br><span class="line">args:[]</span><br><span class="line">env: 123</span><br><span class="line">java version:1.8.0...</span><br><span class="line">system property:789</span><br></pre></td></tr></table></figure>
<h5 id="D-的顺序有要求"><a href="#D-的顺序有要求" class="headerlink" title="-D 的顺序有要求"></a><code>-D</code> 的顺序有要求</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">javac -DBBB=789 Main</span><br><span class="line">args:[]</span><br><span class="line">env: 123</span><br><span class="line">java version:1.8.0...</span><br><span class="line">system property:789</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">javac  Main -DBBB=789</span><br><span class="line">args:[-DBBB=789]</span><br><span class="line">env: 123</span><br><span class="line">java version:1.8.0...</span><br><span class="line">system property:null</span><br></pre></td></tr></table></figure>
<h5 id="classpath应用"><a href="#classpath应用" class="headerlink" title="classpath应用"></a>classpath应用</h5><p>假如我们的<code>Main.java</code> 里 用了第三方包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java Main 报错 class not found</span><br><span class="line"></span><br><span class="line">javac -classpath common-lang3-3.9.jar Main.java</span><br><span class="line">java Main </span><br><span class="line">// 报错，意思只在 common-lang3-3.9.jar 的目录里找不在当前目录找</span><br><span class="line"></span><br><span class="line">还可以简写</span><br><span class="line">java -cp common-lang3-3.9.jar Main</span><br><span class="line"></span><br><span class="line"># 正确写法 除了在 common-lang3-3.9.jar 找还在 当前目录找</span><br><span class="line">java -cp common-lang3-3.9.jar:. Main</span><br></pre></td></tr></table></figure>
<h4 id="在看IDEA里运行main的时候启动时的命令行"><a href="#在看IDEA里运行main的时候启动时的命令行" class="headerlink" title="在看IDEA里运行main的时候启动时的命令行"></a>在看IDEA里运行main的时候启动时的命令行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/bin/java &quot;-javaagent:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=51272:/Applications/IntelliJ IDEA.app/Contents/bin&quot; -Dfile.encoding=UTF-8 -classpath /Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/jfxswt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/lib/packager.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_191.jdk/Contents/Home/lib/tools.jar:/Users/huangjiaxi/Desktop/java-fork-process/target/classes com.github.hcsp.shell.Fork</span><br></pre></td></tr></table></figure>
<h3 id="java-中-fork进程"><a href="#java-中-fork进程" class="headerlink" title="java 中 fork进程"></a>java 中 fork进程</h3><ul>
<li><a href="https://github.com/hcsp/java-fork-process" target="_blank" rel="noopener">代码仓库</a></li>
<li><a href="https://github.com/hcsp/java-fork-process/pull/7" target="_blank" rel="noopener">pr</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package com.github.hcsp.shell;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.nio.file.Path;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class Fork &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 请在这里使用Java代码fork一个子进程，将fork的子进程的标准输出重定向到指定文件：工作目录下名为output.txt的文件</span><br><span class="line">        // 工作目录是项目目录下的working-directory目录（可以用getWorkingDir()方法得到这个目录对应的File对象）</span><br><span class="line">        // 传递的命令是sh run.sh</span><br><span class="line">        // 环境变量是AAA=123</span><br><span class="line"></span><br><span class="line">        // 1. 可执行程序 2。 参数</span><br><span class="line">        ProcessBuilder pb = new ProcessBuilder(&quot;sh&quot;,&quot;run.sh&quot;);</span><br><span class="line">        // 3。 工作路径</span><br><span class="line">        pb.directory(getWorkingDir());</span><br><span class="line">        // 4。 设置环境变量</span><br><span class="line">        Map&lt;String,String&gt; envs = pb.environment();</span><br><span class="line">        envs.put(&quot;AAA&quot;,&quot;123&quot;);</span><br><span class="line"></span><br><span class="line">        // 把系统输入输出 继承到当前的进程中来</span><br><span class="line">        // pb.inheritIO();</span><br><span class="line"></span><br><span class="line">        // 将输出内容重定向到文件</span><br><span class="line">        pb.redirectOutput(getOutputFile());</span><br><span class="line"></span><br><span class="line">        pb.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static File getWorkingDir() &#123;</span><br><span class="line">        Path projectDir = Paths.get(System.getProperty(&quot;user.dir&quot;));</span><br><span class="line">        return projectDir.resolve(&quot;working-directory&quot;).toFile();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static File getOutputFile() &#123;</span><br><span class="line">        return new File(getWorkingDir(), &quot;output.txt&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ol>
<li><a href="https://github.com/hcsp/practise-shell-commands" target="_blank" rel="noopener">Linux命令</a><br> <a href="https://github.com/hcsp/practise-shell-commands/pull/7" target="_blank" rel="noopener">我的pr</a></li>
<li><a href="https://github.com/hcsp/practise-java-commands" target="_blank" rel="noopener">java命令</a><br> <a href="https://github.com/hcsp/practise-java-commands/pull/4" target="_blank" rel="noopener">我的pr</a></li>
<li><a href="https://github.com/hcsp/java-fork-process" target="_blank" rel="noopener">使用Java代码fork子进程</a><br> <a href="https://github.com/hcsp/java-fork-process/pull/7" target="_blank" rel="noopener">我的pr</a></li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/oak/">oak</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/07/15/ZB-016-命令行详解01/" title="ZB-016-命令行详解01" itemprop="url">ZB-016-命令行详解01</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Stevin" target="_blank" itemprop="author">Stevin</a>
		
  <p class="article-time">
    <time datetime="2019-07-15T12:08:57.000Z" itemprop="datePublished"> Published 2019-07-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="什么是命令行"><a href="#什么是命令行" class="headerlink" title="什么是命令行"></a>什么是命令行</h3><blockquote>
<p>什么是 Kernel</p>
</blockquote>
<p>负责和计算机硬件交互的，负责CPU调度和进程相关的调度/IO之类的操作。操作系统最底层</p>
<blockquote>
<p>我们如何操作内核呢？</p>
</blockquote>
<p>Linux 通过命令行里(终端)来与内核进行交互</p>
<p>通过命令行操作内核的过程 叫做 Shell</p>
<ul>
<li>Kernel(内核) 与 Shell(壳)</li>
<li>广义的命令行一切通过字符终端控制计算机的方式<ul>
<li>Windows cmd/PowerShell/Git bash</li>
<li>UNIX/Linux系列 sh/zsh/Terminal etc</li>
</ul>
</li>
</ul>
<blockquote>
<p>为什么需要 Shell</p>
</blockquote>
<ul>
<li>因为你不能直接和操作系统内核进行交互</li>
</ul>
<h3 id="为什么需要命令行"><a href="#为什么需要命令行" class="headerlink" title="为什么需要命令行"></a>为什么需要命令行</h3><ul>
<li>因为你不得不用<ul>
<li>几乎所有的服务器都运行在 linux 上 </li>
</ul>
</li>
<li>将工作自动化<ul>
<li>自动化是一切生产力的来源(提高生产力)</li>
<li>你一台机子需要 点点点操作，10000台呢？</li>
</ul>
</li>
<li>相比GUI,命令行更容易开发和维护<ul>
<li>bug少</li>
</ul>
</li>
<li>远程连接命令行占用资源远远低于GUI</li>
<li>命令行上的开发者工具更丰富</li>
</ul>
<h3 id="命令行的历史和流派"><a href="#命令行的历史和流派" class="headerlink" title="命令行的历史和流派"></a>命令行的历史和流派</h3><ul>
<li>UNIX家族<ul>
<li>POSIX标准</li>
<li>macOS </li>
<li>Linux</li>
<li>Windows Subsystem for Linux</li>
</ul>
</li>
<li>Windows<ul>
<li>奇葩</li>
</ul>
</li>
</ul>
<blockquote>
<p>Windows 和 UNIX 系统的区别</p>
</blockquote>
<ul>
<li>UNIX遵循<strong>POSIX标准</strong>，只要遵循POSIX标准就可以以同样的方式工作<ul>
<li>默认命令行交互</li>
<li>GUI只是个扩展</li>
<li>只有一个盘符</li>
</ul>
</li>
<li>Windows<ul>
<li>GUI主要</li>
<li>命令行是扩展的(导致命令行在windows上是个残废)</li>
<li>多个盘符 cdef</li>
</ul>
</li>
</ul>
<blockquote>
<p>如何安装 windows 的 linux 子系统</p>
</blockquote>
<ul>
<li>搜索 Windows Subsystem for Linux </li>
</ul>
<h3 id="命令的全部要素"><a href="#命令的全部要素" class="headerlink" title="命令的全部要素"></a>命令的全部要素</h3><ul>
<li>可执⾏程序（Executable）</li>
<li>参数</li>
<li>环境变量（Environment variable）</li>
<li>⼯作⽬录（Working directory）<ul>
<li>启动命令的路径</li>
<li>相对路径都是相对于这个路径</li>
<li>在Java中的应⽤</li>
</ul>
</li>
</ul>
<p><strong>以上四个要素相同，就可以完全地“重现”⼀个命令</strong></p>
<p><strong>你碰到的各种各样古怪的问题，原因⼀定是上述四个要素之⼀</strong></p>
<blockquote>
<p>可执行程序和参数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -al </span><br><span class="line"># ls就是可执行程序</span><br><span class="line"># -al就是参数</span><br></pre></td></tr></table></figure>
<blockquote>
<p>工作目录</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd 就是当前的目录</span><br></pre></td></tr></table></figure>
<h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><ul>
<li>进程（Process）<ul>
<li>进程是计算机程序运⾏的最⼩单位</li>
<li>独占⾃⼰的内存空间和⽂件资源</li>
</ul>
</li>
<li><p>每个进程都和⼀组变量相绑定</p>
<ul>
<li><p>传递不同的环境变量可以让程序表现出不同的⾏为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 当前终端里</span><br><span class="line">export aa=1</span><br><span class="line"></span><br><span class="line"># 当前终端进入node环境</span><br><span class="line">node</span><br><span class="line"># 获取环境变量</span><br><span class="line">&gt; process.env.aa</span><br><span class="line"># 输出 &apos;1&apos;</span><br><span class="line">&apos;1&apos;</span><br><span class="line"></span><br><span class="line"># 此时新开一个终端</span><br><span class="line">node</span><br><span class="line">&gt; process.env.aa</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure>
</li>
<li><p>CLASSPATH/GOPATH</p>
</li>
</ul>
</li>
<li>在进程的fork过程中，环境变量可以被完全继承(fork 就是生进程的过程)</li>
<li>所有的操作系统/编程语⾔都⽀持环境变量</li>
<li>局部和全局的环境变量</li>
</ul>
<blockquote>
<p>进程是那里来的</p>
</blockquote>
<ul>
<li>进程是它爹生的，最开始系统启动的时候只有一个进程，在 Linux 中叫做 init进程，它生了一堆孩子 桌面/终端 </li>
<li>在终端里输入 node 就导致 终端产生一个孩子 node进程</li>
<li>这就形成了一棵树——进程树</li>
<li>环境变量会一级一级的向下继承</li>
<li>意思是 父进程里有一个环境变量 a=1 那么它的子进程也有这个 a=1</li>
</ul>
<h4 id="环境变量实战"><a href="#环境变量实战" class="headerlink" title="环境变量实战"></a>环境变量实战</h4><ul>
<li>通过export/set设置环境变量，通过echo读取环境变量</li>
<li>从Java/Go/Python/Node.js中读取环境变量</li>
<li><p>向Docker容器传递环境变量</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># -e 代表环境变量</span><br><span class="line">docker run -it -e AAA=1 ubuntu</span><br></pre></td></tr></table></figure>
</li>
<li><p>快速传递⼀个环境变量</p>
</li>
<li>使⽤环境变量控制程序的⾏为</li>
</ul>
<blockquote>
<p>java中读取环境变量</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(System.getenv(&quot;aa&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>局部和全局的环境变量</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 只在当前终端里有效，新开 终端无效</span><br><span class="line">export a = 1</span><br><span class="line"></span><br><span class="line"># 只对当前的命令有效</span><br><span class="line">a=1 node aa.js</span><br><span class="line"></span><br><span class="line"># 全局的环境变量</span><br><span class="line"># 编辑你的 ~/.bash_profile </span><br><span class="line">vi ~/.bash_profile </span><br><span class="line"># 输入如下内容</span><br><span class="line">export aaa = 123456</span><br><span class="line"></span><br><span class="line"># 然后新开终端输入</span><br><span class="line">echo $aaa</span><br><span class="line"></span><br><span class="line"># 你可能遇到，为什么刚改了现在没生效</span><br><span class="line"># 你要 source 一下</span><br><span class="line">source ~/.bash_profile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 注意！！！ bash_profile只对 bash有效 </span><br><span class="line"># 注意！！！ bash_profile只对 bash有效 </span><br><span class="line"># 注意！！！ bash_profile只对 bash有效 </span><br><span class="line"></span><br><span class="line">取决于你用的终端是 bash 还是 zsh</span><br></pre></td></tr></table></figure>
<h3 id="可执⾏程序"><a href="#可执⾏程序" class="headerlink" title="可执⾏程序"></a>可执⾏程序</h3><ul>
<li>Windows：exe/bat/com</li>
<li>UNIX/Linux：x权限 - 可执⾏权限</li>
<li><p>去哪⾥找程序？</p>
<ul>
<li>Windows：Path环境变量 + 当前⽬录</li>
<li>UNIX/Linux：PATH环境变量 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH</span><br><span class="line"></span><br><span class="line">/Users/huangjiaxi/flutter/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Users/huangjiaxi/Desktop/soft/apache-maven-3.6.1/bin</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>在脚本的第⼀⾏指定解释器（shebang）</p>
</li>
<li>别名（alias）</li>
</ul>
<blockquote>
<p>设置环境变量</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># windows</span><br><span class="line">set ABC=123</span><br><span class="line">echo %ABC%</span><br><span class="line"></span><br><span class="line"># linux</span><br><span class="line">export ABC=123</span><br><span class="line">echo $ABC</span><br></pre></td></tr></table></figure>
<blockquote>
<p>初学命令行的困扰</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 执行命令时，windows会在 PATH 和 当前目录里找，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 而 linux 只会在 PATH 里找</span><br><span class="line"># 假设当前目录有 main 脚本</span><br><span class="line"># 直接 main 不会执行 因为 linux 只会在 PATH里找</span><br><span class="line">./main 才执行</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如何执行一个文本文件</p>
</blockquote>
<p><code>echo.sh</code> 内容如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 123</span><br><span class="line">echo 456</span><br></pre></td></tr></table></figure>
<p>分配执行权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 echo.sh</span><br><span class="line"></span><br><span class="line"># 执行你的脚本</span><br><span class="line">./echo.sh</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="写一个-node脚本"><a href="#写一个-node脚本" class="headerlink" title="写一个 node脚本"></a>写一个 node脚本</h4></blockquote>
<p><code>echo.sh</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(123);</span><br><span class="line">console.log(456);</span><br></pre></td></tr></table></figure>
<p>但是操作系统不认识 node！！！</p>
<p><strong>教操作系统认识node</strong></p>
<ul>
<li><a href="https://stackoverflow.com/questions/24253027/node-and-shebang-help-executing-via-command-line" target="_blank" rel="noopener">搜索 node shebang</a></li>
</ul>
<p><code>echo.sh</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env node</span><br><span class="line">console.log(123);</span><br><span class="line">console.log(456);</span><br></pre></td></tr></table></figure>
<p>shell的约定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">shell中 “#” 代表注释</span><br><span class="line"></span><br><span class="line">首行 代表指定当前的文件由谁来解释和执行</span><br><span class="line"># 从当前的上下文环境中查找 node 命令</span><br><span class="line">#!/usr/bin/env node</span><br><span class="line"></span><br><span class="line">为什么不推荐写绝对路径，因为你不知道别人的node是不是安装在这个路径</span><br><span class="line">#!/usr/local/bin/node</span><br></pre></td></tr></table></figure>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul>
<li><p>UNIX参数的约定——然鹅Java并不⻦这个约定</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">‘-’ 约定</span><br><span class="line">ls -alth</span><br><span class="line"># 约定，以一个 ‘-’ 开头的可以 -a -l -t -h 也可以合并为 -alth</span><br><span class="line"># 意思就是 &apos;-&apos; 后面跟一个字符</span><br><span class="line"></span><br><span class="line">&apos;--&apos; 约定 后面跟单词</span><br><span class="line">ls -a &lt;==&gt; ls --all</span><br><span class="line">git push -f &lt;==&gt; git push --force</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">但是 java 不遵守这个</span><br><span class="line">java -version</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数中包含空格或者字符串</p>
<ul>
<li>单引号</li>
<li>双引号</li>
</ul>
</li>
<li>参数的展开</li>
</ul>
<blockquote>
<h4 id="坑人的-单双引号"><a href="#坑人的-单双引号" class="headerlink" title="坑人的 单双引号"></a>坑人的 单双引号</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 当前环境里没有 A 变量，运行正常</span><br><span class="line">javap Main$A.class</span><br><span class="line"></span><br><span class="line"># 此时 </span><br><span class="line">export A=123</span><br><span class="line">javap Main$A.class 报错了</span><br><span class="line">实际执行的是  javap Main123.class</span><br><span class="line"></span><br><span class="line"># 默认情况下 “$” 是把命令展开的符号</span><br><span class="line"></span><br><span class="line"># 通过单引号来包裹它，运行正常，除了可以让多个空格分开的字符串连接在一起，还可以告诉命令行 里面的内容全不要替换</span><br><span class="line">javap &apos;Main$A.class&apos; </span><br><span class="line"></span><br><span class="line"># 换个 &quot;双引号&quot; 试试</span><br><span class="line">javap &quot;Main$A.class&quot;</span><br><span class="line"></span><br><span class="line">双引号会把 里面的变量展开 ==&gt; javap Main$123.class</span><br><span class="line"></span><br><span class="line"># 想给程序传递 单引号怎么办？</span><br><span class="line"># 包双引号</span><br><span class="line">./main &quot;&apos;I am a boy&apos;&quot;</span><br><span class="line"># 转义</span><br><span class="line">./main \&apos;I am a boy\&apos;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="扩展的参数"><a href="#扩展的参数" class="headerlink" title="扩展的参数"></a>扩展的参数</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ls *.java</span><br><span class="line">此时会把所有 .java扩展名的文件罗列出来</span><br><span class="line"></span><br><span class="line"># 如何想不被扩展原样执行呢？</span><br><span class="line"></span><br><span class="line">ls &apos;*.java&apos;</span><br><span class="line"></span><br><span class="line"># * 代表通配符 默认会展开，如果你不想它自动扩展 就包含 单引号</span><br></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/oak/">oak</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/07/10/ZB-014-java接口和抽象类02/" title="ZB-014-java接口和抽象类02" itemprop="url">ZB-014-java接口和抽象类02</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Stevin" target="_blank" itemprop="author">Stevin</a>
		
  <p class="article-time">
    <time datetime="2019-07-10T13:39:39.000Z" itemprop="datePublished"> Published 2019-07-10</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="Comparable-接口"><a href="#Comparable-接口" class="headerlink" title="Comparable 接口"></a>Comparable 接口</h3><ul>
<li>JDK 比较重要的约定——<strong>可比较性</strong>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class User&#123;</span><br><span class="line">    int id;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如何进行比较？</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface Comparable&lt;T&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Compares this object with the specified object for order.  Returns a</span><br><span class="line">     * negative integer, zero, or a positive integer as this object is less</span><br><span class="line">     * than, equal to, or greater than the specified object.</span><br><span class="line">        ...</span><br><span class="line">     */</span><br><span class="line">    public int compareTo(T o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>natural ordering 自然顺序(从小到大)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a &lt; b 返回 -1</span><br><span class="line">a &gt; b 返回 1 </span><br><span class="line">a = b 返回 0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实战</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">package com.github.hcsp.polymorphism;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class Point implements Comparable&lt;Point&gt;&#123;</span><br><span class="line"></span><br><span class="line">    private final int x;</span><br><span class="line">    private final int y;</span><br><span class="line">    // 代表笛卡尔坐标系中的一个点</span><br><span class="line">    public Point(int x, int y) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getX() &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getY() &#123;</span><br><span class="line">        return y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (this == o) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (o == null || getClass() != o.getClass()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Point point = (Point) o;</span><br><span class="line"></span><br><span class="line">        if (x != point.x) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return y == point.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        int result = x;</span><br><span class="line">        result = 31 * result + y;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return String.format(&quot;(%d,%d)&quot;, x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 按照先x再y，从小到大的顺序排序</span><br><span class="line">    // 例如排序后的结果应该是 (-1, 1) (1, -1) (2, -1) (2, 0) (2, 1)</span><br><span class="line">    public static List&lt;Point&gt; sort(List&lt;Point&gt; points) &#123;</span><br><span class="line">        Collections.sort(points);</span><br><span class="line">        return points;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        List&lt;Point&gt; points =</span><br><span class="line">                Arrays.asList(</span><br><span class="line">                        new Point(2, 0),</span><br><span class="line">                        new Point(-1, 1),</span><br><span class="line">                        new Point(1, -1),</span><br><span class="line">                        new Point(2, 1),</span><br><span class="line">                        new Point(2, -1));</span><br><span class="line">        System.out.println(Point.sort(points));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Point that) &#123;</span><br><span class="line">        // 比较 this 和 that</span><br><span class="line">        if(this.x &lt; that.x)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;else if(this.x &gt; that.x)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 运行到此说明 this.x = that.x</span><br><span class="line">        // 因此我要可以进行 y 的排序</span><br><span class="line">        if(this.y &lt; that.y)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;else if(this.y &gt; that.y)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>一个坑的地方千万不要这样比较 <code>return this.x - that.x;</code> <ul>
<li>记得<strong>溢出</strong>吗？ </li>
<li>两个数相减，不一定是你想要的那个数，同理两数相加也是一个道理</li>
</ul>
</li>
<li><code>Comparable</code> 实际也是策略模式，由你来决定策略的各种条件</li>
<li><a href="https://github.com/hcsp/sort-by-multiple-fields" target="_blank" rel="noopener">参考练习</a></li>
<li><a href="https://github.com/hcsp/sort-by-multiple-fields/pull/10" target="_blank" rel="noopener">我的pr</a></li>
</ul>
<blockquote>
<h4 id="另一个坑，注意Comparable在TreeSet中的坑"><a href="#另一个坑，注意Comparable在TreeSet中的坑" class="headerlink" title="另一个坑，注意Comparable在TreeSet中的坑"></a>另一个坑，注意<code>Comparable</code>在<code>TreeSet</code>中的坑</h4></blockquote>
<ul>
<li>Set 它是一个 无重复元素的集合</li>
<li>而你对<code>TreeSet</code> 排序时候也就是实现<code>Comparable</code> 接口的，而调用<code>compareTo</code>时候<ul>
<li>一旦 <code>o1.id = o2.id 导致compareTo 返回 0</code> 这样就会<strong>丢失元素</strong></li>
<li><code>compareTo</code>不要返回0，否则一定踩到坑</li>
</ul>
</li>
<li><a href="https://github.com/hcsp/fix-comparable-bug" target="_blank" rel="noopener">TreeSet排序丢失元素的bug</a></li>
<li><a href="https://github.com/hcsp/fix-comparable-bug/pull/8" target="_blank" rel="noopener">我的pr</a>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public class User implements Comparable&lt;User&gt; &#123;</span><br><span class="line">    /** 用户ID，数据库主键，全局唯一 */</span><br><span class="line">    private final Integer id;</span><br><span class="line"></span><br><span class="line">    /** 用户名 */</span><br><span class="line">    private final String name;</span><br><span class="line"></span><br><span class="line">    public User(Integer id, String name) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (this == o) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (o == null || getClass() != o.getClass()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        User person = (User) o;</span><br><span class="line"></span><br><span class="line">        return Objects.equals(id, person.id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        return id != null ? id.hashCode() : 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** 老板说让我按照用户名排序 */</span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(User o) &#123;</span><br><span class="line">        if(name == o.name)&#123;</span><br><span class="line">            return id.compareTo(o.id);</span><br><span class="line">        &#125;</span><br><span class="line">        return name.compareTo(o.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;User&gt; users =</span><br><span class="line">                Arrays.asList(</span><br><span class="line">                        new User(100, &quot;b&quot;),</span><br><span class="line">                        new User(10, &quot;z&quot;),</span><br><span class="line">                        new User(1, &quot;a&quot;),</span><br><span class="line">                        new User(2000, &quot;a&quot;));</span><br><span class="line">        TreeSet&lt;User&gt; treeSet = new TreeSet&lt;&gt;(users);</span><br><span class="line">        // 为什么这里的输出是3？试着修复其中的bug</span><br><span class="line">        System.out.println(treeSet.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">package com.github.hcsp.polymorphism;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line">public class User &#123;</span><br><span class="line">    /** 用户ID，数据库主键，全局唯一 */</span><br><span class="line">    private final Integer id;</span><br><span class="line"></span><br><span class="line">    /** 用户名 */</span><br><span class="line">    private final String name;</span><br><span class="line"></span><br><span class="line">    public User(Integer id, String name) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 过滤ID为偶数的用户</span><br><span class="line">    public static List&lt;User&gt; filterUsersWithEvenId(List&lt;User&gt; users) &#123;</span><br><span class="line">        List&lt;User&gt; results = new ArrayList&lt;&gt;();</span><br><span class="line">        for (User user : users) &#123;</span><br><span class="line">            if (user.id % 2 == 0) &#123;</span><br><span class="line">                results.add(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return results;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 过滤姓张的用户</span><br><span class="line">    public static List&lt;User&gt; filterZhangUsers(List&lt;User&gt; users) &#123;</span><br><span class="line">        List&lt;User&gt; results = new ArrayList&lt;&gt;();</span><br><span class="line">        for (User user : users) &#123;</span><br><span class="line">            if (user.name.startsWith(&quot;张&quot;)) &#123;</span><br><span class="line">                results.add(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return results;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 过滤姓王的用户</span><br><span class="line">    public static List&lt;User&gt; filterWangUsers(List&lt;User&gt; users) &#123;</span><br><span class="line">        List&lt;User&gt; results = new ArrayList&lt;&gt;();</span><br><span class="line">        for (User user : users) &#123;</span><br><span class="line">            if (user.name.startsWith(&quot;王&quot;)) &#123;</span><br><span class="line">                results.add(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return results;</span><br><span class="line">    &#125;</span><br><span class="line">    // 你可以发现，在上面三个函数中包含大量的重复代码。</span><br><span class="line">    // 请尝试通过Predicate接口将上述代码抽取成一个公用的过滤器函数</span><br><span class="line">    // 并简化上面三个函数</span><br><span class="line">    public static List&lt;User&gt; filter(List&lt;User&gt; users, Predicate&lt;User&gt; predicate) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>用策略模式 和 匿名内部类 </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    /** 用户ID，数据库主键，全局唯一 */</span><br><span class="line">    private final Integer id;</span><br><span class="line"></span><br><span class="line">    /** 用户名 */</span><br><span class="line">    private final String name;</span><br><span class="line"></span><br><span class="line">    public User(Integer id, String name) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 你可以发现，在上面三个函数中包含大量的重复代码。</span><br><span class="line">    // 请尝试通过Predicate接口将上述代码抽取成一个公用的过滤器函数</span><br><span class="line">    // 并简化上面三个函数</span><br><span class="line">    public static List&lt;User&gt; filter(List&lt;User&gt; users, 判断条件是否成立 条件) &#123;</span><br><span class="line">        List&lt;User&gt; results = new ArrayList&lt;&gt;();</span><br><span class="line">        for (User user: users) &#123;</span><br><span class="line">            if(条件.这个用户是否满足条件(user))&#123;</span><br><span class="line">                results.add(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return results;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private interface 判断条件是否成立 &#123;</span><br><span class="line">        boolean 这个用户是否满足条件(User user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class 用户ID是偶数的条件 implements 判断条件是否成立&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean 这个用户是否满足条件(User user) &#123;</span><br><span class="line">            return user.id % 2 == 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;User&gt; res = filterUsersWithEvenId(Arrays.asList(new User(1,&quot;a&quot;),new User(2,&quot;b&quot;)));</span><br><span class="line">        System.out.println(res);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; res2 =  filterZhangUsers(Arrays.asList(new User(1,&quot;张三&quot;),new User(2,&quot;李四&quot;)));</span><br><span class="line">        System.out.println(res2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 过滤ID为偶数的用户(接口实现类的实例)</span><br><span class="line">    public static List&lt;User&gt; filterUsersWithEvenId(List&lt;User&gt; users) &#123;</span><br><span class="line">        List&lt;User&gt; results = new ArrayList&lt;&gt;();</span><br><span class="line">        return filter(users,new 用户ID是偶数的条件());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 过滤姓张的用户(匿名内部类)</span><br><span class="line">    public static List&lt;User&gt; filterZhangUsers(List&lt;User&gt; users) &#123;</span><br><span class="line">        return filter(users, new 判断条件是否成立() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean 这个用户是否满足条件(User user) &#123;</span><br><span class="line">                return user.name.startsWith(&quot;张&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 过滤姓王的用户</span><br><span class="line">    public static List&lt;User&gt; filterWangUsers(List&lt;User&gt; users) &#123;</span><br><span class="line">        List&lt;User&gt; results = new ArrayList&lt;&gt;();</span><br><span class="line">        for (User user : users) &#123;</span><br><span class="line">            if (user.name.startsWith(&quot;王&quot;)) &#123;</span><br><span class="line">                results.add(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong><code>Predicate</code></strong></p>
</blockquote>
<ul>
<li>判定</li>
<li>接口内部只有一个方法，返回值是boolean</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">package com.github.hcsp.polymorphism;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line">public class User &#123;</span><br><span class="line">    /** 用户ID，数据库主键，全局唯一 */</span><br><span class="line">    private final Integer id;</span><br><span class="line"></span><br><span class="line">    /** 用户名 */</span><br><span class="line">    private final String name;</span><br><span class="line"></span><br><span class="line">    public User(Integer id, String name) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 你可以发现，在上面三个函数中包含大量的重复代码。</span><br><span class="line">    // 请尝试通过Predicate接口将上述代码抽取成一个公用的过滤器函数</span><br><span class="line">    // 并简化上面三个函数</span><br><span class="line">    public static List&lt;User&gt; filter(List&lt;User&gt; users, Predicate&lt;User&gt; predicate) &#123;</span><br><span class="line">        List&lt;User&gt; results = new ArrayList&lt;&gt;();</span><br><span class="line">        for (User user: users) &#123;</span><br><span class="line">            if(predicate.test(user))&#123;</span><br><span class="line">                results.add(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return results;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;User&gt; res = filterUsersWithEvenId(Arrays.asList(new User(1,&quot;a&quot;),new User(2,&quot;b&quot;)));</span><br><span class="line">        System.out.println(res);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; res2 =  filterZhangUsers(Arrays.asList(new User(1,&quot;张三&quot;),new User(2,&quot;李四&quot;)));</span><br><span class="line">        System.out.println(res2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 过滤ID为偶数的用户</span><br><span class="line">    public static List&lt;User&gt; filterUsersWithEvenId(List&lt;User&gt; users) &#123;</span><br><span class="line">        List&lt;User&gt; results = new ArrayList&lt;&gt;();</span><br><span class="line">        return filter(users, new Predicate&lt;User&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean test(User user) &#123;</span><br><span class="line">                return user.id % 2 == 0 ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 过滤姓张的用户 lambda 表达式</span><br><span class="line">    public static List&lt;User&gt; filterZhangUsers(List&lt;User&gt; users) &#123;</span><br><span class="line">        return filter(users, user -&gt; user.name.startsWith(&quot;张&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 过滤姓王的用户</span><br><span class="line">    public static List&lt;User&gt; filterWangUsers(List&lt;User&gt; users) &#123;</span><br><span class="line">        return filter(users, user -&gt; user.name.startsWith(&quot;王&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://github.com/hcsp/refactor-filters" target="_blank" rel="noopener">代码仓库</a></li>
<li><a href="https://github.com/hcsp/refactor-filters/pull/9" target="_blank" rel="noopener">pr</a></li>
</ul>
<h3 id="内部类详解"><a href="#内部类详解" class="headerlink" title="内部类详解"></a>内部类详解</h3><h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><ul>
<li>用途：实现更加精细的封装</li>
<li>可以访问外围类的实例方法</li>
<li>非静态内部类<ul>
<li>和一个外围类实例相绑定</li>
<li>可以访问外围类实例的方法</li>
</ul>
</li>
<li>静态内部类<ul>
<li>不和外围类实例绑定</li>
<li>不可以访问外围实例的方法</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Home &#123;</span><br><span class="line">    void log()&#123;</span><br><span class="line">        System.out.println(111);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new B(new Home()).xx();</span><br><span class="line">    &#125;</span><br><span class="line">    static class B&#123;</span><br><span class="line"></span><br><span class="line">        Home home;</span><br><span class="line">        // 通过构造器把外围类的实例注入到内部类来，使得静态内部类可以调用外围类的实例方法</span><br><span class="line">        B(Home home)&#123;</span><br><span class="line">            this.home = home;</span><br><span class="line">        &#125;</span><br><span class="line">        void xx()&#123;</span><br><span class="line">            home.log();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class C&#123;</span><br><span class="line">        //编译器偷偷帮你注入一个 外围类的实例/对象</span><br><span class="line">        // private Home this$0;</span><br><span class="line">        // 这就是为什么非静态的内部类可以访问外部类的秘密所在</span><br><span class="line">        &#123;</span><br><span class="line">            log();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="静态内部类和非静态内部类使用的原则"><a href="#静态内部类和非静态内部类使用的原则" class="headerlink" title="静态内部类和非静态内部类使用的原则"></a>静态内部类和非静态内部类使用的原则</h4></blockquote>
<ul>
<li>永远使用静态内部类，否则编译报错<ul>
<li>因为使用非静态内部类，编译器偷偷帮你注入一个 this$0的外围类实例，这个对象会占用空间的，如果不用，就浪费类空间</li>
</ul>
</li>
</ul>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Home &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 匿名内部类</span><br><span class="line">        new Predicate&lt;Object&gt;()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean test(Object o) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 匿名相当于</span><br><span class="line">class XXXX implements Predicate&lt;Object&gt;&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean test(Object o) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>好处就是非常的短小，逻辑紧密结合</li>
<li>可以访问外围类的成员</li>
<li>还可以变成 lambda 表达式</li>
</ul>
<blockquote>
<p>匿名类最后会变成什么</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Home &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 匿名内部类</span><br><span class="line">        new Predicate&lt;Object&gt;()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean test(Object o) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        new Predicate&lt;Object&gt;()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean test(Object o) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        new Predicate&lt;Object&gt;()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean test(Object o) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 此时三个匿名内部类就会变成</span><br><span class="line"></span><br><span class="line">Home$1.class</span><br><span class="line">Home$2.class</span><br><span class="line">Home$3.class</span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/oak/">oak</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/07/09/ZB-014-java接口和抽象类01/" title="ZB-014-java接口和抽象类" itemprop="url">ZB-014-java接口和抽象类</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Stevin" target="_blank" itemprop="author">Stevin</a>
		
  <p class="article-time">
    <time datetime="2019-07-09T12:54:18.000Z" itemprop="datePublished"> Published 2019-07-09</time>
    
  </p>
</header>
    <div class="article-content">
        
        <ul>
<li><a href="https://sltrust.github.io/2019/05/14/Java-010-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BA%8C/" target="_blank" rel="noopener">参考链接</a></li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul>
<li>不可实例化<ul>
<li>反证法：假如我们允许实例化抽象类的实例，那么该实例调用抽象方法是怎样的？没有方法体？</li>
</ul>
</li>
<li>可以实例化的东西一定要补全所有的方法体</li>
<li>可以包含抽象方法</li>
<li>可以包含成员变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Animal&#123;</span><br><span class="line">    public abstract void 跑();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Bird extends Animal&#123;</span><br><span class="line">    public void 跑()&#123;</span><br><span class="line">        // 跑的实现逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li>接口部分的实现了多继承</li>
<li>接口不是类</li>
<li>接口的扩展</li>
<li>接口只代表一种功能</li>
<li>一个类只能继承一个类，但是却能实现若干的接口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface Aaa &#123;</span><br><span class="line">    // 接口里的成员默认是 public static final </span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">    int a = 1;</span><br><span class="line">    等价于</span><br><span class="line">    public static final  int a = 1;</span><br><span class="line">    而我们知道 final的应该大写</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    // 所以正确的写法应该是</span><br><span class="line">    int A = 1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="接口可以包含什么"><a href="#接口可以包含什么" class="headerlink" title="接口可以包含什么"></a>接口可以包含什么</h4><ul>
<li>若干个方法(默认 public)</li>
<li>若干个常量(默认 public static final)</li>
<li>extends 接口</li>
<li>默认方法<ul>
<li>Since Java8</li>
<li>一种妥协的产物</li>
<li>可以用来实现 minxin</li>
<li>菱形继承</li>
</ul>
</li>
</ul>
<blockquote>
<p>在经典的接口里，java8之前，接口里的方法不能有方法体的 java8之后可以了</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">在 C++ 中 允许多继承</span><br><span class="line">class A&#123;</span><br><span class="line">    f()&#123; ....&#125;</span><br><span class="line">&#125;</span><br><span class="line">class B&#123;</span><br><span class="line">    f()&#123; ....&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C extends A,B&#123;</span><br><span class="line">    // </span><br><span class="line">&#125;</span><br><span class="line">// 菱形继承</span><br><span class="line">new C().f(); // 调用的是谁？此时产生了歧义</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 而 java 是单根继承(不够灵活)，于是提出了 “接口”允许多实现。</span><br><span class="line">// 把接口的功能理解为一种能力</span><br><span class="line">// 那如何区分 类继承体系和接口呢？</span><br><span class="line">// 假设你是个老板Boss 你想找几个人干活，对于class来说就是找几个“人”来干活</span><br><span class="line">// 对于interface来说就是 找几个“能干活”的人来</span><br><span class="line">interface A&#123;</span><br><span class="line">    f();</span><br><span class="line">&#125;</span><br><span class="line">interface B&#123;</span><br><span class="line">    f();</span><br><span class="line">&#125;</span><br><span class="line">class C implements A,B&#123;</span><br><span class="line">    f()&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 而在java8 之后，这种现象被改变了。妥协了</span><br><span class="line">// 当一个接口发布出去 就不能在改了，不能增添或减少成员，因为一旦成型，再次添加方法后，导致所有实现类都报错。必须实现接口的所有方法。</span><br><span class="line"></span><br><span class="line">// 由于这种向后兼容性。所以这种发布之后，再也不修改的情况是个天真的想法——人的认知是有限的</span><br><span class="line">// 所以在 java 工作体系运行20年之后，突然发现某些接口 如 List 想给当年的List添加一个 sort(); 但是很不幸 你不能打破“向后兼容性”， 这样导致 List的实现类全报错了，必须实现 sort方法才行，问题升级，你老板非要实现，但是你要该 N 多地方。</span><br><span class="line"></span><br><span class="line">// 于是产生了一个妥协的产物——默认方法</span><br><span class="line">这个 sort 就在 List 中</span><br><span class="line">// 因为无法变成抽象方法，所以必须写实现，所以 sort 有一个默认的实现使得之前没有实现 sort方法的实现类也能正常工作</span><br><span class="line"></span><br><span class="line">default void sort(Comparator&lt;? super E&gt; c)&#123;</span><br><span class="line">    Object[] a = this.toArray();</span><br><span class="line">    Array.sort(a,(Comparator) c);</span><br><span class="line">    ListIterator&lt;E&gt; i = this.listIterator();</span><br><span class="line">    for(Object e : a)&#123;</span><br><span class="line">        i.next();</span><br><span class="line">        i.set((E) e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4></blockquote>
<ul>
<li><p>java8 之前</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface A&#123;</span><br><span class="line">    void a();</span><br><span class="line">    void b();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>java8 之后</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface A&#123;</span><br><span class="line">    void a();</span><br><span class="line">    void b();</span><br><span class="line">    default void  c()&#123;</span><br><span class="line">        // 实现</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 这样原来实现 A 接口的实现类就可以得到兼容</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<h4 id="java8-接口默认方法引出的问题"><a href="#java8-接口默认方法引出的问题" class="headerlink" title="java8 接口默认方法引出的问题"></a>java8 接口默认方法引出的问题</h4></blockquote>
<ul>
<li>当年极力避免的 <code>C++ 的多继承，导致父类有相同f();的问题出现了</code></li>
<li>当年极力避免的 <strong>“二义性”</strong> 现在又妥协了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">interface A&#123;</span><br><span class="line">    void a();</span><br><span class="line">    default void  c()&#123;</span><br><span class="line">        // 实现</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface B&#123;</span><br><span class="line">    void a();</span><br><span class="line">    default void  c()&#123;</span><br><span class="line">        // 实现</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C implatements A,B&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        c(); // 此时报错了</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="接口和抽象类总结"><a href="#接口和抽象类总结" class="headerlink" title="接口和抽象类总结"></a>接口和抽象类总结</h3><blockquote>
<p>共同点</p>
</blockquote>
<ul>
<li>抽象的，不可实例化</li>
<li>可包含抽象方法(没有方法体，非 static/private/final )</li>
</ul>
<blockquote>
<p>不同点</p>
</blockquote>
<ul>
<li>抽象类是类可以包含类的一切，接口只能包含受限的成员(public static final)和方法(public abstract,java8之后可以 default的)</li>
<li>抽象类只能单一继承，接口可以多实现</li>
</ul>
<blockquote>
<p>instanceof 不仅能检查是不是一个类的实例还可以检测是不是一个接口实现类的实例</p>
</blockquote>
<blockquote>
<p>什么是 API(application program interface)</p>
</blockquote>
<blockquote>
<p>什么是UI(User interface)</p>
</blockquote>
<h4 id="多态实战"><a href="#多态实战" class="headerlink" title="多态实战"></a>多态实战</h4><p>Files.walkFileTree 当你用一个不知道意思的方法的时候，你最好看一下JDK文档 JDK的文档是最好的教材</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Walks a file tree.</span><br><span class="line">    *</span><br><span class="line">    * &lt;p&gt; This method walks a file tree rooted at a given starting file. The</span><br><span class="line">    * file tree traversal is &lt;em&gt;depth-first&lt;/em&gt; with the given &#123;@link</span><br><span class="line">    * FileVisitor&#125; invoked for each file encountered. 看到这就够了</span><br><span class="line"></span><br><span class="line">    public static Path walkFileTree(Path start,</span><br><span class="line">                                    Set&lt;FileVisitOption&gt; options,</span><br><span class="line">                                    int maxDepth,</span><br><span class="line">                                    FileVisitor&lt;? super Path&gt; visitor)</span><br><span class="line">        throws IOException</span><br><span class="line">    &#123; ... &#125;</span><br><span class="line">    - 沿着给定的一个 目录</span><br><span class="line">    - 深度优先 </span><br><span class="line"></span><br><span class="line">    FileVisitor 是什么？就是一个接口，如果你实现它，就可以在访问文件的过程中进行自定义控制</span><br></pre></td></tr></table></figure>
<blockquote>
<p>FileVisitor接口</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public interface FileVisitor&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // 文件夹访问之前</span><br><span class="line">    FileVisitResult preVisitDirectory(T dir, BasicFileAttributes attrs)</span><br><span class="line">        throws IOException;</span><br><span class="line"></span><br><span class="line">    // 访问文件夹做什么</span><br><span class="line">    FileVisitResult visitFile(T file, BasicFileAttributes attrs)</span><br><span class="line">        throws IOException;</span><br><span class="line"></span><br><span class="line">    // 访问失败做什么</span><br><span class="line">    FileVisitResult visitFileFailed(T file, IOException exc)</span><br><span class="line">        throws IOException;</span><br><span class="line"></span><br><span class="line">    // 访问文件夹之后</span><br><span class="line">    FileVisitResult postVisitDirectory(T dir, IOException exc)</span><br><span class="line">        throws IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>FileVisitResult 访问文件的4个结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public enum FileVisitResult &#123;</span><br><span class="line">    CONTINUE,</span><br><span class="line">    TERMINATE,// 终止</span><br><span class="line">    SKIP_SUBTREE, // 忽略子树</span><br><span class="line">    SKIP_SIBLINGS; // 忽略所有兄弟</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="MyFileVisitor"><a href="#MyFileVisitor" class="headerlink" title="MyFileVisitor"></a>MyFileVisitor</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">package com.github.hcsp.polymorphism;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.file.*;</span><br><span class="line">import java.nio.file.attribute.BasicFileAttributes;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class FileFilter &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Path projectDir = Paths.get(System.getProperty(&quot;user.dir&quot;));</span><br><span class="line">        Path testRootDir = projectDir.resolve(&quot;test-root&quot;);</span><br><span class="line">        if (!testRootDir.toFile().isDirectory()) &#123;</span><br><span class="line">            throw new IllegalStateException(testRootDir.toAbsolutePath().toString() + &quot;不存在！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; filteredFileNames = filter(testRootDir, &quot;.csv&quot;);</span><br><span class="line">        System.out.println(filteredFileNames);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 实现一个按照扩展名过滤文件的功能</span><br><span class="line">     *</span><br><span class="line">     * @param rootDirectory 要过滤的文件夹</span><br><span class="line">     * @param extension 要过滤的文件扩展名，例如 .txt</span><br><span class="line">     * @return 所有该文件夹（及其后代子文件夹中）匹配指定扩展名的文件的名字</span><br><span class="line">     */</span><br><span class="line">    public static List&lt;String&gt; filter(Path rootDirectory, String extension) throws IOException &#123;</span><br><span class="line">        Files.walkFileTree(rootDirectory,new MyFileVisitor());</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 分割线，另一个 java文件里</span><br><span class="line">// MyFileVisitor.java</span><br><span class="line">public class MyFileVisitor implements FileVisitor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public FileVisitResult preVisitDirectory(Object dir, BasicFileAttributes attrs) throws IOException &#123;</span><br><span class="line">        System.out.println(dir);</span><br><span class="line">        return FileVisitResult.CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public FileVisitResult visitFile(Object file, BasicFileAttributes attrs) throws IOException &#123;</span><br><span class="line">        System.out.println(file);</span><br><span class="line">        return FileVisitResult.CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public FileVisitResult visitFileFailed(Object file, IOException exc) throws IOException &#123;</span><br><span class="line">        System.out.println(file);</span><br><span class="line">        return FileVisitResult.CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public FileVisitResult postVisitDirectory(Object dir, IOException exc) throws IOException &#123;</span><br><span class="line">        return FileVisitResult.CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>除此之外，我们可以找到 FileVisitor 的实现类(骨架类)，因为我们不需要实现所有的接口</p>
</blockquote>
<ul>
<li>找到了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class FileFilterVisitor extends SimpleFileVisitor&lt;Path&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123;</span><br><span class="line">        System.out.println(file);</span><br><span class="line">        return FileVisitResult.CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需求添加，我们需要知道过滤文件的扩展名，和返回过滤后的集合</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package com.github.hcsp.polymorphism;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.file.*;</span><br><span class="line">import java.nio.file.attribute.BasicFileAttributes;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class FileFilter &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Path projectDir = Paths.get(System.getProperty(&quot;user.dir&quot;));</span><br><span class="line">        Path testRootDir = projectDir.resolve(&quot;test-root&quot;);</span><br><span class="line">        if (!testRootDir.toFile().isDirectory()) &#123;</span><br><span class="line">            throw new IllegalStateException(testRootDir.toAbsolutePath().toString() + &quot;不存在！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; filteredFileNames = filter(testRootDir, &quot;.csv&quot;);</span><br><span class="line">        System.out.println(filteredFileNames);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static List&lt;String&gt; filter(Path rootDirectory, String extension) throws IOException &#123;</span><br><span class="line">        FileFilterVisitor visitor = new FileFilterVisitor(extension);</span><br><span class="line">        Files.walkFileTree(rootDirectory,visitor);</span><br><span class="line">        return visitor.getFilterNames();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 分割线，另一个 java文件里</span><br><span class="line">// FileFilterVisitor.java</span><br><span class="line">// 使用骨架实现</span><br><span class="line">public class FileFilterVisitor extends SimpleFileVisitor&lt;Path&gt;&#123;</span><br><span class="line">    private String extension;</span><br><span class="line">    private List&lt;String&gt; filterNames = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public FileFilterVisitor(String extension) &#123;</span><br><span class="line">        this.extension = extension;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; getFilterNames() &#123;</span><br><span class="line">        return filterNames;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123;</span><br><span class="line">        System.out.println(file);</span><br><span class="line">        if(file.getFileName().toString().endsWith(extension))&#123;</span><br><span class="line">            filterNames.add(file.getFileName().toString());</span><br><span class="line">        &#125;</span><br><span class="line">        return FileVisitResult.CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="再次升级需求：问题如下"><a href="#再次升级需求：问题如下" class="headerlink" title="再次升级需求：问题如下"></a>再次升级需求：问题如下</h4></blockquote>
<ul>
<li>你的 <code>FileFilterVisitor</code> 不再一个类里，而且还需要定制构造器 传递<code>extension</code>参数</li>
</ul>
<p>于是你把 <code>FileFilterVisitor.java</code> 移到 <code>FileFilter.java</code> 里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package com.github.hcsp.polymorphism;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.file.*;</span><br><span class="line">import java.nio.file.attribute.BasicFileAttributes;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class FileFilter &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Path projectDir = Paths.get(System.getProperty(&quot;user.dir&quot;));</span><br><span class="line">        Path testRootDir = projectDir.resolve(&quot;test-root&quot;);</span><br><span class="line">        if (!testRootDir.toFile().isDirectory()) &#123;</span><br><span class="line">            throw new IllegalStateException(testRootDir.toAbsolutePath().toString() + &quot;不存在！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; filteredFileNames = filter(testRootDir, &quot;.csv&quot;);</span><br><span class="line">        System.out.println(filteredFileNames);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static List&lt;String&gt; filter(Path rootDirectory, String extension) throws IOException &#123;</span><br><span class="line">        FileFilterVisitor visitor = new FileFilterVisitor(extension);</span><br><span class="line">        Files.walkFileTree(rootDirectory,visitor);</span><br><span class="line">        return visitor.getFilterNames();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class FileFilterVisitor extends SimpleFileVisitor&lt;Path&gt;&#123;</span><br><span class="line">    private String extension;</span><br><span class="line">    private List&lt;String&gt; filterNames = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public FileFilterVisitor(String extension) &#123;</span><br><span class="line">        this.extension = extension;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; getFilterNames() &#123;</span><br><span class="line">        return filterNames;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123;</span><br><span class="line">        System.out.println(file);</span><br><span class="line">        if(file.getFileName().toString().endsWith(extension))&#123;</span><br><span class="line">            filterNames.add(file.getFileName().toString());</span><br><span class="line">        &#125;</span><br><span class="line">        return FileVisitResult.CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>即使移到了一个java文件里，但是你还是觉得麻烦</strong></p>
<h4 id="内部类-一个类包含在另一类中"><a href="#内部类-一个类包含在另一类中" class="headerlink" title="内部类(一个类包含在另一类中)"></a>内部类(一个类包含在另一类中)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class FileFilter &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Path projectDir = Paths.get(System.getProperty(&quot;user.dir&quot;));</span><br><span class="line">        Path testRootDir = projectDir.resolve(&quot;test-root&quot;);</span><br><span class="line">        if (!testRootDir.toFile().isDirectory()) &#123;</span><br><span class="line">            throw new IllegalStateException(testRootDir.toAbsolutePath().toString() + &quot;不存在！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; filteredFileNames = filter(testRootDir, &quot;.csv&quot;);</span><br><span class="line">        System.out.println(filteredFileNames);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static List&lt;String&gt; filter(Path rootDirectory, String extension) throws IOException &#123;</span><br><span class="line">        FileFilterVisitor visitor = new FileFilterVisitor(extension);</span><br><span class="line">        Files.walkFileTree(rootDirectory,visitor);</span><br><span class="line">        return visitor.getFilterNames();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 内部类</span><br><span class="line">    public static class FileFilterVisitor extends SimpleFileVisitor&lt;Path&gt;&#123;</span><br><span class="line">        private String extension;</span><br><span class="line">        private List&lt;String&gt; filterNames = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        public FileFilterVisitor(String extension) &#123;</span><br><span class="line">            this.extension = extension;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public List&lt;String&gt; getFilterNames() &#123;</span><br><span class="line">            return filterNames;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">            if(file.getFileName().toString().endsWith(extension))&#123;</span><br><span class="line">                filterNames.add(file.getFileName().toString());</span><br><span class="line">            &#125;</span><br><span class="line">            return FileVisitResult.CONTINUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>还是觉得麻烦，因为要传递<code>extension</code></strong></p>
<blockquote>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class FileFilter &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Path projectDir = Paths.get(System.getProperty(&quot;user.dir&quot;));</span><br><span class="line">        Path testRootDir = projectDir.resolve(&quot;test-root&quot;);</span><br><span class="line">        if (!testRootDir.toFile().isDirectory()) &#123;</span><br><span class="line">            throw new IllegalStateException(testRootDir.toAbsolutePath().toString() + &quot;不存在！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; filteredFileNames = filter(testRootDir, &quot;.csv&quot;);</span><br><span class="line">        System.out.println(filteredFileNames);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 匿名内部类</span><br><span class="line">    public static List&lt;String&gt; filter(Path rootDirectory, String extension) throws IOException &#123;</span><br><span class="line">        List&lt;String&gt; names = new ArrayList&lt;&gt;();</span><br><span class="line">        Files.walkFileTree(rootDirectory,new SimpleFileVisitor&lt;Path&gt;()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123;</span><br><span class="line">                System.out.println(file);</span><br><span class="line">                if(file.getFileName().toString().endsWith(extension))&#123;</span><br><span class="line">                    names.add(file.getFileName().toString());</span><br><span class="line">                &#125;</span><br><span class="line">                return FileVisitResult.CONTINUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return names;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是<strong>多态</strong>的应用</p>
<ul>
<li>通过修改一小块的功能去完成一个更加灵活性的功能</li>
<li><p>通过去覆盖(重写)一个方法来实现更加灵活的功能</p>
</li>
<li><p><a href="https://github.com/hcsp/refactor-filters" target="_blank" rel="noopener">代码参考</a></p>
</li>
<li><a href="https://github.com/hcsp/file-filter/pull/10" target="_blank" rel="noopener">我的pr</a></li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/oak/">oak</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/07/05/ZB-013-java多态/" title="ZB-013-java多态" itemprop="url">ZB-013-java多态</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Stevin" target="_blank" itemprop="author">Stevin</a>
		
  <p class="article-time">
    <time datetime="2019-07-05T13:28:53.000Z" itemprop="datePublished"> Published 2019-07-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="什么是多态"><a href="#什么是多态" class="headerlink" title="什么是多态"></a>什么是多态</h3><ul>
<li>实例方法默认是多态的<ul>
<li>在运行时根据this来决定调用那个方法</li>
<li>静态方法没有多态</li>
<li>参数静态绑定，接受者动态绑定<ol>
<li>多态只对方法的接受者生效</li>
<li>多态只选择接受者的类型，不选择参数的类型</li>
</ol>
</li>
</ul>
</li>
<li>例子<ol>
<li>shape</li>
<li>HashSet.addAll() <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 HashSet自己没有 addAll ，从父类继承来的，</span><br><span class="line">2 调用addAll 会调用 add 方法</span><br><span class="line">3 而 HashSet 和 父类 都有 add 方法，那么会调用谁的呢？</span><br><span class="line">4 默念口诀： 实例方法默认是多态的，多态的意思是根据当前的类型来决定调用那个方法</span><br><span class="line">5 虽然 addAll 在父类中 但当前对象是 HashSet 的实例。所有会调用 HashSet 的 add</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<blockquote>
<h4 id="相关例子"><a href="#相关例子" class="headerlink" title="相关例子"></a>相关例子</h4></blockquote>
<ul>
<li><a href="https://github.com/hcsp/shape-polymorphism" target="_blank" rel="noopener">https://github.com/hcsp/shape-polymorphism</a></li>
<li><a href="https://github.com/hcsp/polymorphism-overload-method-selection" target="_blank" rel="noopener">https://github.com/hcsp/polymorphism-overload-method-selection</a></li>
<li><a href="https://github.com/hcsp/discount-strategy-pattern" target="_blank" rel="noopener">策略模式，打折策略</a>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public static int calculatePrice(String discountStrategy, int price, User user) &#123;</span><br><span class="line">    switch (discountStrategy) &#123;</span><br><span class="line">        case &quot;NoDiscount&quot;:</span><br><span class="line">            return price;</span><br><span class="line">        case &quot;Discount95&quot;:</span><br><span class="line">            return (int) (price * 0.95);</span><br><span class="line">        case &quot;OnlyVip&quot;:</span><br><span class="line">            &#123;</span><br><span class="line">                if (user.isVip()) &#123;</span><br><span class="line">                    return (int) (price * 0.95);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return price;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        default:</span><br><span class="line">            throw new IllegalStateException(&quot;Should not be here!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这样的缺点是 后来又多了 N种策略怎么办，别人都不敢轻易改代码了</span><br><span class="line">把每个策略抽象成一种类型单独维护</span><br><span class="line">public static int calculatePrice(DiscountStrategy strategy, int price, User user) &#123;</span><br><span class="line">    return strategy.discount(price, user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// DiscountStrategy 是父类</span><br><span class="line">public class DiscountStrategy &#123;</span><br><span class="line">    public int discount(int price, User user) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 使用 多态实现不同策略  </span><br><span class="line">public class Discount95Strategy extends DiscountStrategy&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int discount(int price, User user) &#123;</span><br><span class="line">        return (int)(price*0.95);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class NoDiscountStrategy extends DiscountStrategy&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int discount(int price, User user) &#123;</span><br><span class="line">        return price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class OnlyVipDiscountStrategy extends DiscountStrategy&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int discount(int price, User user) &#123;</span><br><span class="line">        if(user.isVip())&#123;</span><br><span class="line">            return (int)(price*0.95);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return price;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 这样每次增加策略就新建一个类就行了。</span><br><span class="line"></span><br><span class="line">// 这是个优点，也是个缺点。是因为 如果10000个策略就10000个类</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<h4 id="涉及金额绝对不能用double"><a href="#涉及金额绝对不能用double" class="headerlink" title="涉及金额绝对不能用double"></a>涉及金额绝对不能用double</h4></blockquote>
<ol>
<li>所有金额乘以 100 (1元= 100分)</li>
<li><code>BigDecimal</code>类型 任意精度10进制数</li>
</ol>
<blockquote>
<h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TheadPoolExecutor(</span><br><span class="line">    int corePoolSize,</span><br><span class="line">    int maxiumPoolSize,</span><br><span class="line">    long keepAliveTime,</span><br><span class="line">    TimeUnit unit,</span><br><span class="line">    BlockKingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">    ThreadFactory threadFactory,</span><br><span class="line">    RejectedExecutionHandler handler)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 最后一个参数的意思       </span><br><span class="line">RejectedExecutionHandler 就是策略模式在线程池中的应用</span><br></pre></td></tr></table></figure>
<h4 id="做菜实例"><a href="#做菜实例" class="headerlink" title="做菜实例"></a>做菜实例</h4><ul>
<li><a href="https://github.com/hcsp/refactor-to-abstract-class" target="_blank" rel="noopener">https://github.com/hcsp/refactor-to-abstract-class</a></li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/oak/">oak</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/07/04/ZB-012-java组合和继承/" title="ZB-012-java组合和继承" itemprop="url">ZB-012-java组合和继承</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Stevin" target="_blank" itemprop="author">Stevin</a>
		
  <p class="article-time">
    <time datetime="2019-07-04T14:44:46.000Z" itemprop="datePublished"> Published 2019-07-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="什么是继承"><a href="#什么是继承" class="headerlink" title="什么是继承"></a>什么是继承</h3><ul>
<li>程序员的宿命：复制 &amp; 粘贴<ul>
<li>真的只能这样吗？</li>
<li>DRY(Donot Repeat Youself)</li>
<li>事不过三，三则重构</li>
</ul>
</li>
<li>继承的本质是提炼代码，避免重复</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Cat &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void walk()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Dog &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void walk()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Pig &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void walk()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 它们又很多共性和重复</span><br><span class="line">// 一旦walk改变了，要改三个地方</span><br></pre></td></tr></table></figure>
<blockquote>
<p>继承,避免重复</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Animal&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public void walk()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Cat extends Amimal&#123;...&#125;</span><br><span class="line">public class Dog extends Amimal&#123;...&#125;</span><br><span class="line">public class Pig extends Amimal&#123;...&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Java的继承体系"><a href="#Java的继承体系" class="headerlink" title="Java的继承体系"></a>Java的继承体系</h3><ul>
<li>单继承</li>
<li><p>Object 是所有类的基类，所有对象都继承了Object，所以所有对象都有 Object 的非私有成员属性/方法</p>
<ul>
<li><p>equals</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Object 的 equals 默认实现是 </span><br><span class="line">public boolean equals(Object obj)&#123;</span><br><span class="line">    return this == obj; // 比较的是 addr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">针对其他类如 Order  根据 id就可以确定是不是同一订单</span><br><span class="line">public class Order &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (this == o) return true;</span><br><span class="line">        if (o == null || getClass() != o.getClass()) return false;</span><br><span class="line">        Cat cat = (Cat) o;</span><br><span class="line">        return id == cat.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        return Objects.hash(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>toString</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object 的 toString 默认实现是 </span><br><span class="line">public boolean toString()&#123;</span><br><span class="line">    return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode()) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">任何时候打印对象的时候 都会提供字符串表示</span><br><span class="line">System.out.println(xxx); // 隐式调用</span><br><span class="line">xxx.toString();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>单根继承的好处是：</p>
</blockquote>
<ul>
<li>所有对象都有某一行为，因为都继承了 Object</li>
<li>方便处理</li>
</ul>
<blockquote>
<p>如 python支持多继承。会带来很多问题——菱形继承</p>
</blockquote>
<ul>
<li>父类都有 xxx()函数的处理！！！不知道该调用谁，但是python解决了！不再详细解释</li>
</ul>
<h3 id="类的结构和初始化顺序"><a href="#类的结构和初始化顺序" class="headerlink" title="类的结构和初始化顺序"></a>类的结构和初始化顺序</h3><ul>
<li>子类拥有父类一切的数据和行为</li>
<li>父类先于子类</li>
<li>必须拥有匹配的构造器<ul>
<li>super</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Animal &#123;</span><br><span class="line">    String name;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;初始化父类块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public Animal(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Cat extends Animal&#123;</span><br><span class="line">    int age;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;初始化子类块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public Cat(String name,int age) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>过程就是自顶向下依次初始化</li>
</ul>
<h3 id="实例方法的覆盖"><a href="#实例方法的覆盖" class="headerlink" title="实例方法的覆盖"></a>实例方法的覆盖</h3><ul>
<li>又称为重写/覆盖</li>
<li>永远使用<code>@Override</code>注解来防止手残<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Animal &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    public Animal(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sayHello()&#123;</span><br><span class="line">        System.out.println(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ----------------------------------</span><br><span class="line">public class Cat extends Animal&#123;</span><br><span class="line">    int age;</span><br><span class="line"></span><br><span class="line">    public Cat(String name,int age) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello()&#123;</span><br><span class="line">        System.out.println(&quot;cat hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h3><ul>
<li>spring的初始化代码就是模版方法，定义了一些预定义好的方法。自定义的实现可以覆盖模版的方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 模版方法</span><br><span class="line">public class BookWriter &#123;</span><br><span class="line">    // 写书</span><br><span class="line">    public void wtiteBook()&#123;</span><br><span class="line">        writeTitle();</span><br><span class="line">        writeContent();</span><br><span class="line">        writeEnding();</span><br><span class="line">    &#125;</span><br><span class="line">    public void writeTitle()&#123;</span><br><span class="line">        System.out.println(&quot;标题&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void writeContent()&#123;</span><br><span class="line">        System.out.println(&quot;内容&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void writeEnding()&#123;</span><br><span class="line">        System.out.println(&quot;结尾&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 子类继承父类的模版方法</span><br><span class="line">public class MyBookWriter extends BookWriter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void writeContent()&#123;</span><br><span class="line">        System.out.println(&quot;我的内容&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new MyBookWriter().wtiteBook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="向上和向下转型"><a href="#向上和向下转型" class="headerlink" title="向上和向下转型"></a>向上和向下转型</h3><ul>
<li><p>一个子类对象一定是父类类型的对象</p>
<ul>
<li>正如一只猫同时也是一个动物，同时也是一个对象</li>
<li><p>instanceof 判断一个对象是不是一个类的实例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object a = new Integer(1234);</span><br><span class="line">System.out.println(a instanceof Integer); // true</span><br><span class="line">System.out.println(a instanceof Number); // true</span><br><span class="line">System.out.println(a instanceof Object); // true</span><br><span class="line">System.out.println(null instanceof Integer); // false</span><br></pre></td></tr></table></figure>
</li>
<li><p>null installceof ? 都是 false</p>
</li>
</ul>
</li>
<li><p>当需要一个父类型时，可以传递一个子类型</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    setList(new ArrayList&lt;Integer&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void setList(AbstractList&lt;Integer&gt; list)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// &lt;Integer&gt; 是泛型， ArrayList 是 AbstractList 的子类</span><br><span class="line"></span><br><span class="line">// 还可以这样</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    setList(new ArrayList&lt;Integer&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void setList(AbstractList&lt;? super Number&gt; list)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>但是，有的时候你必须进行一些转型</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">    Animal a = new Animal();</span><br><span class="line">    setAnimalName((Dog)animal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void setAnimalName(Dog dog)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.ClassCastException: Animal cannot be cast to Dog</span><br></pre></td></tr></table></figure>
<ul>
<li>转型是不安全的</li>
<li>失败了怎么办？</li>
</ul>
</li>
</ul>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><ul>
<li><p>final声明变量是不可变的(必须初始化)</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final int a = 1; // 正确</span><br><span class="line">final int a ; // 错误 没有初始化</span><br></pre></td></tr></table></figure>
<ul>
<li><p>局部变量/方法参数</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void f(final Date date)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// date的地址不能改变， 地址指向的东西可以改变</span><br></pre></td></tr></table></figure>
</li>
<li><p>成员变量</p>
</li>
<li><p>常量和单例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 命名规则是全部大写 ，然后以下划线区分 如 MAX_VALUE</span><br><span class="line">public static final double PI = 3.1415926;</span><br><span class="line"></span><br><span class="line">// 单例模式</span><br><span class="line">public class World&#123;</span><br><span class="line">    private static final World SINGLETON_INSTANCE = new World();</span><br><span class="line">    private World()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static World getInstance()&#123;</span><br><span class="line">        return SINGLETON_INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>final在方法上的声明： 禁止继承/覆盖/重写此方法</p>
</li>
<li>final在类声明上的声明： 禁止继承此类<ul>
<li>继承提供了灵活性，也埋下了隐患</li>
<li>为什么String/Integer 等是 final的呢？<ol>
<li>假设 <code>MyInteger extends Integer</code> 此时重写 <code>compare</code> 本来 <code>1&lt;2</code> 而你偏偏 <code>改写成 1&gt;2</code> 这样就破坏所有使用<code>Integer</code>方法 的约定</li>
<li>JDK通过把 <code>String/Integer 定义为 final</code> 来阻止恶意的客户端继承常见类，破坏程序的约定</li>
</ol>
</li>
</ul>
</li>
</ul>
<blockquote>
<h4 id="final在-类-方法上有什么优点"><a href="#final在-类-方法上有什么优点" class="headerlink" title="final在 类/方法上有什么优点"></a>final在 类/方法上有什么优点</h4></blockquote>
<ol>
<li>使用 final 可以保证类无法被继承，方法无法被重写，别人无法通过继承来破坏约定，你可以大胆的做一些事情，软件设计的一个约定——放心大胆的做一些事，我可以保证这个约定不会被打破</li>
<li>这个方法是 final 时方法是被确定的无法多态</li>
</ol>
<h3 id="组合和继承"><a href="#组合和继承" class="headerlink" title="组合和继承"></a>组合和继承</h3><ul>
<li>继承：is-a</li>
<li>组合：has-a</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/oak/">oak</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/07/04/ZB-011-java封装和访问控制/" title="ZB-011-java封装和访问控制" itemprop="url">ZB-011-java封装和访问控制</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Stevin" target="_blank" itemprop="author">Stevin</a>
		
  <p class="article-time">
    <time datetime="2019-07-04T11:59:51.000Z" itemprop="datePublished"> Published 2019-07-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="什么是封装"><a href="#什么是封装" class="headerlink" title="什么是封装"></a>什么是封装</h3><ul>
<li>隐藏内部细节，只暴露出接口</li>
<li>电灯<ul>
<li>你只关心它的“开关”接口，不关心内部的“电路”细节</li>
</ul>
</li>
<li>汽车<ul>
<li>你只关心“方向盘”，不关心内部的细节</li>
</ul>
</li>
</ul>
<p>Light.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Light&#123;</span><br><span class="line"></span><br><span class="line">    public void trunOn()&#123;</span><br><span class="line">        打开电路1();</span><br><span class="line">        打开电路2();</span><br><span class="line">        打开电路3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void 打开电路1()&#123;&#125;</span><br><span class="line">    public void 打开电路2()&#123;&#125;</span><br><span class="line">    public void 打开电路3()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Home.java</p>
</blockquote>
<p>打开灯有两种方式</p>
<ul>
<li>直接调用 <code>trunOn()</code> (低耦合)</li>
<li>调用实现细节 <code>打开电路1();打开电路2();打开电路3()</code>(高耦合)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class public Home&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Light a = new Light();</span><br><span class="line">        a.trunOn();</span><br><span class="line"></span><br><span class="line">        Light b = new Light();</span><br><span class="line">        b.打开电路1();</span><br><span class="line">        b.打开电路2();</span><br><span class="line">        b.打开电路3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如果有一天，一个高级工程师对打开灯的方式进行了优化</strong></p>
<p>此时只要<code>打开电路1();打开电路2();</code> 就可以开灯了</p>
<p>此时 以第二种方式调用开灯的人就要修改 因为它耦合了开灯的细节</p>
<p><strong>一方改变另一方也要改变</strong></p>
<p>而第一种方式只需要更改 <code>turnOn()</code> 自己一个方法就做到了正常工作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void trunOn()&#123;</span><br><span class="line">    打开电路1();</span><br><span class="line">    打开电路2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h4></blockquote>
<p>Person类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Person&#123;</span><br><span class="line">    int id;</span><br><span class="line">    int age;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设10个人都用了你的 <code>Person</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person p = new Person();</span><br><span class="line">p.age = 10;</span><br><span class="line">p.name = &quot;张三&quot;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>老板突然提了个需求，<strong>如果年龄小与0则为0，大于100则为100</strong></p>
</blockquote>
<ul>
<li>这样别人都是通过 <code>p.age = 10</code>设置一个值。这样要改 10个地方。</li>
</ul>
<blockquote>
<p>优化</p>
</blockquote>
<ul>
<li>把成员变量变为私有</li>
<li>设置对应的 get/set 接口</li>
<li>外界只能通过 get/set接口对成员进行操作  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person p = new Person();</span><br><span class="line">p.setAge(10);</span><br><span class="line">p.setName(&quot;张三&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">    // 如果年龄小与0则为0，大于100则为100</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        if(age&lt;0)&#123;</span><br><span class="line">            this.age = 0;</span><br><span class="line">        &#125;else if(age&gt;100)&#123;</span><br><span class="line">            this.age = 100;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            this.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有没有发现改一下接口 <code>setAge()</code> 就轻松的完成了需求</p>
<blockquote>
<p>场景三，你开发的Person 被广泛应用到别人的电脑</p>
</blockquote>
<p>此时你老板认为世界上只有男和女，于是你的<code>gender</code> 采用了 <code>boolean</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private boolean gender;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean isMale() &#123;</span><br><span class="line">        return gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setGender(boolean gender) &#123;</span><br><span class="line">        this.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过了1年后，你老板发现还真有其他性别。你就不得不改变<code>gender 为 String</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package hello.service;</span><br><span class="line"></span><br><span class="line">import java.util.Objects;</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private String gender;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean isMale() &#123;</span><br><span class="line">        // return gender == &quot;M&quot;; 可能会空指针</span><br><span class="line">        // return &quot;M&quot;.equals(gender);  非空对象前置</span><br><span class="line">        return Objects.equals(gender,&quot;M&quot;); </span><br><span class="line">    &#125;</span><br><span class="line">    // 废弃的注解</span><br><span class="line">    @Deprecated</span><br><span class="line">    public void setGender(boolean gender) &#123;</span><br><span class="line">        this.gender = gender ? &quot;M&quot; : &quot;F&quot; ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时使用者无需任何改变，依然能正常使用</p>
<h3 id="封装的实现"><a href="#封装的实现" class="headerlink" title="封装的实现"></a>封装的实现</h3><blockquote>
<p>包的功能就是提供<strong>访问控制，一种边界，封装的边界</strong></p>
</blockquote>
<ul>
<li>public 任何人都能访问</li>
<li>protected 只有子类和同包的可以访问</li>
<li>package private(包级私有)包权限 同包可访问</li>
<li>private 只有自己能访问</li>
</ul>
<p><strong>包是没有嵌套包含关系的！！！跟文件夹父子目录不一样</strong></p>
<h4 id="JavaBean约定"><a href="#JavaBean约定" class="headerlink" title="JavaBean约定"></a>JavaBean约定</h4><ul>
<li>getter</li>
<li>setter</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private boolean cute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>此时 <code>Person 的 name / cute</code> 无法被外界访问因为是 <code>private</code></strong></p>
<p>设置getter/setter</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private boolean cute;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isCute() &#123;</span><br><span class="line">        return cute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCute(boolean cute) &#123;</span><br><span class="line">        this.cute = cute;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么 <code>getter/setter</code>长这个样子,不是无缘无故，而是<strong>JavaBean约定</strong></p>
</blockquote>
<ul>
<li>我们知道 <code>java</code> 代表咖啡，而程序员很浪漫</li>
<li>在<code>java</code>中创建对象了叫什么呢？ 对象？太土了，程序员的浪漫促使它起了名字叫做 <strong>“Bean”</strong> 就是”豆”</li>
<li>JavaBean 就是咖啡豆</li>
</ul>
<p>对于一个 JavaBean 来说 加入他有一个 <code>getX() 和 setX()</code> 方法，我们就认为它有一个 <code>x</code> 属性</p>
<h5 id="规则如下"><a href="#规则如下" class="headerlink" title="规则如下"></a>规则如下</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 非 boolean 值</span><br><span class="line">String name;</span><br><span class="line">setName/getName</span><br><span class="line"></span><br><span class="line">// boolean 值</span><br><span class="line">boolean gender</span><br><span class="line">setGender/isGender</span><br></pre></td></tr></table></figure>
<h5 id="这些约定有什么用呢？"><a href="#这些约定有什么用呢？" class="headerlink" title="这些约定有什么用呢？"></a>这些约定有什么用呢？</h5><ul>
<li>最重要之一就是 <code>JSON</code> 对象和字符串相互转换</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 如 js</span><br><span class="line">var obj = &#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:&quot;李四&quot;&#125;;</span><br><span class="line">// 序列化</span><br><span class="line">JSON.stringify(obj);</span><br><span class="line">// 反序列化</span><br><span class="line">var obj2 = JSON.parse(`&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:&quot;李四&quot;&#125;`);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>java常见序列化库 fastjson / gson / jackson</p>
</blockquote>
<h5 id="java中使用序列化库"><a href="#java中使用序列化库" class="headerlink" title="java中使用序列化库"></a>java中使用序列化库</h5><p>maven里引入依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.58&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Cat &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private boolean cute;</span><br><span class="line"></span><br><span class="line">    public Cat(String name, boolean cute) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.cute = cute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isCute() &#123;</span><br><span class="line">        return cute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCute(boolean cute) &#123;</span><br><span class="line">        this.cute = cute;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.json;</span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Cat cat = new Cat(&quot;a&quot;,true);</span><br><span class="line"></span><br><span class="line">        System.out.printf(JSON.toJSONString(cat));</span><br><span class="line"></span><br><span class="line">        String s = &quot;&#123;\&quot;cute\&quot;:true,\&quot;name\&quot;:\&quot;喵\&quot;&#125;&quot;;</span><br><span class="line"></span><br><span class="line">        cat = JSON.parseObject(s,Cat.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是 JSON 的序列化和反序列化过程</p>
<blockquote>
<h4 id="JavaBean-约定"><a href="#JavaBean-约定" class="headerlink" title="JavaBean 约定"></a>JavaBean 约定</h4></blockquote>
<p><strong>会使用你的 getter/setter 当作属性的名字，而不是你的成员private类型成员</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package com.json;</span><br><span class="line"></span><br><span class="line">public class Cat &#123;</span><br><span class="line">    private boolean cute;</span><br><span class="line"></span><br><span class="line">    public Cat(String name, boolean cute) &#123;</span><br><span class="line">        this.cute = cute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return &quot;123&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isCute() &#123;</span><br><span class="line">        return cute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCute(boolean cute) &#123;</span><br><span class="line">        this.cute = cute;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// name属性不存在了</span><br><span class="line">// getter/setter还在</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Cat cat = new Cat(&quot;a&quot;,true);</span><br><span class="line">        System.out.printf(JSON.toJSONString(cat));</span><br><span class="line">        //&#123;&quot;cute&quot;:true,&quot;name&quot;:&quot;123&quot;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="JavaBean总结"><a href="#JavaBean总结" class="headerlink" title="JavaBean总结"></a>JavaBean总结</h4><p>在Java的世界中，对json进行读写的时候，我们只看JavaBean的 <code>getter/setter</code>方法，而不看是否具有<code>xxx</code>属性</p>
<p><strong>这也进一步验证了我们想要达到封装的目的，封装应该尽可能的隐藏内部实现细节，而仅仅像外界暴露接口</strong></p>
<p>暴露的接口 在JavaBean中就是 <code>getter/setter</code> 方法</p>
<p>虽然每次java里设置一堆<code>getter/setter</code>很繁琐啰嗦，好处就是为你提供了封装，</p>
<ul>
<li>封装是软件得以成功演进的保证</li>
</ul>
<h3 id="设计模式：抽象工厂方法"><a href="#设计模式：抽象工厂方法" class="headerlink" title="设计模式：抽象工厂方法"></a>设计模式：抽象工厂方法</h3><blockquote>
<p>推荐一本书 effective java,无论处在java任何阶段都非常值得一读</p>
</blockquote>
<ul>
<li>使用静态工厂方法代替构造器</li>
<li>将构造器私有化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static Cat newCuteCat(String name)&#123;</span><br><span class="line">        return new Cat(name,true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public static Cat newUnCuteCat(String name)&#123;</span><br><span class="line">    return new Cat(name,false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Cat(String name, boolean cute) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.cute = cute;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 静态工厂方法，可以有个名字，清楚无误的告诉你干什么</span><br><span class="line">Cat.newCuteCat(&quot;xxx&quot;)  // 萌的猫</span><br><span class="line">Cat.newUnCuteCat(&quot;xxx&quot;) // 不萌的猫</span><br><span class="line">new Cat(&quot;xxx&quot;,true) // 看不出来</span><br></pre></td></tr></table></figure>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol>
<li>不像构造器，它是有名字的。可以描述在做什么<ul>
<li>疑问，我可以通过注释来告诉别人构造器做什么</li>
<li>注释是不会被编译器处理的，因此它很有可能过时，过时的注释很可能会误导你，一个过时的<strong>注释</strong>比没有注释更糟糕</li>
<li>尽可能不要写注释，如果你不能保证及时更新</li>
</ul>
</li>
<li>静态方法不一定创建一个实例，你可以返回一个null也可以返回一个之前创建好的对象，但是构造器一定会创建一个实例</li>
<li>静态构造方法可以返回 <strong>该类的子类型</strong>，而构造器只能返回该类的实例</li>
<li><p>可以根据参数决定 要不要创建这个对象，我要创建什么对象，以及要不要把之前的对象缓存一下</p>
<ul>
<li><p>参考<code>Boolean</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final class Boolean implements java.io.Serializable,</span><br><span class="line">                                    Comparable&lt;Boolean&gt;</span><br><span class="line">&#123;</span><br><span class="line">    // 预先定义好的对象</span><br><span class="line">    public static final Boolean TRUE = new Boolean(true);</span><br><span class="line">    public static final Boolean FALSE = new Boolean(false);</span><br><span class="line"></span><br><span class="line">    public static Boolean valueOf(boolean b) &#123;</span><br><span class="line">        return (b ? TRUE : FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>它返回了预先定义好的对象，不用每次都创建，省内存</p>
</li>
</ul>
</li>
<li>静态工厂返回的这个对象，它可以不存在<ul>
<li>动态加载，灵活的体现</li>
</ul>
</li>
</ol>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li>一个子类构造器会自动调用父类的构造器，构造对应的对象，但是静态方法不可以</li>
<li>很难让开发者找到，因为它的灵活性只能打开文档找到它 而不像这样<code>new Cat()</code>方便找到</li>
</ol>
<h5 id="静态方法的最佳实践"><a href="#静态方法的最佳实践" class="headerlink" title="静态方法的最佳实践"></a>静态方法的最佳实践</h5><ul>
<li>将构造器变为私有,此时外界无法创建实例，只能通过暴露的工厂方法</li>
<li>此时你内部如何修改构造器都随意了。外界只能操作暴露的工厂方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Cat &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private boolean cute;</span><br><span class="line"></span><br><span class="line">    public static Cat newCuteCat(String name)&#123;</span><br><span class="line">        return new Cat(name,true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Cat newUnCuteCat(String name)&#123;</span><br><span class="line">        return new Cat(name,false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Cat(String name, boolean cute) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.cute = cute;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类的访问控制"><a href="#类的访问控制" class="headerlink" title="类的访问控制"></a>类的访问控制</h4><p>这就是封装在类级别的表现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 之前，不同包可以直接使用</span><br><span class="line">public class Cat&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 现在 包级私有 package private </span><br><span class="line">class Cat&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>包级私有类 如<code>ProcessEnvironment</code> 在其他包外不能调用。</li>
</ul>
<blockquote>
<h4 id="如何访问一个-包级私有的类呢？-不建议使用太hack"><a href="#如何访问一个-包级私有的类呢？-不建议使用太hack" class="headerlink" title="如何访问一个 包级私有的类呢？(不建议使用太hack)"></a>如何访问一个 包级私有的类呢？(不建议使用太hack)</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 假设一个类,它是 包级私有 只能同包访问</span><br><span class="line">package com.github.demo;</span><br><span class="line">class A&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 在你的 maven项目里创建一个 桥接类 ,它的包路径和 上面的 一样</span><br><span class="line">package com.github.demo;</span><br><span class="line">class 桥接类&#123;</span><br><span class="line">    public A newInstance()&#123;</span><br><span class="line">        // 访问同一包中的私有类</span><br><span class="line">        return new A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 此时你去创建这个类</span><br><span class="line">桥接类.newInstance();// 报错 因为java发现返回值 还是不能访问</span><br><span class="line"></span><br><span class="line">// 怎么办呢,修改返回值类型为 Object</span><br><span class="line">class 桥接类&#123;</span><br><span class="line">    public Object newInstance()&#123;</span><br><span class="line">        // 访问同一包中的私有类</span><br><span class="line">        return new A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 因为 任何对象都是 Object 的子类</span><br><span class="line">// 此时你就可以</span><br><span class="line">桥接类.newInstance();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>既然这样那么我们是不是可以这样绕过限制创建 <code>ProcessEnvironment</code> 的实例呢？</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 你就创建这样的package</span><br><span class="line">package java.lang;</span><br><span class="line">public class MyClass&#123;&#125;</span><br><span class="line">//此时报错了。 说这个类是被禁止的。</span><br><span class="line"></span><br><span class="line">原因是 以 java开头的包都是 jvm的保留包,不允许你自定义一个java.lang包的，但是你可以通过别的包的访问限制</span><br></pre></td></tr></table></figure>
<h4 id="私有内部类"><a href="#私有内部类" class="headerlink" title="私有内部类"></a>私有内部类</h4><p>一个类有简单功能，你不想几个目录跳过来跳过去的使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Home&#123;</span><br><span class="line"></span><br><span class="line">    // 只能在同一个类中访问</span><br><span class="line">    private static class InnerClass&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Java模块系统简介"><a href="#Java模块系统简介" class="headerlink" title="Java模块系统简介"></a>Java模块系统简介</h3><p>需求：你像把若干个包封装在一起，暴露接口出去</p>
<ul>
<li>java8之前是不行的</li>
<li>java9引入了模块化系统，你可以把包封装成模块 module</li>
</ul>
<blockquote>
<p>java9的模块化系统好处是提供了更大范围的封装。但是它太新了。没有被业界所接受。</p>
</blockquote>
<p>例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">假设你是管理者，你手下有工人</span><br><span class="line">package com.farm;</span><br><span class="line">public class Manger&#123;</span><br><span class="line">    private Worker worker;</span><br><span class="line"></span><br><span class="line">    public void manage()&#123;</span><br><span class="line">        worker.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package com.farm;</span><br><span class="line">public class Worker&#123;</span><br><span class="line">    public void work()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 此时你的类发布了,此时你不小心暴露了 worker</span><br></pre></td></tr></table></figure>
<p>另一个项目中,利用同包路径来访问你的worker</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.farm;</span><br><span class="line">public class Boss&#123;</span><br><span class="line">    Manager manager;</span><br><span class="line"></span><br><span class="line">    public void runCompany()&#123;</span><br><span class="line">        manager.manage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Boss直接指挥工人，此时 manager就懵逼了，你怎么直接指挥工人了</span><br><span class="line">    public void directWorker()&#123;</span><br><span class="line">        Worker w1 = new Worker();</span><br><span class="line">        w1.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了不让 Boss 直接指挥 worker</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 你只能包级私有</span><br><span class="line">class Worker&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是有时候，出于其他原因你不得不把它自己包里面</p>
</blockquote>
<ul>
<li>导致 manager 无法指挥 worker了</li>
<li>只能 public了，一旦 public 你的老板又开始指挥工人了</li>
<li>我们只能使用一些君子协定如 internal 包名 让人知道是内部的包。但是别人不君子咋办！！！  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">package com.farm.worker.internal;</span><br><span class="line">public class Worker&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">package com.farm.worker;</span><br><span class="line">class Worker&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>java8之前无法做到，技术上做不到</strong><br><strong>java9的模块化系统可以解决，但是太新了，业界还没接受</strong></p>
<h3 id="builder模式"><a href="#builder模式" class="headerlink" title="builder模式"></a>builder模式</h3><ul>
<li>简略版</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.json;</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">    private String firstName;</span><br><span class="line">    private String lastName;</span><br><span class="line">    private String desc;</span><br><span class="line">    private String job;</span><br><span class="line">    private String phone;</span><br><span class="line">    private String address;</span><br><span class="line"></span><br><span class="line">    public Person(String firstName, String lastName, String desc, String job, String phone, String address) &#123;</span><br><span class="line">        this.firstName = firstName;</span><br><span class="line">        this.lastName = lastName;</span><br><span class="line">        this.desc = desc;</span><br><span class="line">        this.job = job;</span><br><span class="line">        this.phone = phone;</span><br><span class="line">        this.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>一个 <code>Person</code> 有诸多属性你在创建的时候，顺序错了非常难发现，</li>
<li>尤其是在 代码 review 的时候，不再 IDEA 里 ，没有参数提示。</li>
<li>这个时候你可以使用 builder 安装 builder</li>
<li>在IDEA里右键就可以创建 builder</li>
</ul>
<p>此时可以这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person person1 = new Person(&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;)</span><br><span class="line"></span><br><span class="line">// 更加直观，链式调用</span><br><span class="line">Person person = PersonBuilder.aPerson()</span><br><span class="line">    .withFirstName(&quot;&quot;)</span><br><span class="line">    .withLastName(&quot;&quot;)</span><br><span class="line">    .withAddress(&quot;&quot;)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/oak/">oak</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/07/03/ZB-010-java对象系统/" title="ZB-010-java对象系统" itemprop="url">ZB-010-java对象系统</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Stevin" target="_blank" itemprop="author">Stevin</a>
		
  <p class="article-time">
    <time datetime="2019-07-03T12:53:55.000Z" itemprop="datePublished"> Published 2019-07-03</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象"></a>什么是对象</h3><ul>
<li>对象就是数据和行为的集合</li>
<li>一切能用 new 创建出来的都是对象  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new Object()</span><br><span class="line"></span><br><span class="line">特例 Integer a = 1; 实际是 Integer a = new Integer(1);</span><br><span class="line">特例 String a = &quot;&quot;; 实际是 String a = new String(&quot;&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="对象的组成"><a href="#对象的组成" class="headerlink" title="对象的组成"></a>对象的组成</h3><ul>
<li>所有的对象都在堆上分配</li>
<li>每个对象有自己的数据(成员变量)<ul>
<li>原生类型成员</li>
<li>引用类型成员</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Home&#123;</span><br><span class="line">    int age;</span><br><span class="line">    Cat cat;</span><br><span class="line">    Home(Cat cat)&#123;</span><br><span class="line">        this.cat = cat;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        new Home(new Cat(1,&quot;阿三&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void miao()&#123;</span><br><span class="line">        System.out.println(&quot;喵&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Cat&#123;</span><br><span class="line">    int age;</span><br><span class="line">    String name;</span><br><span class="line">    Cat(int age,String name)&#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对象的构造函数"><a href="#对象的构造函数" class="headerlink" title="对象的构造函数"></a>对象的构造函数</h3><ul>
<li>新建对象的唯一途径<ol>
<li>在 堆 上分配空间</li>
<li>执行必要的初始化函数</li>
<li>执行构造函数</li>
</ol>
</li>
<li>没有构造器，则编译器偷偷生成一个  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Cat&#123;</span><br><span class="line">    int age; // 默认初始化为 0</span><br><span class="line">    byte b;// 0</span><br><span class="line">    short c;// 0</span><br><span class="line">    float d;// 0f</span><br><span class="line">    double e;// 0d</span><br><span class="line">    String f; // null 引用类型为 null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>new Cat(1,&quot;张三&quot;)</code> 做了什么</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Cat&#123;</span><br><span class="line">    int age;</span><br><span class="line">    String name;</span><br><span class="line">    Cat(int age,String name)&#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在堆上 开辟一个空间</li>
<li>对空间内的对象执行初始化语句，成员变量进行初始化 <code>age = 0 ,name=null</code></li>
<li>执行类的构造器函数,对成员变量进行赋值 <code>age = 1, name=&quot;张三&quot;</code></li>
</ol>
<h3 id="对象的方法"><a href="#对象的方法" class="headerlink" title="对象的方法"></a>对象的方法</h3><ul>
<li>数据是“对象有什么”</li>
<li>方法是“对象做什么”</li>
</ul>
<h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><ul>
<li>重载 overload </li>
<li>重写/覆盖 override</li>
<li>如何区分同名的不同重载方法？<ul>
<li>根据类型</li>
<li>那隐式转换呢？</li>
<li>类型最匹配优先(如果能匹配多个呢？ null)</li>
</ul>
</li>
<li>能仅仅重载返回值吗？</li>
<li>如何为方法提供默认值？<ul>
<li>没办法</li>
<li>但是可以通过重载曲线救国</li>
</ul>
</li>
</ul>
<blockquote>
<p>重载：根据类型区分</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Cat&#123;</span><br><span class="line">    Cat()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    void f()&#123;&#125;</span><br><span class="line">    void f(String s)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Cat cat = new Cat();</span><br><span class="line">        cat.f();</span><br><span class="line">        cat.f(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>重载的坑</strong></p>
</blockquote>
<ul>
<li>装箱类型 int / Integer</li>
<li>Integer 是 Number的子类</li>
<li>Number 是 Object 的子类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Cat&#123;</span><br><span class="line"></span><br><span class="line">    void f(int i)&#123;&#125;</span><br><span class="line">    void f(Integer i)&#123;&#125;</span><br><span class="line">    void f(Number i)&#123;&#125;</span><br><span class="line">    void f(Object i)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Cat cat = new Cat();</span><br><span class="line">        // 此时匹配到哪一个呢？</span><br><span class="line">        cat.f(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个方法调用可以匹配多个方法声明，我该调用谁？</p>
<ul>
<li><p>类型最匹配优先</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> // int 此时会匹配 f(int i) 那个方法</span><br><span class="line">public class Cat&#123;</span><br><span class="line"></span><br><span class="line">     void f(int i)&#123;&#125;</span><br><span class="line">     void f(Integer i)&#123;&#125;</span><br><span class="line">     void f(Number i)&#123;&#125;</span><br><span class="line">     void f(Object i)&#123;&#125;</span><br><span class="line"></span><br><span class="line">     public static void main(String[] args)&#123;</span><br><span class="line">         Cat cat = new Cat();</span><br><span class="line">         // 此时匹配到哪一个呢？</span><br><span class="line">         cat.f(1); // int</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 变化了 注释掉这个 void f(int i)&#123;&#125;</span><br><span class="line">public class Cat&#123;</span><br><span class="line"></span><br><span class="line">    void f(Integer i)&#123;&#125;</span><br><span class="line">    void f(Number i)&#123;&#125;</span><br><span class="line">    void f(Object i)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Cat cat = new Cat();</span><br><span class="line">        // 此时匹配到哪一个呢？ </span><br><span class="line">        // Integer最匹配</span><br><span class="line">        cat.f(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>null值怎么办</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Cat&#123;</span><br><span class="line"></span><br><span class="line">    void f(Integer i)&#123;&#125;</span><br><span class="line">    void f(Object[] i)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Cat cat = new Cat();</span><br><span class="line">        // 此时匹配到哪一个呢？ 两个f都匹配</span><br><span class="line">        // cat.f(null); //标红了</span><br><span class="line">        cat.f((Integer)null); // 强制为 null 指定类型</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  而我这样的时候就不报错了</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Cat&#123;</span><br><span class="line"></span><br><span class="line">    void f(Integer i)&#123;&#125;</span><br><span class="line">    void f(Number i)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Cat cat = new Cat();</span><br><span class="line">        // 此时匹配到哪一个呢？此时竟然不报错了</span><br><span class="line">        cat.f(null); //  Integer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">因为你要记住这句 匹配最接近的 </span><br><span class="line">java的类型树 </span><br><span class="line"></span><br><span class="line">假设我有两种类型 是父子关系。意味着匹配最接近的 就是 Integer</span><br><span class="line">-|Object </span><br><span class="line">--|Number</span><br><span class="line">----|Integer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">假设是兄弟关系呢？ 他们俩与 null的距离相同。所以歧义产生了 ，所以必须要 强制转换</span><br><span class="line">-|Object </span><br><span class="line">--|List</span><br><span class="line">----|ArrayList</span><br><span class="line"></span><br><span class="line">-|Object </span><br><span class="line">--|Number</span><br><span class="line">----|Integer</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<h4 id="能仅仅重载返回值吗？"><a href="#能仅仅重载返回值吗？" class="headerlink" title="能仅仅重载返回值吗？"></a>能仅仅重载返回值吗？</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void f()&#123;&#125;</span><br><span class="line"></span><br><span class="line">int f()&#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 标红</span><br><span class="line">// 因为方法调用允许忽略返回值，</span><br><span class="line">Cat c = new Cat();</span><br><span class="line">c.f(); // 忽略返回值的时候，int f()方法会和 void f()产生冲突，编译器不知道要用哪个，因此不允许这样</span><br></pre></td></tr></table></figure>
<blockquote>
<p>高深的地方</p>
</blockquote>
<ul>
<li>在源代码里是非法的，但在java的字节码里是允许存在的(JVM里允许)</li>
<li>对于我们来说，编译器不让你做就别做！！！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void f()&#123;&#125;</span><br><span class="line">int f()&#123;return 1;&#125;</span><br><span class="line">// 在源代码里是非法的，但在java的字节码里是允许存在的。</span><br></pre></td></tr></table></figure>
<h4 id="如何为方法提供默认值"><a href="#如何为方法提供默认值" class="headerlink" title="如何为方法提供默认值"></a>如何为方法提供默认值</h4><ul>
<li>答案是在java是不行的,只能这样</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void a()&#123;</span><br><span class="line">    System.out.println(&quot;喵&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void a(String a)&#123;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在其他语言，如js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function a(val = &quot;miao&quot;)&#123;</span><br><span class="line">    console.log(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构造器重载的例子"><a href="#构造器重载的例子" class="headerlink" title="构造器重载的例子"></a>构造器重载的例子</h4><ul>
<li>HashMap</li>
</ul>
<h3 id="对象的初始化过程"><a href="#对象的初始化过程" class="headerlink" title="对象的初始化过程"></a>对象的初始化过程</h3><ul>
<li>必要的初始化工作<ol>
<li>静态成员初始化</li>
<li>静态初始化块</li>
<li>成员初始化</li>
<li>初始化块</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Cat&#123;</span><br><span class="line">    static int a = 123;</span><br><span class="line">    static &#123;</span><br><span class="line">        // 这里不能调用 成员方法 f()</span><br><span class="line">        System.out.println(&quot;000&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    int age;</span><br><span class="line">    String name;</span><br><span class="line">    &#123;</span><br><span class="line">        //</span><br><span class="line">        System.out.println(&quot;abc&quot;);</span><br><span class="line">        // 这里可以调用实例方法吗？ 可以的</span><br><span class="line">        // 但是这是非常危险的，因为此阶段 还未调用 构造器 实例对象是残缺不全的</span><br><span class="line">        f();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void f()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    Cat(int age,String name)&#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        new Cat(1,&quot;aaa&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行步骤</p>
<ol>
<li><p>执行入口函数 main之前要先加载类</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">第一步</span><br><span class="line">static int a = 123;</span><br><span class="line">第二步</span><br><span class="line">static &#123;</span><br><span class="line">    // 这里不能调用 成员方法 f()</span><br><span class="line">    System.out.println(&quot;000&quot;);</span><br><span class="line">&#125;</span><br><span class="line">第三步</span><br><span class="line">执行 main 函数 new Cat(1,&quot;aaa&quot;); 开辟内存空间</span><br></pre></td></tr></table></figure>
</li>
<li><p>成员初始化</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第四步</span><br><span class="line">int age = 0;</span><br><span class="line">String name =  &quot;&quot;;</span><br><span class="line">第五步</span><br><span class="line">执行成员方法块</span><br><span class="line">第六步</span><br><span class="line">执行构造器</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="对象的生命周期"><a href="#对象的生命周期" class="headerlink" title="对象的生命周期"></a>对象的生命周期</h3><ul>
<li><p>如果一直新建对象，内存会不会爆？</p>
<ul>
<li><p>可能会</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object[] arr = new Object[10000];</span><br><span class="line">for(int i=0;i&lt;10000;i++)&#123;</span><br><span class="line">    // 每次开辟1MB的空间</span><br><span class="line">    arr[i] = new byte[1024*1024];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 报错 OutOfMemoryError</span><br></pre></td></tr></table></figure>
</li>
<li><p>可能不会, jvm帮你回收 new出来无用的空间</p>
</li>
</ul>
</li>
<li><p>那对象的内存什么时候回收？ <strong>谁也不知道，JVM帮你做</strong></p>
</li>
<li>对象的内存如何被回收？ <strong>不用管，垃圾回收器帮你干</strong> <ul>
<li>GC 垃圾回收器(幕后偷偷帮你做)</li>
</ul>
</li>
<li>JVM怎么知道那个对象没有被用到？<ul>
<li>通过引用链 (GC Roots)</li>
<li>沿着 GC Roots 可达的路径都是活对象，除此之外都是死对象</li>
</ul>
</li>
</ul>
<blockquote>
<p>生活实例</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">内存 =  假设你房子的空间</span><br><span class="line">GC Root = </span><br><span class="line">房间里有一个 你</span><br><span class="line">你.手 = 键盘</span><br><span class="line">键盘.usb = 笔记本</span><br><span class="line">笔记本.usb2 = 鼠标</span><br><span class="line">笔记本.usb3 = 电源</span><br><span class="line"></span><br><span class="line">此时预定义 GCRoot 根就是 “你”</span><br><span class="line">沿着你能找到的所有对象都是好的</span><br><span class="line">地上扔这个喝完的易拉罐，明显是垃圾 可以被干掉了</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对象没有被引用，应该就被回收了吧？    </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这个东西什么时候回收，由不得你。</span><br><span class="line">由JVM自己决定。 可能马上，也可能一直不回收</span><br><span class="line"></span><br><span class="line">GC 也是需要耗费内存空间的。</span><br><span class="line">假设你的空间非常小，GC就会帮你干掉</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不可达的对象会被删除还是什么？</p>
</blockquote>
<ul>
<li>GC 算法（现在的jvm用的是 分代 回收算法）</li>
</ul>
<p>简单理解就是，一块地上盖了楼，现在拆了盖新的楼</p>
<h4 id="分代回收的大概过程"><a href="#分代回收的大概过程" class="headerlink" title="分代回收的大概过程"></a>分代回收的大概过程</h4><ul>
<li>不一定只发生删除</li>
<li>还会发生压缩</li>
</ul>
<p>在内存中除了 占地方 还有一个非常恐怖的事 就是<strong>碎片化</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">比如操场上开始广播体操。 每个人都拉开距离把操场占满了。 每个人占据的实际空间并不大。但是空间被割裂为很碎很碎</span><br><span class="line"></span><br><span class="line">虽然有很大的空间。</span><br><span class="line"></span><br><span class="line">但是此时 如果想在 操场中心建一个花园。 你就做不到了因为 人的分布已经把操场碎片化了。</span><br><span class="line">以至于你不能找到一块 完整的连续的空间 做你想做的事情。</span><br><span class="line">这时候也会抛出内存不足的Error</span><br><span class="line"></span><br><span class="line">因此垃圾回收不仅仅是删除</span><br><span class="line">还可能把这些细碎的内存 “归整” 来释放 完整的连续的空间供其他程序使用</span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/oak/">oak</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/07/03/ZB-009-java控制流/" title="ZB-009-java控制流" itemprop="url">ZB-009-java控制流</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Stevin" target="_blank" itemprop="author">Stevin</a>
		
  <p class="article-time">
    <time datetime="2019-07-03T12:13:08.000Z" itemprop="datePublished"> Published 2019-07-03</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="方法的控制流"><a href="#方法的控制流" class="headerlink" title="方法的控制流"></a>方法的控制流</h3><ul>
<li>方法调用，就是一个方法栈每当开始一个方法调用的时候就在方法栈上面落上一个方法块(栈帧)，方法调用结束的时候销毁栈帧，控制权交给上一个方法。然后循环往复</li>
</ul>
<h3 id="while和-do-while"><a href="#while和-do-while" class="headerlink" title="while和 do while"></a>while和 do while</h3><p>死循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(true)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>do while </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">while(i &lt;100)&#123;</span><br><span class="line">    i+=1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int j =0;</span><br><span class="line">do&#123;</span><br><span class="line">    System.out.println(i)</span><br><span class="line">    j++;</span><br><span class="line">&#125;while(j&gt;0);</span><br></pre></td></tr></table></figure>
<h3 id="for-和-foreach循环"><a href="#for-和-foreach循环" class="headerlink" title="for 和 foreach循环"></a>for 和 foreach循环</h3><ul>
<li>for循环</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;100;i++)&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>foreach循环(不是java独有的)  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 冒号后面的对象必须实现了  Iterable 接口</span><br><span class="line">for(String e:Iterable&lt;String&gt;)&#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>foreach</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(&quot;1&quot;,&quot;2&quot;);</span><br><span class="line">for(String e:list)&#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a>break 和 continue</h3><ul>
<li>break 立刻结束包裹当前 break 的第一层循环</li>
<li>continue 跳过包裹当前 continue 的第一层循环中的语句，继续下一次循环</li>
<li>break label;</li>
</ul>
<blockquote>
<p>远古黑魔法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    // 这样写是声明了一个 label</span><br><span class="line">    http://google.com </span><br><span class="line">    i++; // label后面必须有一个语句 否则报错</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">～～～～～～～～～～～～～～～～～～～～～～～～～～</span><br><span class="line">// 另一种用法</span><br><span class="line">最外层循环:</span><br><span class="line">for(int i=0;i&lt;100;i++)&#123;</span><br><span class="line">    for(int j=0;j&lt;100;j++)&#123;</span><br><span class="line">        break 最外层循环;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>goto 上古时代控制程序流程的方式</p>
</blockquote>
<ul>
<li>java保留字，不能使用的关键字</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 其他语言 如 C</span><br><span class="line">label:</span><br><span class="line">if(i&lt;100)&#123;</span><br><span class="line">    i++;</span><br><span class="line">    goto label;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><blockquote>
<p>在java中只有三种东西可 switch</p>
<ul>
<li>int/long/char/byte/short</li>
<li>enum</li>
<li>String(JDK7 2011年)</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int i = new Random().nextInt(5);</span><br><span class="line">switch(i)&#123;</span><br><span class="line">    case 0:</span><br><span class="line">        xxx;</span><br><span class="line">        break;</span><br><span class="line">    case 1:</span><br><span class="line">        xxx;</span><br><span class="line">        break;</span><br><span class="line">    case 2:</span><br><span class="line">        xxx;</span><br><span class="line">        break;</span><br><span class="line">    case 3:</span><br><span class="line">        xxx;</span><br><span class="line">        break;</span><br><span class="line">    case 4:</span><br><span class="line">        xxx;</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        xxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>switch 可以贯穿</p>
</blockquote>
<blockquote>
<p>swich的作用域</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int i = new Random().nextInt(5);</span><br><span class="line">switch(i)&#123;</span><br><span class="line">    case 0:</span><br><span class="line">    case 1:</span><br><span class="line">    case 2:&#123;</span><br><span class="line">        String s = &quot;A&quot;;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    case 3:&#123;</span><br><span class="line">        String s = &quot;A&quot;;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    default:</span><br><span class="line">        xxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/oak/">oak</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/13/"><span></span>Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/52/">52</a><a class="extend next" rel="next" href="/page/15/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  

  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/oak/" title="oak">oak<sup>71</sup></a></li>
			
		
			
				<li><a href="/tags/前端知识点/" title="前端知识点">前端知识点<sup>43</sup></a></li>
			
		
			
				<li><a href="/tags/java/" title="java">java<sup>37</sup></a></li>
			
		
			
				<li><a href="/tags/Node后端/" title="Node后端">Node后端<sup>36</sup></a></li>
			
		
			
				<li><a href="/tags/M06/" title="M06">M06<sup>29</sup></a></li>
			
		
			
				<li><a href="/tags/fullstack/" title="fullstack">fullstack<sup>27</sup></a></li>
			
		
			
				<li><a href="/tags/M07/" title="M07">M07<sup>27</sup></a></li>
			
		
			
				<li><a href="/tags/python/" title="python">python<sup>26</sup></a></li>
			
		
			
				<li><a href="/tags/M08/" title="M08">M08<sup>25</sup></a></li>
			
		
			
				<li><a href="/tags/ReactWheels/" title="ReactWheels">ReactWheels<sup>24</sup></a></li>
			
		
			
				<li><a href="/tags/M04/" title="M04">M04<sup>22</sup></a></li>
			
		
			
				<li><a href="/tags/M03/" title="M03">M03<sup>20</sup></a></li>
			
		
			
				<li><a href="/tags/M02/" title="M02">M02<sup>17</sup></a></li>
			
		
			
				<li><a href="/tags/React入门/" title="React入门">React入门<sup>17</sup></a></li>
			
		
			
				<li><a href="/tags/TS入门/" title="TS入门">TS入门<sup>16</sup></a></li>
			
		
			
				<li><a href="/tags/CSS/" title="CSS">CSS<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/M01/" title="M01">M01<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/vue/" title="vue">vue<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/ES6速学/" title="ES6速学">ES6速学<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/mongodb/" title="mongodb">mongodb<sup>7</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=&verifier=b3593ceb&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Larry Page in Google. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2176287895" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2021 
		
		<a href="/about" target="_blank" title="Stevin">Stevin</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>












<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
