
 <!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  
    <title>Almost</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Stevin">
    

    
    <meta property="og:type" content="website">
<meta property="og:title" content="Almost">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="Almost">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Almost">

    
    <link rel="alternative" href="/atom.xml" title="Almost" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>
</html>
  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Almost" title="Almost"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Almost">Almost</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2020/03/08/Node全解02-01node命令行程序/" title="Node全解02_01node命令行程序" itemprop="url">Node全解02_01node命令行程序</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Stevin" target="_blank" itemprop="author">Stevin</a>
		
  <p class="article-time">
    <time datetime="2020-03-08T05:58:10.000Z" itemprop="datePublished"> Published 2020-03-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="CRM学习-Node-js-之文件模块"><a href="#CRM学习-Node-js-之文件模块" class="headerlink" title="CRM学习 Node.js 之文件模块"></a>CRM学习 Node.js 之文件模块</h3><p>目标 <strong>完成一个命令行工具</strong></p>
<blockquote>
<p>001 新建目录 node-todo-1</p>
</blockquote>
<ul>
<li>打开这个目录终端 yarn init -y </li>
<li>修改package.json 的版本号为 0.0.1</li>
<li>新建 index.js 内容为<code>console.log(&#39;hi&#39;)</code></li>
</ul>
<blockquote>
<p>002 使用库 <a href="https://github.com/tj/commander.js" target="_blank" rel="noopener">commander.js</a></p>
</blockquote>
<ul>
<li>抄文档开始干</li>
<li><code>npm install commander</code> 或者你 <code>yarn add commander</code></li>
<li><p>安装后，继续抄</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const program = require(&apos;commander&apos;);</span><br><span class="line"></span><br><span class="line">program</span><br><span class="line">.option(&apos;-d, --debug&apos;, &apos;output extra debugging&apos;)</span><br><span class="line">.option(&apos;-s, --small&apos;, &apos;small pizza size&apos;)</span><br><span class="line">.option(&apos;-p, --pizza-type &lt;type&gt;&apos;, &apos;flavour of pizza&apos;);</span><br><span class="line"></span><br><span class="line">program.parse(process.argv);</span><br><span class="line"></span><br><span class="line">// 额外加一行</span><br><span class="line">console.log(&apos;hi&apos;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>项目根目录运行 node index.js  只打印了 hi</p>
</li>
<li><p>此时你运行 <code>node index -h</code> 会显示如下内容</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Usage: index [options]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">-d, --debug              output extra debugging</span><br><span class="line">-s, --small              small pizza size</span><br><span class="line">-p, --pizza-type &lt;type&gt;  flavour of pizza</span><br><span class="line">-h, --help               output usage information</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 index.js</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 修改后然后运行  node index -h 就会显示你修改的内容</span><br><span class="line">const program = require(&apos;commander&apos;);</span><br><span class="line"></span><br><span class="line">program</span><br><span class="line">.option(&apos;-x, --xxx&apos;, &apos;what the x&apos;)</span><br><span class="line"></span><br><span class="line">program.parse(process.argv);</span><br></pre></td></tr></table></figure>
</li>
<li><p>继续抄文档， 实现一个子命令</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">const program = require(&apos;commander&apos;);</span><br><span class="line"></span><br><span class="line">// 设置它的选项</span><br><span class="line">program</span><br><span class="line">.option(&apos;-x, --xxx&apos;, &apos;what the x&apos;)</span><br><span class="line"></span><br><span class="line">// 设置子命令</span><br><span class="line">program</span><br><span class="line">.command(&apos;add &lt;taskName&gt;&apos;)</span><br><span class="line">.description(&apos;add a task&apos;)</span><br><span class="line">.action((x,y) =&gt; &#123;</span><br><span class="line">    console.log(x)</span><br><span class="line">    console.log(y)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">program.parse(process.argv);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 运行 node index add  会提示缺少一个 taskName</span><br><span class="line"></span><br><span class="line">// 运行 node index add aa  打印 </span><br><span class="line">aa</span><br><span class="line">Command &#123;</span><br><span class="line">commands: [],</span><br><span class="line">options: [],</span><br><span class="line">_execs: Set &#123;&#125;,</span><br><span class="line">_allowUnknownOption: false,</span><br><span class="line">_args: [ &#123; required: true, name: &apos;taskName&apos;, variadic: false &#125; ],</span><br><span class="line">_name: &apos;add&apos;,</span><br><span class="line">_optionValues: &#123;&#125;,</span><br><span class="line">_storeOptionsAsProperties: true,</span><br><span class="line">_passCommandToAction: true,</span><br><span class="line">_actionResults: [],</span><br><span class="line">_helpFlags: &apos;-h, --help&apos;,</span><br><span class="line">_helpDescription: &apos;output usage information&apos;,</span><br><span class="line">_helpShortFlag: &apos;-h&apos;,</span><br><span class="line">_helpLongFlag: &apos;--help&apos;,</span><br><span class="line">_noHelp: false,</span><br><span class="line">_exitCallback: undefined,</span><br><span class="line">_executableFile: undefined,</span><br><span class="line">parent: Command &#123;</span><br><span class="line">    commands: [ [Circular] ],</span><br><span class="line">    options: [ [Option] ],</span><br><span class="line">    _execs: Set &#123;&#125;,</span><br><span class="line">    _allowUnknownOption: false,</span><br><span class="line">    _args: [],</span><br><span class="line">    _name: &apos;index&apos;,</span><br><span class="line">    _optionValues: &#123;&#125;,</span><br><span class="line">    _storeOptionsAsProperties: true,</span><br><span class="line">    _passCommandToAction: true,</span><br><span class="line">    _actionResults: [],</span><br><span class="line">    _helpFlags: &apos;-h, --help&apos;,</span><br><span class="line">    _helpDescription: &apos;output usage information&apos;,</span><br><span class="line">    _helpShortFlag: &apos;-h&apos;,</span><br><span class="line">    _helpLongFlag: &apos;--help&apos;,</span><br><span class="line">    Command: [Function: Command],</span><br><span class="line">    Option: [Function: Option],</span><br><span class="line">    CommanderError: [Function: CommanderError],</span><br><span class="line">    _events: [Object: null prototype] &#123;</span><br><span class="line">    &apos;option:xxx&apos;: [Function],</span><br><span class="line">    &apos;command:add&apos;: [Function: listener]</span><br><span class="line">    &#125;,</span><br><span class="line">    _eventsCount: 2,</span><br><span class="line">    rawArgs: [</span><br><span class="line">    &apos;/Users/hjx/.nvm/versions/node/v12.14.1/bin/node&apos;,</span><br><span class="line">    &apos;/Users/hjx/Desktop/node-todo-1/index.js&apos;,</span><br><span class="line">    &apos;add&apos;,</span><br><span class="line">    &apos;aa&apos;,</span><br><span class="line">    &apos;bb&apos;,</span><br><span class="line">    &apos;cc&apos;</span><br><span class="line">    ],</span><br><span class="line">    args: [ &apos;aa&apos;, &apos;bb&apos;, &apos;cc&apos; ]</span><br><span class="line">&#125;,</span><br><span class="line">_description: &apos;add a task&apos;,</span><br><span class="line">_argsDescription: undefined</span><br><span class="line">&#125;</span><br><span class="line">// 你就可以自己领会了</span><br></pre></td></tr></table></figure>
</li>
<li><p>index.js</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const program = require(&apos;commander&apos;);</span><br><span class="line"></span><br><span class="line">// 设置它的选项</span><br><span class="line">program</span><br><span class="line">.option(&apos;-x, --xxx&apos;, &apos;what the x&apos;)</span><br><span class="line"></span><br><span class="line">// 设置子命令</span><br><span class="line">program</span><br><span class="line">  .command(&apos;add &lt;taskName&gt;&apos;)</span><br><span class="line">  .description(&apos;add a task&apos;)</span><br><span class="line">  .action((firstArg,info) =&gt; &#123;</span><br><span class="line">      let args = info.parent.args;</span><br><span class="line">      console.log(args);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">program.parse(process.argv);</span><br><span class="line"></span><br><span class="line">// node index aa bb cc dd</span><br><span class="line">// 打印 aa bb cc dd</span><br></pre></td></tr></table></figure>
<blockquote>
<p>003 修改目录结构</p>
</blockquote>
<p>cli.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const program = require(&apos;commander&apos;);</span><br><span class="line">const api = require(&apos;./index.js&apos;)</span><br><span class="line">// 设置它的选项</span><br><span class="line">program</span><br><span class="line">.option(&apos;-x, --xxx&apos;, &apos;what the x&apos;)</span><br><span class="line"></span><br><span class="line">// 设置子命令</span><br><span class="line">program</span><br><span class="line">  .command(&apos;add &lt;taskName&gt;&apos;)</span><br><span class="line">  .description(&apos;add a task&apos;)</span><br><span class="line">  .action((firstArg,info) =&gt; &#123;</span><br><span class="line">      let words = info.parent.args;</span><br><span class="line">      console.log(words);</span><br><span class="line">      api.add(words);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">program</span><br><span class="line">  .command(&apos;clear&apos;)</span><br><span class="line">  .description(&apos;clear all tasks&apos;)</span><br><span class="line">  .action(() =&gt; &#123;</span><br><span class="line">      console.log(&apos;this is clear&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">program.parse(process.argv);</span><br></pre></td></tr></table></figure>
<p>index.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports.add = (title)=&gt;&#123;</span><br><span class="line">    console.log(&apos;add &apos; + title);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行 <code>node cli add aa bb cc</code> 会显示相应的任务被添加</p>
<blockquote>
<p>004 持久化任务内容</p>
</blockquote>
<ul>
<li>但是没有数据库～</li>
<li>使用一个文件吧！ 存到用户home目录里 打算存在<code>~/</code></li>
<li>google 搜索 <code>nodejs get home directory</code></li>
<li>得到答案<code>const homedir = require(&#39;os&#39;).homedir()</code></li>
<li><p>获取用户设置的 home 目录 <code>const home = process.env.HOME</code></p>
</li>
<li><p>修改 index.js</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const homedir = require(&apos;os&apos;).homedir()</span><br><span class="line">const home = process.env.HOME || homedir;</span><br><span class="line">module.exports.add = (title)=&gt;&#123;</span><br><span class="line">    console.log(&apos;add &apos; + title);</span><br><span class="line">    // 读取之前的任务</span><br><span class="line">    fs.readFile(dbPath,&#123;&#125;);</span><br><span class="line">    // 往里面添加一个任务</span><br><span class="line">    // 存储任务到文件</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>005 如何拼目录 path</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 专门用来拼路径的 windows 是 \  mac 是 /</span><br><span class="line">const p = require(&apos;path&apos;);</span><br><span class="line">const dbPath = p.join(目录,目录&apos;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>006 利用<a href="https://devdocs.io/" target="_blank" rel="noopener">https://devdocs.io/</a>查fs模块使用</p>
</blockquote>
<ul>
<li>搜索 fs.readFile 查看api </li>
<li>看到 参数里 options 有个 flag 点进去</li>
<li>得到各种模式 <code>a / ax / a+ ...</code></li>
</ul>
<blockquote>
<p>007 实现创建任务功能</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">const homedir = require(&apos;os&apos;).homedir()</span><br><span class="line">const home = process.env.HOME || homedir;</span><br><span class="line">// 专门用来拼路径的 windows 是 \  mac 是 /</span><br><span class="line">const p = require(&apos;path&apos;);</span><br><span class="line">const dbPath = p.join(home,&apos;.todo&apos;);</span><br><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">module.exports.add = (title)=&gt;&#123;</span><br><span class="line">    // 读取之前的任务</span><br><span class="line">    fs.readFile(dbPath,&#123;flag:&apos;a+&apos;&#125;,(error,data)=&gt;&#123;</span><br><span class="line">        if(error)&#123;</span><br><span class="line">            console.log(error)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            let list;</span><br><span class="line">            try&#123;</span><br><span class="line">                list = JSON.parse(data.toString())</span><br><span class="line">            &#125;catch(error2)&#123;</span><br><span class="line">                list = []</span><br><span class="line">            &#125;</span><br><span class="line">            const task = &#123;</span><br><span class="line">                title: title,</span><br><span class="line">                done: false</span><br><span class="line">            &#125;</span><br><span class="line">            list.push(task);</span><br><span class="line">            const string = JSON.stringify(list);</span><br><span class="line">            fs.writeFile(dbPath,string + &quot;\n&quot;,(error3)=&gt;&#123;</span><br><span class="line">                if(error3)&#123;</span><br><span class="line">                    console.log(error3)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            console.log(list)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    // 往里面添加一个任务</span><br><span class="line">    // 存储任务到文件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>007 优化代码 <strong>面向接口编程</strong></p>
</blockquote>
<p>index.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const db = require(&apos;./db.js&apos;);</span><br><span class="line"></span><br><span class="line">module.exports.add = async (title) =&gt;&#123;</span><br><span class="line">    // 读取之前的任务</span><br><span class="line">    const list = await db.read();</span><br><span class="line">    // 往里面添加一个任务</span><br><span class="line">    list.push(&#123;title,done:false&#125;);</span><br><span class="line">    // 存储任务到文件</span><br><span class="line">    await db.write(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>db.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">const homedir = require(&apos;os&apos;).homedir()</span><br><span class="line">const home = process.env.HOME || homedir;</span><br><span class="line">// 专门用来拼路径的 windows 是 \  mac 是 /</span><br><span class="line">const p = require(&apos;path&apos;);</span><br><span class="line">const dbPath = p.join(home,&apos;.todo&apos;);</span><br><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">const db = &#123;</span><br><span class="line">    read(path = dbPath)&#123;</span><br><span class="line">        return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            fs.readFile(path,&#123;flag:&apos;a+&apos;&#125;,(error,data)=&gt;&#123;</span><br><span class="line">                if(error)&#123; return reject(error); &#125;</span><br><span class="line">                let list;</span><br><span class="line">                try&#123;</span><br><span class="line">                    list = JSON.parse(data.toString())</span><br><span class="line">                &#125;catch(error2)&#123;</span><br><span class="line">                    list = []</span><br><span class="line">                &#125;</span><br><span class="line">                resolve(list);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)   </span><br><span class="line">    &#125;,</span><br><span class="line">    write(list, path = dbPath)&#123;</span><br><span class="line">        return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            const string = JSON.stringify(list);</span><br><span class="line">            fs.writeFile(path,string + &quot;\n&quot;,(error)=&gt;&#123;</span><br><span class="line">                if(error)&#123; return reject(error); &#125;</span><br><span class="line">                resolve(); </span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = db;</span><br></pre></td></tr></table></figure>
<h3 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h3><ul>
<li><a href="https://github.com/slTrust/node-todo-1/tree/4e6810251dc4aa880d96c660d435b7487c7d7cb5" target="_blank" rel="noopener">https://github.com/slTrust/node-todo-1/tree/4e6810251dc4aa880d96c660d435b7487c7d7cb5</a></li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/Node后端/">Node后端</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2020/03/07/Node全解01-02如何学习Node/" title="Node全解01_02如何学习Node" itemprop="url">Node全解01_02如何学习Node</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Stevin" target="_blank" itemprop="author">Stevin</a>
		
  <p class="article-time">
    <time datetime="2020-03-07T07:57:13.000Z" itemprop="datePublished"> Published 2020-03-07</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="如何学习-Node-js"><a href="#如何学习-Node-js" class="headerlink" title="如何学习 Node.js"></a>如何学习 Node.js</h2><h3 id="先看提供的-Node-js-API"><a href="#先看提供的-Node-js-API" class="headerlink" title="先看提供的 Node.js API"></a>先看提供的 Node.js API</h3><blockquote>
<p>官方API文档</p>
</blockquote>
<ul>
<li>英文 <a href="http://nodejs.org/api" target="_blank" rel="noopener">http://nodejs.org/api</a></li>
<li>中文 <a href="http://nodejs.cn/api" target="_blank" rel="noopener">http://nodejs.cn/api</a></li>
</ul>
<blockquote>
<p>民间版本 <a href="https://devdocs.io/" target="_blank" rel="noopener">https://devdocs.io/</a></p>
</blockquote>
<p><strong>非常推荐</strong></p>
<ul>
<li>进入之后可以选择 Node.js 某个 LTS版本</li>
<li>搜索功能非常方便</li>
<li>可开启黑色主题</li>
<li>可离线观看</li>
</ul>
<h3 id="API-到底有哪些"><a href="#API-到底有哪些" class="headerlink" title="API 到底有哪些"></a>API 到底有哪些</h3><p><strong>加粗的是重点需要看的</strong></p>
<ul>
<li>Assertion 断言</li>
<li>Testing 测试</li>
<li>Async Hooks 异步钩子</li>
<li><strong>Buffer</strong> 一小段缓存</li>
<li><strong>Child Processes</strong> 子进程</li>
<li><strong>Cluster</strong> 集群</li>
<li>Console</li>
<li>Crypto 加密</li>
<li><strong>Debugger</strong> 调试</li>
<li>DNS 获取IP</li>
<li>Errors 错误</li>
<li><strong>Events</strong> 事件</li>
<li><strong>File System</strong> 文件系统</li>
<li><strong>Globals</strong> 全局变量</li>
<li><strong>HTTP</strong></li>
<li>HTTP/2</li>
<li>HTTPS</li>
<li>Inspector</li>
<li>i18n</li>
<li>Net</li>
<li>OS</li>
<li><strong>Path</strong> 路径</li>
<li>Performance Hooks</li>
<li><strong>Process</strong> 进程相关</li>
<li><strong>Query Strings</strong> url处理</li>
<li>Readline</li>
<li>REPL</li>
<li>Report</li>
<li><strong>Stream</strong> 流</li>
<li>String Decoder</li>
<li><strong>Times</strong> setTimeout 那类</li>
<li>TLS/SSL</li>
<li>Trace Events</li>
<li>TTY</li>
<li>UDP/Datagram</li>
<li><strong>URL</strong></li>
<li>Utilites</li>
<li>V8</li>
<li>VM</li>
<li><strong>Worker Threads</strong> node10之后的</li>
<li>Zlib</li>
</ul>
<h4 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h4><blockquote>
<p>基础 - Web - 框架</p>
</blockquote>
<ul>
<li>先学基础，以任务为导向学习</li>
<li>逐个学习 文件、HTTP、Stream 等模块</li>
<li>在学 Web,学习数据库、AJAX 相关知识</li>
<li>最后学框架，以项目为导向学习</li>
<li>以 Express 为切入点，制作完整的网站</li>
</ul>
<blockquote>
<p>三个约定</p>
</blockquote>
<ul>
<li>写博客，记笔记(可以参考 东京大学笔记法)</li>
<li>CRM学习法贯穿整个学习过程</li>
<li>学习调试工具和思路</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/Node后端/">Node后端</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2020/03/07/Node全解01-01Node简介/" title="Node全解01_01Node简介" itemprop="url">Node全解01_01Node简介</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Stevin" target="_blank" itemprop="author">Stevin</a>
		
  <p class="article-time">
    <time datetime="2020-03-07T02:56:44.000Z" itemprop="datePublished"> Published 2020-03-07</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="Node-js是什么"><a href="#Node-js是什么" class="headerlink" title="Node.js是什么"></a>Node.js是什么</h1><blockquote>
<p>是一个平台</p>
</blockquote>
<ul>
<li>将多种技术组合起来</li>
<li>让JS 也能调用系统接口，开发后端应用</li>
</ul>
<blockquote>
<p>Node.js用到那些技术</p>
</blockquote>
<ul>
<li>V8引擎</li>
<li>libuv</li>
<li>C/C++实现的 c-ares、http-parser、OpenSSL、zlib等库</li>
</ul>
<h3 id="Node-js的技术架构"><a href="#Node-js的技术架构" class="headerlink" title="Node.js的技术架构"></a>Node.js的技术架构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Node.js API (http模块 fs stream 等)</span><br><span class="line">-------------------------------------</span><br><span class="line">Node.js bindings |  c/c++插件</span><br><span class="line">让JS和 c/c++通讯  ｜  自定义其他能力</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">JS引擎 v8 | 跨平台的异步IO能力 libuv | DNS解析｜加密解密OpenSSL | 其他。。。</span><br></pre></td></tr></table></figure>
<p>随着Node.js的版本从 0.8升级到 12.11.1 架构也一直变化<br>如果你想看源代码，推进看 <a href="https://github.com/nodejs/node/tree/v0.10" target="_blank" rel="noopener">0.10版本</a><br>因为这一版使用了很长的时间，而且源代码比最新版少很多</p>
<blockquote>
<p>如果你想了解更多，可以看 <a href="https://github.com/yjhjstz/deep-into-node" target="_blank" rel="noopener">yjhjstz/deep-into-node</a></p>
</blockquote>
<h3 id="什么是-bindings"><a href="#什么是-bindings" class="headerlink" title="什么是 bindings"></a>什么是 bindings</h3><blockquote>
<p>背景</p>
</blockquote>
<ul>
<li>C/C++实现了一个 http_parser 库，很高效</li>
<li>你只会写JS,但是你想调用这个库</li>
<li>直接调用肯定不行，你需要一个中间的桥梁</li>
</ul>
<blockquote>
<p>bindings</p>
</blockquote>
<ul>
<li>Node.js 用C++ 对 http_parser 进行封装，使它符合某些要求，封装的的文件叫做 http_parser_bindings.cpp</li>
<li>用 Node.js提供的编译工具将其编译为 .node文件</li>
<li>JS代码可以直接 require 这个 .node文件</li>
<li>这样JS就可以 调用 C++库,中间的桥梁就是 bindings</li>
<li>由于 Node.js 提供了很多 binding， 所以叫做 bindings</li>
<li>这就是 bindings</li>
</ul>
<h4 id="JS-和-C-交互"><a href="#JS-和-C-交互" class="headerlink" title="JS 和 C++ 交互"></a>JS 和 C++ 交互</h4><ul>
<li>JS调用 C++ 代码<ul>
<li><a href="http://nodejs.cn/api/addons.html#addons_function_arguments" target="_blank" rel="noopener">官方例子</a></li>
</ul>
</li>
<li>C++调用 JS回调<ul>
<li><a href="http://nodejs.cn/api/addons.html#addons_callbacks" target="_blank" rel="noopener">官方例子</a></li>
</ul>
</li>
</ul>
<h3 id="先看下-0-10版的-Node-依赖了什么"><a href="#先看下-0-10版的-Node-依赖了什么" class="headerlink" title="先看下 0.10版的 Node 依赖了什么"></a>先看下 0.10版的 Node 依赖了什么</h3><ul>
<li><a href="https://github.com/nodejs/node/tree/v0.10/deps" target="_blank" rel="noopener">node0.10版 deps目录</a></li>
</ul>
<h3 id="libuv是什么"><a href="#libuv是什么" class="headerlink" title="libuv是什么"></a>libuv是什么</h3><blockquote>
<p>背景</p>
</blockquote>
<ul>
<li>FreeBSD 系统有个 kqueue</li>
<li>Linux 有个 epoll</li>
<li>Windows 有个 IOCP</li>
<li>Ryan 为了一个跨平台的异步IO库，开始写 libuv</li>
<li>libuv 会根据系统自动选择合适的方案</li>
</ul>
<blockquote>
<p>功能</p>
</blockquote>
<ul>
<li>可以用于TCP/UDP/DNS 文件等的异步操作</li>
</ul>
<h3 id="V8是什么"><a href="#V8是什么" class="headerlink" title="V8是什么"></a>V8是什么</h3><blockquote>
<p>功能</p>
</blockquote>
<ul>
<li>将JS源代码变成本地代码并执行</li>
<li>维护调用栈，确保JS函数的执行顺序</li>
<li>内存管理，为所有对象分配内存</li>
<li>垃圾回收，重复利用无用的内存</li>
<li>实现JS的标准库</li>
</ul>
<blockquote>
<p>注意</p>
</blockquote>
<ul>
<li>V8不提供DOM API</li>
<li>V8执行 JS 是单线程的， V8本身是多线程的</li>
<li>可以开启两个线程分别执行JS</li>
<li>V8本身是包含多个线程的，如垃圾回收为单独线程</li>
<li>自带 eventloop 但 Node.js 基于 libuv 自己做了一个</li>
</ul>
<h3 id="Event-Loop-是什么"><a href="#Event-Loop-是什么" class="headerlink" title="Event Loop 是什么"></a>Event Loop 是什么</h3><blockquote>
<p>什么是 Event</p>
</blockquote>
<ul>
<li>setTimeout 的时间到了，就会产生一个事件</li>
<li>文件可以读取了，读取出错了</li>
<li>socket 有内容了，关闭了</li>
</ul>
<blockquote>
<p>什么是 Loop</p>
</blockquote>
<ul>
<li>loop 就是循环，比如 while(true) 循环</li>
<li>由于事件是分优先级的，所以处理起来也是分先后的<ul>
<li>setTimeout(f1,100)</li>
<li>fs.readFile(‘1.txt’,f2)</li>
<li>server.on(‘close’,f3)</li>
</ul>
</li>
<li>所以 Node.js 需要按顺序轮询每种事件</li>
<li>这种轮询往往都是循环的， 1=&gt;2=&gt;3=&gt;1=&gt;2=&gt;3</li>
</ul>
<blockquote>
<p>Event Loop</p>
</blockquote>
<ul>
<li>操作系统可以触发事件，JS可以处理事件</li>
<li>Event Loop 就是对事件处理顺序的管理</li>
</ul>
<h4 id="Event-loop"><a href="#Event-loop" class="headerlink" title="Event loop"></a>Event loop</h4><ul>
<li><a href="https://juejin.im/post/5ab7677f6fb9a028d56711d0" target="_blank" rel="noopener">翻译版官方文档</a></li>
<li>读官方文档是最好的方式</li>
</ul>
<blockquote>
<p>重点阶段 </p>
</blockquote>
<ul>
<li>times 检查计时器</li>
<li>poll 轮询，检查系统事件</li>
<li>check 检查 setImmediate 回调</li>
<li>其他阶段可暂时不考虑</li>
</ul>
<blockquote>
<p>注意</p>
</blockquote>
<ul>
<li>大部分时间， Node.js 都停留在 poll 轮询阶段</li>
<li>大部分事件都在 poll 阶段被处理，如文件、网络请求</li>
</ul>
<p><strong>前面总结过Event loop 的知识点，可参考 Node-JS专精里的Eventloop章节</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>用 libuv 进行异步I/O操作</li>
<li>用 eventloop 管理事件处理顺序</li>
<li>用 C/C++ 库高效处理 DNS/HTTP …</li>
<li>用 bindings 让 JS 和 C/C++ 沟通</li>
<li>用 V8 运行 JS</li>
<li>用 Node.js 标准库简化 JS 代码</li>
<li>这就是 Node.js</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/Node后端/">Node后端</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2020/03/06/Node-JS专精13-02继承和组合/" title="Node-JS专精13_02继承和组合" itemprop="url">Node-JS专精13_02继承和组合</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Stevin" target="_blank" itemprop="author">Stevin</a>
		
  <p class="article-time">
    <time datetime="2020-03-06T14:12:01.000Z" itemprop="datePublished"> Published 2020-03-06</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="继承和组合"><a href="#继承和组合" class="headerlink" title="继承和组合"></a>继承和组合</h2><blockquote>
<p>现在给 Person 添加功能</p>
</blockquote>
<ul>
<li>person1.on(‘die’,fn)</li>
<li>person1.emit(‘die’,fn)</li>
<li>person1.off(‘die’,fn)</li>
<li>让 Person 实例具有发布订阅功能，怎么做</li>
</ul>
<blockquote>
<p>可以加代码</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    constructor()&#123;&#125;</span><br><span class="line">    sayHi()</span><br><span class="line">    cache = []</span><br><span class="line">    on()&#123;&#125;</span><br><span class="line">    off()&#123;&#125;</span><br><span class="line">    emit()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p1 = new Person()</span><br><span class="line">// 这样 p1 即是 人类 又能发布订阅</span><br></pre></td></tr></table></figure>
<blockquote>
<p>除了人还有另一个类，报社</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class 报社&#123;</span><br><span class="line">    constructor()&#123;&#125;</span><br><span class="line">    print()</span><br><span class="line">    cache = []</span><br><span class="line">    on()&#123;&#125;</span><br><span class="line">    off()&#123;&#125;</span><br><span class="line">    emit()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let 报社1 = new 报社()</span><br><span class="line">// 这样 报社1 即是 报社 又能发布订阅</span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="消除重复"><a href="#消除重复" class="headerlink" title="消除重复"></a>消除重复</h3></blockquote>
<p><strong>Person 和报社有重复属性</strong></p>
<ul>
<li>把重复属性提取出来，单独写个类 EventEmitter</li>
<li>然后让 Person 和 报社 继承 EventEmitter</li>
</ul>
<blockquote>
<p>细节</p>
</blockquote>
<ul>
<li>constructor 要调用 super()</li>
<li>来保证 EventEmitter 实例被初始化</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class EventEmitter&#123;</span><br><span class="line">    constructor()&#123;&#125;</span><br><span class="line">    cache = []</span><br><span class="line">    on()&#123;&#125;</span><br><span class="line">    off()&#123;&#125;</span><br><span class="line">    emit()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person extends EventEmitter &#123;</span><br><span class="line">    name</span><br><span class="line">    constructor()&#123; super() &#125;</span><br><span class="line">    sayHi()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class aa extends EventEmitter&#123;</span><br><span class="line">    name</span><br><span class="line">    constructor()&#123; super() &#125;</span><br><span class="line">    print()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="继承的问题"><a href="#继承的问题" class="headerlink" title="继承的问题"></a>继承的问题</h3><ul>
<li>如果我需要多个功能怎么办？</li>
</ul>
<blockquote>
<p>两个选择</p>
</blockquote>
<ul>
<li>让 EventEmitter 继承其他类 （非常不好，类就不单纯了）</li>
<li>让 Person 继承两个类(多继承，C++ 才支持 ，也不行) </li>
</ul>
<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p><strong>组合没有固定的写法</strong></p>
<blockquote>
<h4 id="让-Person-实现发布订阅"><a href="#让-Person-实现发布订阅" class="headerlink" title="让 Person 实现发布订阅"></a>让 Person 实现发布订阅</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    eventEmitter = new EventEmitter()</span><br><span class="line">    name</span><br><span class="line">    sayHi()&#123;&#125;</span><br><span class="line">    on(eventName,fn)&#123; </span><br><span class="line">        this.eventEmitter.on(eventName,fn)</span><br><span class="line">    &#125;</span><br><span class="line">    off(eventName,fn)&#123; </span><br><span class="line">        this.eventEmitter.off(eventName,fn)</span><br><span class="line">    &#125;</span><br><span class="line">    emit(eventName,data)&#123; </span><br><span class="line">        this.eventEmitter.emit(eventName,data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    eventEmitter = new EventEmitter()</span><br><span class="line">    name</span><br><span class="line">    sayHi()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p1 = new Person(&apos;aa&apos;)</span><br><span class="line"></span><br><span class="line">mixin(p1,new EventEmitter())</span><br><span class="line"></span><br><span class="line">function mixin(to,from)&#123;</span><br><span class="line">    for(let key in from)&#123;</span><br><span class="line">        to[key] = from[key]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 注意这里是 简化版的 mixin， 实际会更复杂的</span><br></pre></td></tr></table></figure>
<p>这样你就可以有更多的功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    eventEmitter = new EventEmitter()</span><br><span class="line">    name</span><br><span class="line">    sayHi()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">let p1 = new Person(&apos;aa&apos;)</span><br><span class="line">mixin(p1,new EventEmitter())</span><br><span class="line">mixin(p1,new Flyer())</span><br><span class="line">mixin(p1,new Killer())</span><br></pre></td></tr></table></figure>
<h4 id="有了组合之后，你可能不需要class了"><a href="#有了组合之后，你可能不需要class了" class="headerlink" title="有了组合之后，你可能不需要class了"></a>有了组合之后，你可能不需要class了</h4><ul>
<li>直接函数 + 闭包</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 看到如下类</span><br><span class="line">class robot&#123;</span><br><span class="line">    run()</span><br><span class="line">&#125;</span><br><span class="line">class murderRobot extends robot&#123;</span><br><span class="line">    kill()</span><br><span class="line">&#125;</span><br><span class="line">class cleaningRobot extends robot&#123;</span><br><span class="line">    clean()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class animal&#123;</span><br><span class="line">    poop()</span><br><span class="line">&#125;</span><br><span class="line">class dog extends animal&#123;</span><br><span class="line">    wangwang()</span><br><span class="line">&#125;</span><br><span class="line">class cat extends animal&#123;</span><br><span class="line">    miaomiao()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需求 狗型杀人机器人 （变态的需求总是不期而遇）</p>
</blockquote>
<p><strong>继承很难做到，我们用组合</strong></p>
<blockquote>
<p>组合模式来看</p>
</blockquote>
<ul>
<li>dog = poop() + wangwang()</li>
<li>cat = poop() + miaomiao()</li>
<li>cleaningRobot = run() + clean()</li>
<li>murderRobot = run() + kill()</li>
<li>狗型杀人机器人 = run() + kill() + wangwang()</li>
</ul>
<blockquote>
<h4 id="不用-class写-dog"><a href="#不用-class写-dog" class="headerlink" title="不用 class写 dog"></a>不用 class写 dog</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">const createWang = (state) =&gt;(&#123;</span><br><span class="line">    wangwang: ()=&gt;&#123;</span><br><span class="line">        console.log(`汪汪,我是$&#123;state.name&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const createRun = (state) =&gt;(&#123;</span><br><span class="line">    run: ()=&gt; state.position += 1</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const createKill = (state) =&gt;(&#123;</span><br><span class="line">    kill: ()=&gt; &#123;</span><br><span class="line">        console.log(`kill`)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const createDog = (name) =&gt;&#123;</span><br><span class="line">    const state = &#123;name,position:0&#125;</span><br><span class="line">    return Object.assign(</span><br><span class="line">        &#123;&#125;,</span><br><span class="line">        createWang(state),</span><br><span class="line">        createRun(state),</span><br><span class="line">        createKill(state)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const dog = createDog(&apos;小白&apos;)</span><br></pre></td></tr></table></figure>
<p><strong>这就是组合模式</strong></p>
<ul>
<li>缺点：写法太灵活，而且这是JS写法，如果是 Java 肯定不这样</li>
</ul>
<h4 id="结论和共识"><a href="#结论和共识" class="headerlink" title="结论和共识"></a>结论和共识</h4><ul>
<li>组合优于继承<ul>
<li>能实现 扁平化的重新分配</li>
<li>而继承 是一个垂直方向的，如果你的需求是两个垂直线交叉 很难做！</li>
</ul>
</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><blockquote>
<h4 id="什么情况用继承"><a href="#什么情况用继承" class="headerlink" title="什么情况用继承"></a>什么情况用继承</h4></blockquote>
<ul>
<li>开发者不会用组合</li>
<li>功能单一，没太多交叉的地方，一眼能看出继承关系</li>
<li>前端库比较喜欢用继承</li>
</ul>
<blockquote>
<p>举例</p>
</blockquote>
<ul>
<li>class App extends React.component{…}</li>
<li>React.Component 内置了方便的复用代码(钩子)</li>
</ul>
<blockquote>
<h4 id="什么情况用组合"><a href="#什么情况用组合" class="headerlink" title="什么情况用组合"></a>什么情况用组合</h4></blockquote>
<ul>
<li>功能组合非常灵活，无法一眼看出继承关系</li>
<li>插件模式</li>
<li>mixin 模式</li>
</ul>
<p><strong>举例</strong></p>
<ul>
<li>Vue.mixin()</li>
<li>Vue.use(plugin)</li>
<li>Vue 的 install 功能</li>
<li>React接受组件的组件</li>
<li>const vm = new Vue({…}) <ul>
<li>vm.$on / vm.$off / vm.$emit</li>
</ul>
</li>
<li>Vue 组合了 EventEmiter</li>
</ul>
<h4 id="什么情况用这些"><a href="#什么情况用这些" class="headerlink" title="什么情况用这些"></a>什么情况用这些</h4><ul>
<li>基础库用继承</li>
<li>业务开发使用组合</li>
<li>不一定是对的 灵活选择</li>
</ul>
<h3 id="组合的内存性能问题"><a href="#组合的内存性能问题" class="headerlink" title="组合的内存性能问题"></a>组合的内存性能问题</h3><ul>
<li>结论就是：实际上没多大区别</li>
</ul>
<p>之前的 狗型杀人机器人</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const dog = createDog(&apos;小白&apos;)</span><br><span class="line">const d1 = createDog(&apos;a&apos;)</span><br><span class="line">const d2 = createDog(&apos;b&apos;)</span><br><span class="line"></span><br><span class="line">d1.run === d2.run  // false</span><br></pre></td></tr></table></figure>
<p>解决方案:通过一些技巧优化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const f1 = ()=&gt;&#123;&#125;</span><br><span class="line">createF1 = (state)=&gt;(&#123;f1:f1&#125;)</span><br><span class="line">const f2 = ()=&gt;&#123;&#125;</span><br><span class="line">createF2 = (state)=&gt;(&#123;f2:f2&#125;)</span><br><span class="line"></span><br><span class="line">createDog = (name)=&gt;&#123;</span><br><span class="line">    const state = &#123;name&#125;</span><br><span class="line">    return Object.assign(&#123;&#125;,createF1(),createF2())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d1 = createDog(1)</span><br><span class="line">d2 = createDog(2)</span><br><span class="line"></span><br><span class="line">d1.f1 === d2.f1 // true</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在看继承：实际也不省空间</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    sayA()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A&#123;</span><br><span class="line">    name</span><br><span class="line">    constructor(name)&#123;</span><br><span class="line">        super()</span><br><span class="line">        this.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    sayB()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实际就是原型链</span><br><span class="line">// 但是 构建B的过程 要先构建 A 多了一层原型 所以也并不是非常的省内存</span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/Node后端/">Node后端</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2020/03/06/Node-JS专精13-01类/" title="Node-JS专精13_01类" itemprop="url">Node-JS专精13_01类</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Stevin" target="_blank" itemprop="author">Stevin</a>
		
  <p class="article-time">
    <time datetime="2020-03-06T05:24:53.000Z" itemprop="datePublished"> Published 2020-03-06</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="类知识简介"><a href="#类知识简介" class="headerlink" title="类知识简介"></a>类知识简介</h1><blockquote>
<p>为什么有类</p>
</blockquote>
<ul>
<li>不同对象的属性重复了，就有类</li>
</ul>
<blockquote>
<p>为什么有继承</p>
</blockquote>
<ul>
<li>不同的类的属性重复类，就有继承</li>
</ul>
<p><strong>大部分编程技巧，都是为了解决重复</strong></p>
<h3 id="对象的属性重复了"><a href="#对象的属性重复了" class="headerlink" title="对象的属性重复了"></a>对象的属性重复了</h3><ul>
<li>两个对象的属性重复</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let p1 = &#123;name:&apos;aa&apos;,age:18,sayHi()&#123;&#125;&#125;</span><br><span class="line">let p2 = &#123;name:&apos;bb&apos;,age:18,sayHi()&#123;&#125;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>于是有了类和构造函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Pserson &#123;</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">    sayHi()&#123;&#125;</span><br><span class="line">    constructor(name,age)&#123;</span><br><span class="line">        this.name = name</span><br><span class="line">        this.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p1 = new Person(&apos;aa&apos;,18)</span><br><span class="line">let p2 = new Person(&apos;bb&apos;,18)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>改写成TS</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    sayHi(): void &#123;&#125;</span><br><span class="line">    constructor(public name: string, public age: number)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p1 = new Person(&apos;aa&apos;,18)</span><br><span class="line">let p2 = new Person(&apos;bb&apos;,18)</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4></blockquote>
<p><strong>类</strong></p>
<ul>
<li>类就是把对象的属性提前写好，避免重复</li>
<li>类里面的字段会变成对象的属性</li>
<li>为了节约内存，所有函数都是 共用的</li>
<li>而非函数属性是各个对象自有的</li>
<li>使用 console.dir 可以看出来</li>
</ul>
<p><strong>构造函数</strong></p>
<ul>
<li>属性名虽然可以提前写好，但是属性值不行</li>
<li>所以需要构造函数接受参数，初始化属性值</li>
<li>构造函数不需要写 return , 默认会 return 新对象</li>
</ul>
<p><strong>语法</strong></p>
<ul>
<li>JS的所有 class 语法可以在 MDN上看</li>
<li>TS的所有 class 语法可以在 TS英文/中文 官网看</li>
</ul>
<blockquote>
<h4 id="不想所有函数都是共用的"><a href="#不想所有函数都是共用的" class="headerlink" title="不想所有函数都是共用的"></a>不想所有函数都是共用的</h4></blockquote>
<ul>
<li>写成箭头函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Pserson &#123;</span><br><span class="line">    sayHi()&#123;&#125; // 共用</span><br><span class="line">    myFn = () =&gt; &#123;&#125; // 自用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这玩意除了浪费内存还有啥用？</strong></p>
<ul>
<li>你必须<code>onclick 那里bind(this)</code>否则报错</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import ReactDOM from &quot;react-dom&quot;;</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  name = &quot;Frank&quot;;</span><br><span class="line">  sayHi()&#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">    console.log(`Hi, I&apos;m $&#123;this.name&#125;`);</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.sayHi.bind(this)&#125;&gt;say hi&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const rootElement = document.getElementById(&quot;root&quot;);</span><br><span class="line">ReactDOM.render(&lt;App /&gt;, rootElement);</span><br></pre></td></tr></table></figure>
<ul>
<li>而如果是各自的函数，就可以直接调用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import ReactDOM from &quot;react-dom&quot;;</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  name = &quot;Frank&quot;;</span><br><span class="line">  sayHi = () =&gt; &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">    console.log(`Hi, I&apos;m $&#123;this.name&#125;`);</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.sayHi&#125;&gt;say hi&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const rootElement = document.getElementById(&quot;root&quot;);</span><br><span class="line">ReactDOM.render(&lt;App /&gt;, rootElement);</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://codesandbox.io/s/muddy-snowflake-1ezyg" target="_blank" rel="noopener">代码地址</a></li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/Node后端/">Node后端</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2020/03/05/Node-JS专精12-01Eventloop/" title="Node-JS专精12_01Eventloop" itemprop="url">Node-JS专精12_01Eventloop</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Stevin" target="_blank" itemprop="author">Stevin</a>
		
  <p class="article-time">
    <time datetime="2020-03-05T02:46:11.000Z" itemprop="datePublished"> Published 2020-03-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="https://juejin.im/post/5ab7677f6fb9a028d56711d0" target="_blank" rel="noopener">Event Loop、计时器、nextTick</a></li>
</ul>
<h3 id="Eventloop-之前的前置内容"><a href="#Eventloop-之前的前置内容" class="headerlink" title="Eventloop 之前的前置内容"></a>Eventloop 之前的前置内容</h3><blockquote>
<p>操作系统相关</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">网页上有个输入框，当你按下键盘的 “J” 之后发生了什么</span><br><span class="line"></span><br><span class="line">实际 “J” 下面有一个非常复杂的电路</span><br><span class="line">当你按下 之后，会触发一个电流</span><br><span class="line">这个电流会触发一个你按键的信息 如 101</span><br><span class="line">然后把这个 信息 101 传递给 操作系统</span><br><span class="line">操作系统知道这个 按键信息之后，它就会通知给你的浏览器</span><br><span class="line">浏览器得到 “J” 按键信息之后，就会把这个 “J” 显示在你的输入框上</span><br></pre></td></tr></table></figure>
<p>为什么讲这个：<strong>浏览器它会接受到系统给它的一个事件</strong>用户不停的触发事件，浏览器就不停的把用户输入渲染到输入框里</p>
<p>这个东西呢就叫做 <strong>“事件”</strong></p>
<blockquote>
<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4></blockquote>
<p>接受各种外部设备发出的信号</p>
<ul>
<li>蓝牙事件</li>
<li>鼠标事件</li>
<li>键盘事件</li>
<li>USB事件</li>
</ul>
<blockquote>
<p>疑问？为什么你一插 USB操作系统马上就知道呢？有没有延迟呢？它是非常的快呢？还是一段时间一段时间的查呢？</p>
</blockquote>
<ul>
<li>非常遗憾的是，操作系统并没有你想想的那么聪明</li>
<li>它是如何知道 用户按下了 “J” 呢？</li>
</ul>
<p>它实际上是 <strong>不停的等键盘，可能每隔5毫秒查看一下有没有按下这个键</strong> 这个过程 叫做 <strong>“轮询”</strong></p>
<h3 id="接下来我们看一下-浏览器的内容"><a href="#接下来我们看一下-浏览器的内容" class="headerlink" title="接下来我们看一下 浏览器的内容"></a>接下来我们看一下 浏览器的内容</h3><ul>
<li>浏览器除了运行 JS 之外，还有些网络请求<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 假设你做了这样的事情</span><br><span class="line">console.log(1)</span><br><span class="line">console.log(2)</span><br><span class="line">console.log(3)</span><br><span class="line">...</span><br><span class="line">console.log(10)</span><br><span class="line">ajax(); </span><br><span class="line">console.log(11)</span><br><span class="line">console.log(12)</span><br><span class="line">...</span><br><span class="line">console.log(20)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当我们发送了请求之后，请求大概需要0.2秒得到结果，</span><br><span class="line">首先JS是单线程，那么在这请求 0.2 秒的时间内， ajax() 后面的代码有么有执行？</span><br><span class="line"></span><br><span class="line">有！！！ 执行了</span><br><span class="line"></span><br><span class="line">那么此时 ajax 请求的 0.2秒 是谁在等？</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>或者说 等待请求结果是谁在处理 / 谁在轮询</p>
</blockquote>
<ul>
<li>答案是：<strong>“C++”</strong>， 浏览器有一个轮询机制，每隔一段时间假设5毫秒就问 结果来了没？</li>
<li>反正始终有一个东西在轮询 ，我们不管到底是 浏览器还是 操作系统这些细节。 反正不是JS在等就好了</li>
</ul>
<p><strong>所有的事件 应该如何通知给 JS</strong></p>
<h3 id="这个轮询的规则是什么？"><a href="#这个轮询的规则是什么？" class="headerlink" title="这个轮询的规则是什么？"></a>这个轮询的规则是什么？</h3><p>搞清楚这些规则，你就明白什么是 <strong>Eventloop</strong></p>
<ul>
<li>刚刚的内容讲的是浏览器，我们必须要回到 Node.js 和浏览器是差不多的东西</li>
<li>Node.js 可以执行js代码，浏览器也可以执行 js代码，Eventloop 是 Node.js的概念而不是 浏览器。 所以我们来看 Node.js</li>
</ul>
<h4 id="回到-Node-js"><a href="#回到-Node-js" class="headerlink" title="回到 Node.js"></a>回到 Node.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">同样执行10行代码</span><br><span class="line">然后发起一个异步任务 耗时2秒 setTimeout(fn,2000)</span><br><span class="line">下面又执行20行代码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">那么这个  setTimeout 到底是谁在做呢？</span><br></pre></td></tr></table></figure>
<blockquote>
<p>引入 Eventloop</p>
</blockquote>
<ul>
<li>首先这个 Eventloop 会去监听这个 setTimeout，它会保证 一段时间后执行这个 fn</li>
</ul>
<blockquote>
<h4 id="Eventloop-之前的铺垫"><a href="#Eventloop-之前的铺垫" class="headerlink" title="Eventloop 之前的铺垫"></a>Eventloop 之前的铺垫</h4></blockquote>
<ul>
<li>Eventloop 到底是真实存在的对象，还是一个虚拟的概念？</li>
</ul>
<p>来个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">假设人是有轮回的？ 我们叫它 人生循环</span><br><span class="line">那么人生循环有那些阶段呢？</span><br><span class="line"></span><br><span class="line">生老病死 ==》 投胎 ==》 生老病死 ==》 投胎 。。。</span><br><span class="line">什么时候是尽头，除非宇宙毁灭，什么时候开始，也不要太关心。</span><br><span class="line"></span><br><span class="line">请问人生循环 是什么？</span><br><span class="line"></span><br><span class="line">人在一生中处于不同阶段的过程</span><br></pre></td></tr></table></figure>
<p><strong>事件循环不是循环，它是状态变化的过程</strong></p>
<h4 id="Eventloop-事件循环的阶段"><a href="#Eventloop-事件循环的阶段" class="headerlink" title="Eventloop 事件循环的阶段"></a>Eventloop 事件循环的阶段</h4><ul>
<li>times (前端需要知道)</li>
<li>I/O callbacks </li>
<li>idle , prepare</li>
<li>poll (前端需要知道)</li>
<li>check (前端需要知道)</li>
<li>close callbacks</li>
</ul>
<blockquote>
<p>我们只需要清楚 times / poll / check 就够了</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1 times</span><br><span class="line">2 poll</span><br><span class="line">3 check </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">times =&gt; poll 会停留一段事件</span><br><span class="line">poll =&gt; check</span><br><span class="line">check =&gt; times</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当我们执行 setTimeout(fn,2000) 时， 会把 fn 放入 times 的一个 数组里 (队列)同时记录 要在 2秒后执行 fn ,于是 js 就去做自己的事去了</span><br><span class="line"></span><br><span class="line">setTimeout(fn,2000) 之后就会进入 poll 阶段 等待的过程中 他会去看时间， </span><br><span class="line">刚才 js 说要在 2秒后执行 fn , 比如此时等了 500毫秒，发现不需要执行， 继续等 1000毫秒再去看， 继续等， 等到 2秒的时候 发现时间到了， </span><br><span class="line">赶紧进入 times 阶段执行 fn， 虽然 poll之后要经过 check 阶段 ，但稍后再说</span><br><span class="line">执行完 fn 之后 又回到 poll 阶段 继续等。 一般来说有最长等待时间 假设3秒 后就会进入 check 然后进入 times 然后继续进入 poll</span><br><span class="line">所以 大部分时间都是在 poll 阶段 用来等</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="check-阶段是什么？"><a href="#check-阶段是什么？" class="headerlink" title="check 阶段是什么？"></a>check 阶段是什么？</h4></blockquote>
<ul>
<li>Node.js 除了 setTimeout 还有 setImmediate(fn2) </li>
<li>当你调用 <code>setImmediate(fn2)</code> 的时候 你的 fn2 不会进入 times 阶段，会进入 check阶段</li>
<li>check 阶段也是有 一个队列的 主要是用来存 <code>setImmediate</code> 执行的函数的</li>
</ul>
<blockquote>
<p>来个考题, 先执行 fn 还是先执行 fn2</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(fn,0)</span><br><span class="line">setImmediate(fn2)</span><br><span class="line">// 答案是 fn2</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">setTimeout(fn,0) 执行后 会进入 times 阶段 把 fn 放入 times 的队列里 </span><br><span class="line">然后看到下一句代码</span><br><span class="line">setImmediate(fn2)  会把 fn2 放入 check 阶段的队列里 ， 并立即执行队列里的fn2。 </span><br><span class="line">于是JS开始做事了， 它看到 check 队列里有个需要立即执行的 于是就不停了 ，直接 fn2执行掉</span><br><span class="line">然后到 times 阶段 刚好发现 times 队列里 有个 0秒后执行，于是 执行 fn</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="一个坑-开启-Eventloop-这是需要消耗时间的"><a href="#一个坑-开启-Eventloop-这是需要消耗时间的" class="headerlink" title="一个坑 开启 Eventloop() 这是需要消耗时间的"></a>一个坑 开启 Eventloop() 这是需要消耗时间的</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 在 node环境下 运行这两句</span><br><span class="line">setTimeout(()=&gt;&#123;console.log(&apos;fn&apos;)&#125;,0)</span><br><span class="line">setImmediate(()=&gt;&#123;console.log(&apos;fn2&apos;)&#125;)</span><br><span class="line"></span><br><span class="line">// 你会惊讶的发现 有的时候 fn fn2 有的时候 fn2 fn</span><br><span class="line"></span><br><span class="line">// 为什么？</span><br><span class="line">如果说 开启 Eventloop 很快 那么就是你分析的顺序 fn2 fn</span><br><span class="line">如果 Eventloop 开启很慢 我们在执行js的时候 可能还没进入 times 实际上是先把 fn 加到 times 队列里 然后在开始第一阶段</span><br><span class="line"></span><br><span class="line">这就刚好解释了 为什么顺序是不确定的？</span><br><span class="line">就是看 进入 times 阶段的时候 fn 就存在 还是 进入 times 阶段的时候 fn 不存在</span><br></pre></td></tr></table></figure>
<p>如何解决这种情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;console.log(&apos;fn&apos;)&#125;,0)</span><br><span class="line">    setImmediate(()=&gt;&#123;console.log(&apos;fn2&apos;)&#125;)</span><br><span class="line">&#125;,1000)</span><br><span class="line"></span><br><span class="line">// 这样每次都是  fn2 fn</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="process-nextTick-是放到什么阶段"><a href="#process-nextTick-是放到什么阶段" class="headerlink" title="process.nextTick 是放到什么阶段"></a>process.nextTick 是放到什么阶段</h4></blockquote>
<ul>
<li>首先它不属于 Eventloop 的任何一个阶段，官网说的，其他都是瞎扯的</li>
<li>process.nextTick 意思就是 当前阶段结束后马上执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;console.log(&apos;fn&apos;)&#125;,0)</span><br><span class="line">    setImmediate(()=&gt;&#123;console.log(&apos;fn2&apos;)&#125;)</span><br><span class="line">    process.nextTick(()=&gt;&#123;console.log(&apos;fn3&apos;)&#125;)</span><br><span class="line">&#125;,1000)</span><br><span class="line"></span><br><span class="line">// 注意！！！ nextTick 不属于 Eventloop 任何阶段 ， 它的意思是当前阶段马上执行</span><br><span class="line">//  setImmediate 会在 setTimeout之前</span><br><span class="line">// setImmediate 是从 poll 阶段 进入 check 才执行</span><br><span class="line">// nextTick 是当前阶段 poll 所以先 nextTick 在 check 阶段里的 然后 times 里的</span><br><span class="line">/*</span><br><span class="line">fn3</span><br><span class="line">fn2</span><br><span class="line">fn</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(()=&#123;</span><br><span class="line">    console.log(&quot;setImmediate1&quot;)</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">        console.log(&quot;setTimeout1&quot;)</span><br><span class="line">        </span><br><span class="line">    &#125;,0)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(()=&#123;</span><br><span class="line">    console.log(&quot;setTimeout2&quot;)</span><br><span class="line">    setImmediate(()=&gt;&#123;</span><br><span class="line">        console.log(&quot;setImmediate2&quot;)</span><br><span class="line">        </span><br><span class="line">    &#125;,0)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">答案是：</span><br><span class="line">setImmediate1</span><br><span class="line">setTimeout2</span><br><span class="line">setTimeout1</span><br><span class="line">setImmediate2</span><br><span class="line"></span><br><span class="line">// 务必画图分析</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>Eventloop 状态转移</p>
</blockquote>
<ul>
<li>Node.js 有六个阶段 简化为三个 <ul>
<li>times</li>
<li>poll</li>
<li>check</li>
</ul>
</li>
<li>Chrome （一会，马上）(宏任务，微任务)</li>
</ul>
<blockquote>
<p>Node.js</p>
</blockquote>
<ul>
<li>setTimeout =&gt; times</li>
<li>setImmediate =&gt; check</li>
<li>nextTick =&gt; 当前阶段结束后执行</li>
</ul>
<blockquote>
<p>Chrome</p>
</blockquote>
<ul>
<li>setTimeout =&gt; 宏任务</li>
<li>promise.then =&gt; 微任务<ul>
<li>注意！ 面试喜欢问 await <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">await 转换成 promise</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>面试题</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">async function async1()&#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">    await async2()</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function async2()&#123;</span><br><span class="line">    console.log(3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line">new Promise(function(resolve)&#123;</span><br><span class="line">    console.log(4)</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(function()&#123;</span><br><span class="line">    console.log(5)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p><strong>首先改写所有的 await</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">async function async1()&#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">    async2().then(f1)</span><br><span class="line">    function f1()&#123;</span><br><span class="line">        console.log(2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function async2()&#123;</span><br><span class="line">    console.log(3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line">new Promise(function(resolve)&#123;</span><br><span class="line">    console.log(4)</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(f2)</span><br><span class="line"></span><br><span class="line">function f2()&#123;</span><br><span class="line">    console.log(5)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">在看 首先 async1()执行 打印1</span><br><span class="line">async2() 执行 打印3</span><br><span class="line">async2().then() 把 f1 存入 微任务 </span><br><span class="line">new Promsie 开始 打印4</span><br><span class="line">把 new Promise().then(f2) 的 f2 存入 微任务</span><br><span class="line">开始执行微任务队列里的内容</span><br><span class="line">f1 执行 打印 2</span><br><span class="line">f2 执行 打印 5</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<blockquote>
<p>面试</p>
</blockquote>
<ul>
<li>一定要画图</li>
<li>一定要画图</li>
<li>一定要画图</li>
</ul>
<h4 id="个性化题目的面试如何处理"><a href="#个性化题目的面试如何处理" class="headerlink" title="个性化题目的面试如何处理"></a>个性化题目的面试如何处理</h4><p>只有某些公司会问，80%的公司不会问的题</p>
<ul>
<li>PWA</li>
<li>echarts / d3.js</li>
<li>three.js</li>
<li>flutter</li>
<li>SSR</li>
</ul>
<blockquote>
<h4 id="如何准备"><a href="#如何准备" class="headerlink" title="如何准备"></a>如何准备</h4></blockquote>
<p><strong>平时用不到，公司太小众了， 但是面试问？</strong></p>
<ul>
<li>先看公司招聘启事，如果明确说了，用到某某技术，你就去看文档，搞出一个 hello world</li>
<li>因为大部分跟你一起面试的人根本就不会对这些东西做任何准备，你只要比他们多准备一点点，就可以了</li>
<li>你不在乎你比别人多厉害，而在乎只要比别人厉害一点</li>
<li>如果你没做，被问到，你连接话的地方都没有那岂不是很尴尬。所以你做个Hello World 都能改善局面</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/Node后端/">Node后端</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2020/03/04/Node-JS专精11-04async-await问题/" title="Node-JS专精11_04async_await问题" itemprop="url">Node-JS专精11_04async_await问题</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Stevin" target="_blank" itemprop="author">Stevin</a>
		
  <p class="article-time">
    <time datetime="2020-03-04T09:53:22.000Z" itemprop="datePublished"> Published 2020-03-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="问题整理"><a href="#问题整理" class="headerlink" title="问题整理"></a>问题整理</h3><blockquote>
<h4 id="async-await-是-promise-的语法糖如何用-promise-实现-async-await"><a href="#async-await-是-promise-的语法糖如何用-promise-实现-async-await" class="headerlink" title="async / await 是 promise 的语法糖如何用 promise 实现 async/await"></a>async / await 是 promise 的语法糖如何用 promise 实现 async/await</h4></blockquote>
<ul>
<li>答：有的语法糖好改写，有的语法糖不好改写。这个语法糖就不好改写，因为这是语言层面的改动，而不是API层面的。可以举例说明</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// API层面语法糖</span><br><span class="line">如 promise 的 catch 改写成  promise.then(null,fn)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// await 改写</span><br><span class="line">async function fn()&#123;</span><br><span class="line">    const res = await ajax();</span><br><span class="line">    console.log(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn2()&#123;</span><br><span class="line">    ajax().then((res)=&gt;&#123;</span><br><span class="line">        console.log(res)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="有些-await-需要等待上一个-await-的结果，有些不用，如何让不用同步的-await-异步执行"><a href="#有些-await-需要等待上一个-await-的结果，有些不用，如何让不用同步的-await-异步执行" class="headerlink" title="有些 await 需要等待上一个 await 的结果，有些不用，如何让不用同步的 await 异步执行"></a>有些 await 需要等待上一个 await 的结果，有些不用，如何让不用同步的 await 异步执行</h4></blockquote>
<ul>
<li>答：其实非常简单</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">async function fn()&#123;</span><br><span class="line">    await getUser()</span><br><span class="line">    await getProducts();</span><br><span class="line">    // 你想要 getOthers 不等前两个同步结果，非常简单 把它放到 前面就行了</span><br><span class="line">    getOthers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 处理方式</span><br><span class="line">async function fn2()&#123;</span><br><span class="line">    getOthers();</span><br><span class="line">    await getUser()</span><br><span class="line">    await getProducts();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="如何实现一个监控，调用异步请求一直等待，监控某个值变了就执行回调"><a href="#如何实现一个监控，调用异步请求一直等待，监控某个值变了就执行回调" class="headerlink" title="如何实现一个监控，调用异步请求一直等待，监控某个值变了就执行回调"></a>如何实现一个监控，调用异步请求一直等待，监控某个值变了就执行回调</h4></blockquote>
<ul>
<li>答：不太清楚你的场景，不过 Vue2 已经做到了这一点，用 Object.defineProperty ,也可以用Proxy方案</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ajax = function()&#123;</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        resolve(&#123;</span><br><span class="line">            data:&#123;name:&apos;a&apos;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var data =&#123;</span><br><span class="line">  name:&apos;sss&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var vm = &#123;&#125;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(vm,&apos;name&apos;,&#123;</span><br><span class="line">  set(newValue)&#123;</span><br><span class="line">    data.name = newValue</span><br><span class="line">  &#125;,</span><br><span class="line">  get()&#123;</span><br><span class="line">      return data.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ajax().then(res=&gt;&#123;</span><br><span class="line">   console.log(res.data);</span><br><span class="line">   vm.name = res.data.name</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="代码题"><a href="#代码题" class="headerlink" title="代码题"></a>代码题</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let a = 0;</span><br><span class="line">let test = async()=&gt;&#123;</span><br><span class="line">    a = a + await 10;</span><br><span class="line">    console.log(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(); </span><br><span class="line">console.log(++a);</span><br><span class="line"></span><br><span class="line">// test 是个异步的 所以不会执行 先去打印</span><br></pre></td></tr></table></figure>
<ul>
<li>答：倒数第二行有坑</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">答案是 </span><br><span class="line">1</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">为什么？是10 你一定认为是 11</span><br><span class="line"></span><br><span class="line">// 改写下代码继续运行 打印 test时 a + </span><br><span class="line">let a = 0;</span><br><span class="line">let test = async()=&gt;&#123;</span><br><span class="line">    a = (console.log(&apos;a:&apos;+ a),a) + await 10;</span><br><span class="line">    console.log(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(); </span><br><span class="line">console.log(++a);</span><br><span class="line"></span><br><span class="line">// 原因就是 我们一直认为 await 的右边会立刻执行 await 是等一会执行的</span><br><span class="line">但是如果他用 加号的时候 就不能这样算 因为你不是 `a + await 10` 而是先确定 a的值</span><br></pre></td></tr></table></figure>
<h4 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h4><ul>
<li><a href="https://juejin.im/post/5cd8e7e251882568b664f459" target="_blank" rel="noopener">async/await 之于 Promise，正如 do 之于 monad（译文）</a></li>
<li>结论就是 Promise 是JS里非常重要的概念，所以我们更应该理解 Promise 而不是 await async</li>
</ul>
<blockquote>
<p>只有在一行代码的情况下</p>
</blockquote>
<ul>
<li>用 await 最好的</li>
<li>如果情况变复杂了，还是要 Promise</li>
<li>并行的情况，也要用 Promise.all</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/Node后端/">Node后端</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2020/03/04/Node-JS专精11-03async-await/" title="Node-JS专精11_03async_await" itemprop="url">Node-JS专精11_03async_await</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Stevin" target="_blank" itemprop="author">Stevin</a>
		
  <p class="article-time">
    <time datetime="2020-03-04T06:15:12.000Z" itemprop="datePublished"> Published 2020-03-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="async-await"><a href="#async-await" class="headerlink" title="async / await"></a>async / await</h3><blockquote>
<p>常用用法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const fn = async () =&gt; &#123;</span><br><span class="line">    // makePromise 返回 promise的函数</span><br><span class="line">    const temp = await makePromise()</span><br><span class="line">    return temp + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这个 makePromise 如果成功了就会返回一个值</span><br><span class="line">// 如果失败了，就会报错，你就必须用 try / catch 才能拿到那个值，但是也不一定后面会说</span><br></pre></td></tr></table></figure>
<blockquote>
<p>优点</p>
</blockquote>
<ul>
<li>完全没有缩进，就像是写同步代码</li>
</ul>
<h4 id="封装一个-async-函数"><a href="#封装一个-async-函数" class="headerlink" title="封装一个 async 函数"></a>封装一个 async 函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">async function 摇骰子()&#123;</span><br><span class="line">  return Math.floor(Math.random()*6)+1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果需要 reject , 直接 throw Error(&apos;xxx&apos;)</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line"></span><br><span class="line">async function fn()&#123;</span><br><span class="line">  const result = await 摇骰子();</span><br><span class="line">  console.log(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果需要处理错误，可以 try catch</span><br><span class="line"></span><br><span class="line">fn(); // 直接打印摇骰子结果</span><br></pre></td></tr></table></figure>
<p><strong>但是如果想要 3秒后得到摇骰子的结果 就就没法直接写，必须有一个 Promise</strong></p>
<blockquote>
<p>实现3秒后摇骰子</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function 摇骰子3秒后()&#123;</span><br><span class="line">  return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">      setTimeout(()=&gt;&#123;</span><br><span class="line">          resolve(Math.floor(Math.random()*6)+1)</span><br><span class="line">      &#125;,3000)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function fn2()&#123;</span><br><span class="line">  const result = await 摇骰子3秒后();</span><br><span class="line">  console.log(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn2()</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="抛出错误-解惑错误"><a href="#抛出错误-解惑错误" class="headerlink" title="抛出错误 / 解惑错误"></a>抛出错误 / 解惑错误</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">async function 摇骰子()&#123;</span><br><span class="line">    throw new Error(&apos;骰子坏了&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function fn()&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        var result = await 摇骰子()</span><br><span class="line">        console.log(result);</span><br><span class="line">    &#125; catch(e)&#123;</span><br><span class="line">        console.log(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>
<h4 id="为什么需要-async"><a href="#为什么需要-async" class="headerlink" title="为什么需要 async"></a>为什么需要 async</h4><ul>
<li>await 所在的函数不就是 async 函数吗？ 但是为什么还是要加上 async声明</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function 摇骰子()&#123;</span><br><span class="line">    throw new Error(&apos;骰子坏了&apos;)</span><br><span class="line">&#125;</span><br><span class="line">// 删掉 async</span><br><span class="line">function fn()&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        var result = await 摇骰子()</span><br><span class="line">        console.log(result);</span><br><span class="line">    &#125; catch(e)&#123;</span><br><span class="line">        console.log(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>
<ul>
<li>原因是在 await出现之前，有些人自己写了 await</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 旧代码，自己实现的 await</span><br><span class="line">function fn()&#123;</span><br><span class="line">    var res = await(摇骰子())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么加了 async</p>
</blockquote>
<ul>
<li>由于那些自己实现 await 的人来说 ，如果 await 不配合 async 直接发布它的代码就不能用，<strong>不兼容</strong></li>
<li>如何兼容呢？ 于是JS设计者想到的是 在外面包一层 来加以区别</li>
<li>最终原因只有一个：<strong>兼容旧代码里，普通函数里的 await(xxx)</strong> 所以在所有出现 await 的地方外面加了一个 async</li>
</ul>
<h4 id="await的错误处理"><a href="#await的错误处理" class="headerlink" title="await的错误处理"></a>await的错误处理</h4><blockquote>
<p>常见方式</p>
</blockquote>
<ul>
<li>一个字：丑</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fn()&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        var result = await axios.get(&apos;/xxx&apos;)</span><br><span class="line">        console.log(result);</span><br><span class="line">    &#125; catch(e)&#123;</span><br><span class="line">        console.log(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="正确姿势"><a href="#正确姿势" class="headerlink" title="正确姿势"></a>正确姿势</h4></blockquote>
<ul>
<li>then 和 await 结合使用，在 then 里处理异步错误， await只接受成功的结果</li>
<li>能处理90%的情况</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const result = await axios.get(&apos;/xxx&apos;).then(null,errorHandler)</span><br><span class="line">console.log(result)</span><br><span class="line">// 错误处理放在 then里面</span><br></pre></td></tr></table></figure>
<blockquote>
<p>细节</p>
</blockquote>
<ul>
<li>可以把 4xx/5xx等常见错误用拦截器全局处理</li>
<li>await只关心成功，失败全部交给 errorHandler</li>
<li>errorHandler 也可以放在拦截器里</li>
</ul>
<p><strong>示例代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ajax = function()&#123;</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        /*</span><br><span class="line">        // 成功处理</span><br><span class="line">        resolve(&#123;</span><br><span class="line">            data:&#123;name:&apos;a&apos;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        */</span><br><span class="line">        reject(&#123;</span><br><span class="line">            response:&#123;status:403&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var error = (e)=&gt;&#123;</span><br><span class="line">    console.log(e)</span><br><span class="line">    console.log(&apos;提示用户没有权限&apos;)</span><br><span class="line">    throw e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function fn()&#123;</span><br><span class="line">    const response = await ajax().then(null,error)</span><br><span class="line">    console.log(response) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>
<h4 id="await-的传染性"><a href="#await-的传染性" class="headerlink" title="await 的传染性"></a>await 的传染性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(1)</span><br><span class="line">await console.log(2)</span><br><span class="line">console.log(3)</span><br><span class="line"></span><br><span class="line">导致 3 要等一会才被打印，因为有 await, 导致它下面的代码变成异步任务</span><br></pre></td></tr></table></figure>
<blockquote>
<p>分析</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(3) 变成异步任务了</span><br><span class="line">Promise 同样具有传染性 (同步变异步)</span><br><span class="line">谁没有传染性 ： 回调</span><br></pre></td></tr></table></figure>
<h4 id="await-应用场景"><a href="#await-应用场景" class="headerlink" title="await 应用场景"></a>await 应用场景</h4><blockquote>
<p>多次处理一个结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const s1 = await makePromise();</span><br><span class="line">const s2 = handlerR1(r1)</span><br><span class="line">const s3 = handlerR2(r2)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>串行</p>
</blockquote>
<ul>
<li><p>天生串行</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async function fn()&#123;</span><br><span class="line">    await ajax1();</span><br><span class="line">    await ajax2();</span><br><span class="line">    await ajax3();</span><br><span class="line">    await ajax4();</span><br><span class="line">    await ajax5();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>循环的时候有 bug </p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 实际上它是并行的</span><br><span class="line">async function fn()&#123;</span><br><span class="line">    var array = [ajax1, ajax2, ajax3]</span><br><span class="line">    for(let i=0;i&lt;array.length;i++)&#123;</span><br><span class="line">        await array[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">跟你直接这样 不一样</span><br><span class="line">await ajax1();</span><br><span class="line">await ajax2();</span><br><span class="line">await ajax3();</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 用 await 循环</span><br><span class="line">搜索关键字 for-await-of</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>并行</p>
</blockquote>
<ul>
<li>await Promise.all() 就是并行了</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/Node后端/">Node后端</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2020/03/04/Node-JS专精11-02Promise使用场景/" title="Node-JS专精11_02Promise使用场景" itemprop="url">Node-JS专精11_02Promise使用场景</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Stevin" target="_blank" itemprop="author">Stevin</a>
		
  <p class="article-time">
    <time datetime="2020-03-04T03:23:03.000Z" itemprop="datePublished"> Published 2020-03-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="Promise使用场景"><a href="#Promise使用场景" class="headerlink" title="Promise使用场景"></a>Promise使用场景</h3><h4 id="多次处理一个结果"><a href="#多次处理一个结果" class="headerlink" title="多次处理一个结果"></a>多次处理一个结果</h4><ul>
<li><code>摇骰子.then(v =&gt; v1).then(v1 =&gt; v2)</code><ul>
<li>1 2 3 返回小 / 4 5 6 返回大</li>
</ul>
</li>
<li>在BOSS直聘上投递阿里简历流程： <ul>
<li>必须先有网</li>
<li>有网才能使用 BOSS直聘app或 pc</li>
<li>登录</li>
<li>从众多公司里搜索 阿里的 岗位</li>
<li>投递简历</li>
</ul>
</li>
</ul>
<h4 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h4><blockquote>
<p>一道网传面试题</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">页面有两个按A和B,以及一个输入框，</span><br><span class="line">A按钮点击后发送一个请求，返回一个字符串A</span><br><span class="line">B按钮点击后也发送一个请求，返回一个字符串B</span><br><span class="line">返回后会把返回的字符串赋值给输入框，但是 A 和 B发送的请求时间点不同，</span><br><span class="line">点击按钮的顺序也不一定，B要比A先返回，而最终效果要求是 输入框字符的顺序是 AB</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这道题实际就是日常你做的如下需求</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">你打开了  百度搜索，先输入 vue,(此时已经发送了 请求a ) ,然后输入 react (此时已经发送了 请求b)</span><br><span class="line"></span><br><span class="line">好巧不巧的是  请求a 10秒返回结果  请求b 1秒返回结果</span><br><span class="line">此时 你如果按照正常的展示逻辑</span><br><span class="line"></span><br><span class="line">你肯定先展示 react的结果 ， 然后在展示 vue的结果</span><br><span class="line">此时用户觉得你神经病 ， 我明明搜的 react 你给我展示 vue的结果</span><br><span class="line"></span><br><span class="line">此时你就要保证就算 react的结果先回来，我也要等到 vue的结果展示了之后在展示</span><br></pre></td></tr></table></figure>
<p>正确处理的姿势：只要有一个结果返回了 就把之前的请求取消掉 ajax.cancel</p>
<blockquote>
<p>生活中的高铁进站例子</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a 和 b 两个人，分别去高铁app上买了去 北京的票 如C2212</span><br><span class="line">b 比 a先买到票，但是检票的时候，a站在 b前面。</span><br><span class="line">所以 无论如何，b都要在 a之后进入车厢</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码实例</p>
</blockquote>
<ul>
<li>点击 a 按钮后立刻点击 b按钮</li>
<li>3秒后 输入框显示 “bbb”  </li>
<li>5秒后显示 “aaa”</li>
</ul>
<p><strong>我们想要的结果是，不管那个结果回来，都最后显示”bbb”</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button id=&quot;a&quot;&gt;a&lt;/button&gt;</span><br><span class="line">&lt;button id=&quot;b&quot;&gt;b&lt;/button&gt;</span><br><span class="line">&lt;input id=&quot;input&quot; type=&quot;text&quot;&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">let ajax1 = function()&#123;</span><br><span class="line">  return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">      resolve(&quot;aaa&quot;)</span><br><span class="line">    &#125;,5000)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let ajax2 = function()&#123;</span><br><span class="line">  return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">      resolve(&quot;bbbb&quot;)</span><br><span class="line">    &#125;,3000)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.onclick = ()=&gt;&#123;</span><br><span class="line">  ajax1().then((s)=&gt;&#123;</span><br><span class="line">    input.value = s</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b.onclick = ()=&gt;&#123;</span><br><span class="line">  ajax2().then((s)=&gt;&#123;</span><br><span class="line">    input.value = s</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;  </span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>生活中的点餐取餐例子</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">餐厅有两个窗口 点餐 / 取餐</span><br><span class="line">a 和 b 两个人 先后进入餐厅的点餐队列进行点餐 a 在 b 之前点餐了</span><br><span class="line">a 点餐制作耗时 15分钟</span><br><span class="line">b 点餐制作耗时 10分钟</span><br><span class="line"></span><br><span class="line">a 和 b 点餐完成后， 又依次站在 取餐队列里 a在 b之前</span><br><span class="line">10分钟后 b的餐好了，</span><br><span class="line">但是 a 在 b之前， b 无法取餐</span><br><span class="line">15分钟 a 的餐好了</span><br><span class="line">a 取餐成功</span><br><span class="line">于是轮到 b ， b取餐成功</span><br></pre></td></tr></table></figure>
<p>代码示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button id=&quot;a&quot;&gt;a&lt;/button&gt;</span><br><span class="line">&lt;button id=&quot;b&quot;&gt;b&lt;/button&gt;</span><br><span class="line">&lt;input id=&quot;input&quot; type=&quot;text&quot;&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">let ajax1 = function()&#123;</span><br><span class="line">  return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">      resolve(&quot;aaa&quot;)</span><br><span class="line">    &#125;,5000)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let ajax2 = function()&#123;</span><br><span class="line">  return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">      resolve(&quot;bbbb&quot;)</span><br><span class="line">    &#125;,3000)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var 取餐队伍 = [];</span><br><span class="line">var 吧台 = [];</span><br><span class="line">var 问 = ()=&gt;&#123;</span><br><span class="line">  var lastN = 吧台[吧台.length -1][0];</span><br><span class="line">  var lastS = 吧台[吧台.length -1][1];</span><br><span class="line">  if(取餐队伍[0][0] === lastN)&#123;</span><br><span class="line">    取餐队伍[0][1](lastS);</span><br><span class="line">    取餐队伍.shift();</span><br><span class="line">    吧台.pop();</span><br><span class="line">    问();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.onclick = ()=&gt;&#123;</span><br><span class="line">  let n = Math.random();</span><br><span class="line">  ajax1().then((s)=&gt;&#123;</span><br><span class="line">    吧台.push([n,s])</span><br><span class="line">    问();</span><br><span class="line">  &#125;)</span><br><span class="line">  取餐队伍.push([n,(s)=&gt;&#123;</span><br><span class="line">    input.value = s;</span><br><span class="line">  &#125;])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b.onclick = ()=&gt;&#123;</span><br><span class="line">  let n = Math.random();</span><br><span class="line">  ajax2().then((s)=&gt;&#123;</span><br><span class="line">    吧台.push([n,s])</span><br><span class="line">    问();</span><br><span class="line">  &#125;)</span><br><span class="line">  取餐队伍.push([n,(s)=&gt;&#123;</span><br><span class="line">    input.value = s;</span><br><span class="line">  &#125;])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h4 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h4><ul>
<li>Promise.all([task1,task2]) 不好用(可以自己写一个，参考上一篇文章)</li>
<li>Promise.allSettled 又太新</li>
</ul>
<h3 id="Promise的错误处理"><a href="#Promise的错误处理" class="headerlink" title="Promise的错误处理"></a>Promise的错误处理</h3><blockquote>
<p>其实挺好用的</p>
</blockquote>
<ul>
<li>promise.then(s1,f1) 即可</li>
<li>如果我想全局处理(以 axios 为例 参考它的拦截器)<ul>
<li><a href="https://juejin.im/post/5a9cddb46fb9a028bc2d3c2f" target="_blank" rel="noopener">axios 作弊表</a> 拦截器章节<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.response.use(function (response) &#123;</span><br><span class="line">    // Do something with response data</span><br><span class="line">    return response;</span><br><span class="line">&#125;, function (error) &#123;</span><br><span class="line">    // Do something with response error</span><br><span class="line">    return Promise.reject(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>语法糖</p>
</blockquote>
<ul>
<li><code>promise.then(s1).catch(f1)</code></li>
</ul>
<blockquote>
<p>错误处理之后</p>
</blockquote>
<ul>
<li>如果你没有继续抛错，那么错误不再出现</li>
<li>如果你继续抛出错误， 那么后续回调就继续处理错误</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// </span><br><span class="line">Promise.resolve(`&#123;&apos;name&apos;:&apos;frank&apos;&#125;`)</span><br><span class="line">    .then( s =&gt; JSON.parse(s)) // parse 失败 json 的 key必须是双引号</span><br><span class="line">    .then( null, (reason) =&gt; console.log(&quot;err:&quot; + reason)) // 继续 promise 里处理</span><br></pre></td></tr></table></figure>
<h4 id="但是有人对-Promise-不满意"><a href="#但是有人对-Promise-不满意" class="headerlink" title="但是有人对 Promise 不满意"></a>但是有人对 Promise 不满意</h4><ul>
<li><a href="https://blog.fundebug.com/2017/04/04/nodejs-async-await/" target="_blank" rel="noopener">Async/Await替代Promise的6个理由</a></li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/Node后端/">Node后端</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2020/03/04/Node-JS专精11-01Promise精讲/" title="Node-JS专精11_01Promise精讲" itemprop="url">Node-JS专精11_01Promise精讲</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Stevin" target="_blank" itemprop="author">Stevin</a>
		
  <p class="article-time">
    <time datetime="2020-03-04T01:33:52.000Z" itemprop="datePublished"> Published 2020-03-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><blockquote>
<p>先看代码</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function 摇骰子()&#123;</span><br><span class="line">    return new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            const result = Math.floor(Math.random()*6+1)</span><br><span class="line">            resolve(result)</span><br><span class="line">        &#125;, 3000);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 摇骰子() // 此时返回的是一个 promise</span><br><span class="line"></span><br><span class="line">摇骰子().then((res)=&gt;&#123;console.log(res)&#125;) // 3秒后返回摇骰子的结果</span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="这是一个异步任务，那么问题来了-异步任务什么时候执行？"><a href="#这是一个异步任务，那么问题来了-异步任务什么时候执行？" class="headerlink" title="这是一个异步任务，那么问题来了 异步任务什么时候执行？"></a>这是一个异步任务，那么问题来了 异步任务什么时候执行？</h3></blockquote>
<ul>
<li>改写了一下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function 摇骰子()&#123;</span><br><span class="line">    return new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">        const result = Math.floor(Math.random()*6+1)</span><br><span class="line">        resolve(result)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">摇骰子().then((res)=&gt;&#123;console.log(res)&#125;)  // 会立刻返回 摇骰子的结果，但是它是什么时候开始呢？</span><br></pre></td></tr></table></figure>
<h3 id="面试中的-微任务-宏任务"><a href="#面试中的-微任务-宏任务" class="headerlink" title="面试中的 微任务/宏任务"></a>面试中的 微任务/宏任务</h3><p>看这样一段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button id=&quot;btn1&quot;&gt;btn1&lt;/button&gt;</span><br><span class="line">&lt;button id=&quot;btn2&quot;&gt;btn2&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">// Promise</span><br><span class="line">function 摇骰子()&#123;</span><br><span class="line">  return new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">      const result = Math.floor(Math.random()*6+1)</span><br><span class="line">      resolve(result)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btn1.onclick=()=&gt;&#123;</span><br><span class="line">  摇骰子().then(n=&gt;console.log(`摇到了$&#123;n&#125;`))</span><br><span class="line">  console.log(&quot;end&quot;);</span><br><span class="line">  // 执行结果：很明显 我们知道  摇骰子 是异步任务 所以会晚于 同步代码 console.log</span><br><span class="line">  /*</span><br><span class="line">  &quot;end&quot;</span><br><span class="line">  &quot;摇到了1&quot;</span><br><span class="line">  */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btn2.onclick=()=&gt;&#123;</span><br><span class="line">  setTimeout(()=&gt;&#123;console.log(&quot;timeout1&quot;),0&#125;)</span><br><span class="line">  摇骰子().then(n=&gt;console.log(`摇到了$&#123;n&#125;`))</span><br><span class="line">  setTimeout(()=&gt;&#123;console.log(&quot;timeout2&quot;),0&#125;)</span><br><span class="line">  // 执行结果</span><br><span class="line">  // 如果我们还有其他的异步任务 比如 setTimeout 那么谁会优先呢？</span><br><span class="line">  // 答案是 先打出骰子的点数</span><br><span class="line">  /*</span><br><span class="line">  &quot;摇到了1&quot;</span><br><span class="line">  &quot;timeout1&quot;</span><br><span class="line">  &quot;timeout2&quot;</span><br><span class="line">  */</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h4 id="微任务-宏任务这些前端名词的前因后果"><a href="#微任务-宏任务这些前端名词的前因后果" class="headerlink" title="微任务/宏任务这些前端名词的前因后果"></a>微任务/宏任务这些前端名词的前因后果</h4><ul>
<li>本来是没有 Promise的 在 ES6之前，ES6之后才有了 Promise这种异步</li>
<li>以前的JS非常单纯只有两个东西<ul>
<li>当前任务 执行的代码(同步代码) </li>
<li>延时任务 setTimeout / setInterval</li>
</ul>
</li>
</ul>
<blockquote>
<h4 id="ES6以前"><a href="#ES6以前" class="headerlink" title="ES6以前"></a>ES6以前</h4></blockquote>
<ul>
<li>当前代码 如<code>console.log(1)</code></li>
<li>异步队列 setTimeout </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">console.log(1)</span><br><span class="line">console.log(2)</span><br><span class="line">setTimeout(()=&gt;&#123;console.log(&quot;timeout 1&quot;)&#125;,0)</span><br><span class="line">setTimeout(()=&gt;&#123;console.log(&quot;timeout 2&quot;)&#125;,0)</span><br><span class="line">console.log(3)</span><br><span class="line">console.log(4)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">timeout 1</span><br><span class="line">timeout 2</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">两次 setTimeout 不会立刻执行，而是放入异步队列里</span><br><span class="line">当前代码执行完了 就去看异步队列了</span><br></pre></td></tr></table></figure>
<p><strong>所以以前的js非常好理解，就是我有个当前要执行的任务，和有个等待执行的任务</strong></p>
<blockquote>
<h4 id="ES6之后"><a href="#ES6之后" class="headerlink" title="ES6之后"></a>ES6之后</h4></blockquote>
<p>前端觉得回调太蛋疼了，于是加了个 Promise</p>
<ul>
<li>宏任务 – 异步队列1（原来的异步队列 setTimeout）</li>
<li>微任务 – 异步队列2 (Promise 使用)</li>
<li>同步代码 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 伪代码</span><br><span class="line">ajax.then(s1)</span><br><span class="line">setTimeout(()=&gt;&#123;console.log(&quot;timeout&quot;)&#125;,0)</span><br><span class="line">console.log(1);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">依然  console.log 放入同步任务</span><br><span class="line">setTimeout 放入异步任务</span><br><span class="line"></span><br><span class="line">此时 ，如果不引入其他东西 ajax.then(s1) 就显得特别智障</span><br><span class="line">    假设只有一个异步任务 那么实际就是 把 s1 加入异步队列1 ， 然后把第二行的 setTimeout 加入异步队列1 s1之后</span><br><span class="line"></span><br><span class="line">    于是你惊讶的发现，那我要 then 干什么，有病吧？ 直接 setTimeout(s1,0) 不就完了</span><br><span class="line"></span><br><span class="line">所以他们就想了一个 让我们的 then 更有用的办法 ，在加一个 异步队列2</span><br><span class="line"></span><br><span class="line">于是乎上面的代码</span><br><span class="line">s1 放入 异步队列2</span><br><span class="line">setTimeout 放入 异步队列1</span><br><span class="line"></span><br><span class="line">当 同步代码执行完</span><br><span class="line">先去读取 异步队列2 里的任务 去执行</span><br><span class="line">等 异步队列2 里的任务执行完了， 再去读取 异步队列1 里的任务 去执行</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p><strong>于是分别给 异步队列1 / 异步队列2 取了个名字叫做 宏任务 / 微任务</strong></p>
<p><strong>如果队列里有任务，先把 微任务 做完，再去做 宏任务</strong></p>
<h3 id="Promise-其他API"><a href="#Promise-其他API" class="headerlink" title="Promise 其他API"></a>Promise 其他API</h3><blockquote>
<p>继续以摇骰子为例</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function 摇骰子()&#123;</span><br><span class="line">  return new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">      const result = Math.floor(Math.random()*6+1)</span><br><span class="line">      resolve(result)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// 随机的</span><br><span class="line">摇骰子().then((res)=&gt;&#123;console.log(res)&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Promise.resolve(result) 制造一个成功(或失败)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 制造成功</span><br><span class="line">// 你想造假一直 摇6</span><br><span class="line"></span><br><span class="line">function 摇6的骰子()&#123;</span><br><span class="line">  return new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">      resolve(6)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function 摇6的骰子2()&#123;</span><br><span class="line">  return  Promise.resolve(6)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 摇6的骰子</span><br><span class="line">// 摇6的骰子().then((res)=&gt;&#123;console.log(res)&#125;)</span><br><span class="line">// 摇6的骰子2().then((res)=&gt;&#123;console.log(res)&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 制造失败</span><br><span class="line">function 摇骰子返回失败()&#123;</span><br><span class="line">  return  Promise.resolve(</span><br><span class="line">              new Promise((resolve,reject)=&gt;reject())</span><br><span class="line">          )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">摇骰子返回失败().then((res)=&gt;&#123;console.log(res)&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Promise.reject(reason) 制造一个失败</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function 摇坏的骰子()&#123;</span><br><span class="line">    return new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">        reject(&apos;坏了&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function 摇坏的骰子2()&#123;</span><br><span class="line">    return Promise.reject(&apos;坏了&apos;)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">摇坏的骰子().then(null,(reason)=&gt;console.log(reason))</span><br><span class="line">摇坏的骰子2().then(null,(reason)=&gt;console.log(reason))</span><br></pre></td></tr></table></figure>
</li>
<li><p>Promise.all(数组) 等待全部成功，或有一个失败</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 所有人都成功了，才叫成功 返回所有成功的结果</span><br><span class="line">Promise.all([Promise.resolve(1),Promise.resolve(2),Promise.resolve(3)]).then((res)=&gt;&#123;console.log(res)&#125;)</span><br><span class="line">// 打印 [1,2,3]</span><br><span class="line"></span><br><span class="line">// 某个失败 返回失败</span><br><span class="line">Promise.all([Promise.resolve(1),Promise.resolve(2),Promise.reject(&apos;错了3&apos;)]).then((res)=&gt;&#123;console.log(res)&#125;,(err)=&gt;&#123;console.log(err)&#125;)</span><br><span class="line">// 打印 &quot;错了3&quot;</span><br><span class="line"></span><br><span class="line">Promise.all([Promise.resolve(1&quot;),Promise.reject(&apos;错了2&apos;),Promise.reject(&apos;错了3&apos;)]).then((res)=&gt;&#123;console.log(res)&#125;,(err)=&gt;&#123;console.log(err)&#125;)</span><br><span class="line">// 打印 &quot;错了2&quot;</span><br><span class="line"></span><br><span class="line">Promise.all([Promise.reject(&quot;错了1&quot;),Promise.reject(&apos;错了2&apos;),Promise.reject(&apos;错了3&apos;)]).then((res)=&gt;&#123;console.log(res)&#125;,(err)=&gt;&#123;console.log(err)&#125;)</span><br><span class="line">// 打印 &quot;错了1&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>所以 Promise.all 非常没用,因为有一个失败就返回了不等所有的结果</li>
<li>请使用 <code>Promise.allSettled</code></li>
</ul>
</li>
<li><p>Promise.race(数组) 等待第一个状态改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同时发很多请求，只要又一个成功了，就成功，或者一个失败了就失败</span><br></pre></td></tr></table></figure>
</li>
<li><p>Promise.allSettled(数组) 等待全部状态改变,目前处于 Stage-4(板上钉钉的实现)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Promise.allSettled([Promise.resolve(1),Promise.resolve(2),Promise.resolve(3)]).then((res)=&gt;&#123;console.log(res)&#125;,(err)=&gt;&#123;console.log(err)&#125;)</span><br><span class="line">// resolve 打印</span><br><span class="line">/*</span><br><span class="line">[</span><br><span class="line">  &#123;status: &quot;fulfilled&quot;, value: 1&#125;,</span><br><span class="line">  &#123;status: &quot;fulfilled&quot;, value: 2&#125;,</span><br><span class="line">  &#123;status: &quot;fulfilled&quot;, value: 3&#125;</span><br><span class="line">]</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">Promise.allSettled([Promise.resolve(1),Promise.reject(&apos;错了2&apos;),Promise.resolve(3)]).then((res)=&gt;&#123;console.log(res)&#125;,(err)=&gt;&#123;console.log(err)&#125;)</span><br><span class="line">// reject 打印</span><br><span class="line">/*</span><br><span class="line">[</span><br><span class="line">  &#123;status: &quot;fulfilled&quot;, value: 1&#125;,</span><br><span class="line">  &#123;status: &quot;rejected&quot;, reason: &quot;错了2&quot;&#125;,</span><br><span class="line">  &#123;status: &quot;fulfilled&quot;, value: 3&#125;</span><br><span class="line">]</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">Promise.allSettled([Promise.reject(&quot;错了1&quot;),Promise.reject(&apos;错了2&apos;),Promise.reject(&apos;错了3&apos;)]).then((res)=&gt;&#123;console.log(res)&#125;,(err)=&gt;&#123;console.log(err)&#125;)</span><br><span class="line"></span><br><span class="line">// reject 打印</span><br><span class="line">/*</span><br><span class="line">[</span><br><span class="line">  &#123;status: &quot;rejected&quot;, reason: &quot;错了1&quot;&#125;,</span><br><span class="line">  &#123;status: &quot;rejected&quot;, reason: &quot;错了2&quot;&#125;,</span><br><span class="line">  &#123;status: &quot;rejected&quot;, reason: &quot;错了3&quot;&#125;</span><br><span class="line">]</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>由于<code>Promise.allSettled</code>很多浏览器不支持，我们依旧无法使用</p>
</blockquote>
<p>所以用 Promise.all 实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">// 假设还是三个 promise 任务  第一个和第二个会失败</span><br><span class="line">task1 = () =&gt; new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">  setTimeout(()=&gt;&#123;</span><br><span class="line">    reject(&quot;第一扇门关了&quot;)</span><br><span class="line">  &#125;,3000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">task2 = () =&gt; new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">  setTimeout(()=&gt;&#123;</span><br><span class="line">    reject(&quot;第二扇门关了&quot;)</span><br><span class="line">  &#125;,4000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">task3 = () =&gt; new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">  setTimeout(()=&gt;&#123;</span><br><span class="line">    resolve(&quot;第三扇门开了&quot;)</span><br><span class="line">  &#125;,5000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 如果这样</span><br><span class="line">// 发现第一个失败就 结束了</span><br><span class="line">Promise.all([task1(),task2(),task3()])</span><br><span class="line">  .then(null,(reason)=&gt;console.log(reason))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 正确姿势 把每个任务都 then一下 因为 Promise.then 会返回新的 promise</span><br><span class="line">Promise.all([</span><br><span class="line">          task1().then(()=&gt;(&#123;&quot;status&quot;:&quot;ok&quot;&#125;),()=&gt;(&#123;status:&quot;not ok&quot;&#125;)),</span><br><span class="line">          task2().then(()=&gt;(&#123;&quot;status&quot;:&quot;ok&quot;&#125;),()=&gt;(&#123;status:&quot;not ok&quot;&#125;)),</span><br><span class="line">          task3().then(()=&gt;(&#123;&quot;status&quot;:&quot;ok&quot;&#125;),()=&gt;(&#123;status:&quot;not ok&quot;&#125;)),</span><br><span class="line">          ])</span><br><span class="line">  .then((result)=&gt;console.log(result))</span><br><span class="line">/*</span><br><span class="line">[</span><br><span class="line">  &#123;status: &quot;not ok&quot;&#125;,</span><br><span class="line">  &#123;status: &quot;not ok&quot;&#125;,</span><br><span class="line">  &#123;status: &quot;ok&quot;&#125;</span><br><span class="line">]</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 优化代码 因为写的太重复了  </span><br><span class="line">setSuccessResult = (promise) =&gt; promise.then(</span><br><span class="line">                                        (value)=&gt;(&#123;status:&quot;ok&quot;,value&#125;),</span><br><span class="line">                                        (reason)=&gt;(&#123;status:&quot;not ok&quot;,reason&#125;),</span><br><span class="line">                                        )</span><br><span class="line">Promise.all([</span><br><span class="line">          setSuccessResult(task1()),</span><br><span class="line">          setSuccessResult(task2()),</span><br><span class="line">          setSuccessResult(task3()),</span><br><span class="line">          ])</span><br><span class="line">  .then((result)=&gt;console.log(result))                                     </span><br><span class="line">// 打印结果</span><br><span class="line">/*</span><br><span class="line">[</span><br><span class="line">  &#123;status: &quot;not ok&quot;, reason: &quot;第一扇门关了&quot;&#125;</span><br><span class="line">  &#123;status: &quot;not ok&quot;, reason: &quot;第二扇门关了&quot;&#125;</span><br><span class="line">  &#123;status: &quot;ok&quot;, value: &quot;第三扇门开了&quot;&#125;</span><br><span class="line">]</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 还能再次简化</span><br><span class="line">setSuccessResultList = (promiseList) =&gt; promiseList.map(</span><br><span class="line">  promise =&gt; promise.then(</span><br><span class="line">                         (value)=&gt;(&#123;status:&quot;ok&quot;,value&#125;),</span><br><span class="line">                         (reason)=&gt;(&#123;status:&quot;not ok&quot;,reason&#125;)</span><br><span class="line">                        )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">Promise.all(setSuccessResultList([task1(),task2(),task3()]))</span><br><span class="line">  .then((result)=&gt;console.log(result))  </span><br><span class="line"></span><br><span class="line">// 再次简化 你不是不支持  Promise.allSettled 吗？</span><br><span class="line">Promise.allSettled2 = function(promiseList)&#123;</span><br><span class="line">  return Promise.all(setSuccessResultList(promiseList))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这其实就是 allSettled2 的实现</span><br><span class="line">Promise.allSettled2([task1(),task2(),task3()])</span><br><span class="line">  .then((result)=&gt;console.log(result))</span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/Node后端/">Node后端</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/3/"><span></span>Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/53/">53</a><a class="extend next" rel="next" href="/page/5/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  

  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/oak/" title="oak">oak<sup>71</sup></a></li>
			
		
			
				<li><a href="/tags/前端知识点/" title="前端知识点">前端知识点<sup>43</sup></a></li>
			
		
			
				<li><a href="/tags/java/" title="java">java<sup>37</sup></a></li>
			
		
			
				<li><a href="/tags/Node后端/" title="Node后端">Node后端<sup>36</sup></a></li>
			
		
			
				<li><a href="/tags/M06/" title="M06">M06<sup>29</sup></a></li>
			
		
			
				<li><a href="/tags/fullstack/" title="fullstack">fullstack<sup>27</sup></a></li>
			
		
			
				<li><a href="/tags/M07/" title="M07">M07<sup>27</sup></a></li>
			
		
			
				<li><a href="/tags/python/" title="python">python<sup>26</sup></a></li>
			
		
			
				<li><a href="/tags/M08/" title="M08">M08<sup>25</sup></a></li>
			
		
			
				<li><a href="/tags/ReactWheels/" title="ReactWheels">ReactWheels<sup>24</sup></a></li>
			
		
			
				<li><a href="/tags/M04/" title="M04">M04<sup>22</sup></a></li>
			
		
			
				<li><a href="/tags/M03/" title="M03">M03<sup>20</sup></a></li>
			
		
			
				<li><a href="/tags/M02/" title="M02">M02<sup>17</sup></a></li>
			
		
			
				<li><a href="/tags/React入门/" title="React入门">React入门<sup>17</sup></a></li>
			
		
			
				<li><a href="/tags/TS入门/" title="TS入门">TS入门<sup>16</sup></a></li>
			
		
			
				<li><a href="/tags/CSS/" title="CSS">CSS<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/ES6速学/" title="ES6速学">ES6速学<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/M01/" title="M01">M01<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/vue/" title="vue">vue<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/mongodb/" title="mongodb">mongodb<sup>7</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=&verifier=b3593ceb&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Larry Page in Google. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2176287895" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2021 
		
		<a href="/about" target="_blank" title="Stevin">Stevin</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>












<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
