<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Almost</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Almost">
<meta property="og:url" content="http://yoursite.com/page/15/index.html">
<meta property="og:site_name" content="Almost">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Almost">
  
    <link rel="alternate" href="/atom.xml" title="Almost" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Almost</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-ZB-014-java接口和抽象类01" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/09/ZB-014-java接口和抽象类01/" class="article-date">
  <time datetime="2019-07-09T12:54:18.000Z" itemprop="datePublished">2019-07-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/09/ZB-014-java接口和抽象类01/">ZB-014-java接口和抽象类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><a href="https://sltrust.github.io/2019/05/14/Java-010-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BA%8C/" target="_blank" rel="noopener">参考链接</a></li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul>
<li>不可实例化<ul>
<li>反证法：假如我们允许实例化抽象类的实例，那么该实例调用抽象方法是怎样的？没有方法体？</li>
</ul>
</li>
<li>可以实例化的东西一定要补全所有的方法体</li>
<li>可以包含抽象方法</li>
<li>可以包含成员变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Animal&#123;</span><br><span class="line">    public abstract void 跑();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Bird extends Animal&#123;</span><br><span class="line">    public void 跑()&#123;</span><br><span class="line">        // 跑的实现逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li>接口部分的实现了多继承</li>
<li>接口不是类</li>
<li>接口的扩展</li>
<li>接口只代表一种功能</li>
<li>一个类只能继承一个类，但是却能实现若干的接口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface Aaa &#123;</span><br><span class="line">    // 接口里的成员默认是 public static final </span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">    int a = 1;</span><br><span class="line">    等价于</span><br><span class="line">    public static final  int a = 1;</span><br><span class="line">    而我们知道 final的应该大写</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    // 所以正确的写法应该是</span><br><span class="line">    int A = 1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="接口可以包含什么"><a href="#接口可以包含什么" class="headerlink" title="接口可以包含什么"></a>接口可以包含什么</h4><ul>
<li>若干个方法(默认 public)</li>
<li>若干个常量(默认 public static final)</li>
<li>extends 接口</li>
<li>默认方法<ul>
<li>Since Java8</li>
<li>一种妥协的产物</li>
<li>可以用来实现 minxin</li>
<li>菱形继承</li>
</ul>
</li>
</ul>
<blockquote>
<p>在经典的接口里，java8之前，接口里的方法不能有方法体的 java8之后可以了</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">在 C++ 中 允许多继承</span><br><span class="line">class A&#123;</span><br><span class="line">    f()&#123; ....&#125;</span><br><span class="line">&#125;</span><br><span class="line">class B&#123;</span><br><span class="line">    f()&#123; ....&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C extends A,B&#123;</span><br><span class="line">    // </span><br><span class="line">&#125;</span><br><span class="line">// 菱形继承</span><br><span class="line">new C().f(); // 调用的是谁？此时产生了歧义</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 而 java 是单根继承(不够灵活)，于是提出了 “接口”允许多实现。</span><br><span class="line">// 把接口的功能理解为一种能力</span><br><span class="line">// 那如何区分 类继承体系和接口呢？</span><br><span class="line">// 假设你是个老板Boss 你想找几个人干活，对于class来说就是找几个“人”来干活</span><br><span class="line">// 对于interface来说就是 找几个“能干活”的人来</span><br><span class="line">interface A&#123;</span><br><span class="line">    f();</span><br><span class="line">&#125;</span><br><span class="line">interface B&#123;</span><br><span class="line">    f();</span><br><span class="line">&#125;</span><br><span class="line">class C implements A,B&#123;</span><br><span class="line">    f()&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 而在java8 之后，这种现象被改变了。妥协了</span><br><span class="line">// 当一个接口发布出去 就不能在改了，不能增添或减少成员，因为一旦成型，再次添加方法后，导致所有实现类都报错。必须实现接口的所有方法。</span><br><span class="line"></span><br><span class="line">// 由于这种向后兼容性。所以这种发布之后，再也不修改的情况是个天真的想法——人的认知是有限的</span><br><span class="line">// 所以在 java 工作体系运行20年之后，突然发现某些接口 如 List 想给当年的List添加一个 sort(); 但是很不幸 你不能打破“向后兼容性”， 这样导致 List的实现类全报错了，必须实现 sort方法才行，问题升级，你老板非要实现，但是你要该 N 多地方。</span><br><span class="line"></span><br><span class="line">// 于是产生了一个妥协的产物——默认方法</span><br><span class="line">这个 sort 就在 List 中</span><br><span class="line">// 因为无法变成抽象方法，所以必须写实现，所以 sort 有一个默认的实现使得之前没有实现 sort方法的实现类也能正常工作</span><br><span class="line"></span><br><span class="line">default void sort(Comparator&lt;? super E&gt; c)&#123;</span><br><span class="line">    Object[] a = this.toArray();</span><br><span class="line">    Array.sort(a,(Comparator) c);</span><br><span class="line">    ListIterator&lt;E&gt; i = this.listIterator();</span><br><span class="line">    for(Object e : a)&#123;</span><br><span class="line">        i.next();</span><br><span class="line">        i.set((E) e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4></blockquote>
<ul>
<li><p>java8 之前</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface A&#123;</span><br><span class="line">    void a();</span><br><span class="line">    void b();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>java8 之后</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface A&#123;</span><br><span class="line">    void a();</span><br><span class="line">    void b();</span><br><span class="line">    default void  c()&#123;</span><br><span class="line">        // 实现</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 这样原来实现 A 接口的实现类就可以得到兼容</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<h4 id="java8-接口默认方法引出的问题"><a href="#java8-接口默认方法引出的问题" class="headerlink" title="java8 接口默认方法引出的问题"></a>java8 接口默认方法引出的问题</h4></blockquote>
<ul>
<li>当年极力避免的 <code>C++ 的多继承，导致父类有相同f();的问题出现了</code></li>
<li>当年极力避免的 <strong>“二义性”</strong> 现在又妥协了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">interface A&#123;</span><br><span class="line">    void a();</span><br><span class="line">    default void  c()&#123;</span><br><span class="line">        // 实现</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface B&#123;</span><br><span class="line">    void a();</span><br><span class="line">    default void  c()&#123;</span><br><span class="line">        // 实现</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C implatements A,B&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        c(); // 此时报错了</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="接口和抽象类总结"><a href="#接口和抽象类总结" class="headerlink" title="接口和抽象类总结"></a>接口和抽象类总结</h3><blockquote>
<p>共同点</p>
</blockquote>
<ul>
<li>抽象的，不可实例化</li>
<li>可包含抽象方法(没有方法体，非 static/private/final )</li>
</ul>
<blockquote>
<p>不同点</p>
</blockquote>
<ul>
<li>抽象类是类可以包含类的一切，接口只能包含受限的成员(public static final)和方法(public abstract,java8之后可以 default的)</li>
<li>抽象类只能单一继承，接口可以多实现</li>
</ul>
<blockquote>
<p>instanceof 不仅能检查是不是一个类的实例还可以检测是不是一个接口实现类的实例</p>
</blockquote>
<blockquote>
<p>什么是 API(application program interface)</p>
</blockquote>
<blockquote>
<p>什么是UI(User interface)</p>
</blockquote>
<h4 id="多态实战"><a href="#多态实战" class="headerlink" title="多态实战"></a>多态实战</h4><p>Files.walkFileTree 当你用一个不知道意思的方法的时候，你最好看一下JDK文档 JDK的文档是最好的教材</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Walks a file tree.</span><br><span class="line">    *</span><br><span class="line">    * &lt;p&gt; This method walks a file tree rooted at a given starting file. The</span><br><span class="line">    * file tree traversal is &lt;em&gt;depth-first&lt;/em&gt; with the given &#123;@link</span><br><span class="line">    * FileVisitor&#125; invoked for each file encountered. 看到这就够了</span><br><span class="line"></span><br><span class="line">    public static Path walkFileTree(Path start,</span><br><span class="line">                                    Set&lt;FileVisitOption&gt; options,</span><br><span class="line">                                    int maxDepth,</span><br><span class="line">                                    FileVisitor&lt;? super Path&gt; visitor)</span><br><span class="line">        throws IOException</span><br><span class="line">    &#123; ... &#125;</span><br><span class="line">    - 沿着给定的一个 目录</span><br><span class="line">    - 深度优先 </span><br><span class="line"></span><br><span class="line">    FileVisitor 是什么？就是一个接口，如果你实现它，就可以在访问文件的过程中进行自定义控制</span><br></pre></td></tr></table></figure>
<blockquote>
<p>FileVisitor接口</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public interface FileVisitor&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // 文件夹访问之前</span><br><span class="line">    FileVisitResult preVisitDirectory(T dir, BasicFileAttributes attrs)</span><br><span class="line">        throws IOException;</span><br><span class="line"></span><br><span class="line">    // 访问文件夹做什么</span><br><span class="line">    FileVisitResult visitFile(T file, BasicFileAttributes attrs)</span><br><span class="line">        throws IOException;</span><br><span class="line"></span><br><span class="line">    // 访问失败做什么</span><br><span class="line">    FileVisitResult visitFileFailed(T file, IOException exc)</span><br><span class="line">        throws IOException;</span><br><span class="line"></span><br><span class="line">    // 访问文件夹之后</span><br><span class="line">    FileVisitResult postVisitDirectory(T dir, IOException exc)</span><br><span class="line">        throws IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>FileVisitResult 访问文件的4个结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public enum FileVisitResult &#123;</span><br><span class="line">    CONTINUE,</span><br><span class="line">    TERMINATE,// 终止</span><br><span class="line">    SKIP_SUBTREE, // 忽略子树</span><br><span class="line">    SKIP_SIBLINGS; // 忽略所有兄弟</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="MyFileVisitor"><a href="#MyFileVisitor" class="headerlink" title="MyFileVisitor"></a>MyFileVisitor</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">package com.github.hcsp.polymorphism;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.file.*;</span><br><span class="line">import java.nio.file.attribute.BasicFileAttributes;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class FileFilter &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Path projectDir = Paths.get(System.getProperty(&quot;user.dir&quot;));</span><br><span class="line">        Path testRootDir = projectDir.resolve(&quot;test-root&quot;);</span><br><span class="line">        if (!testRootDir.toFile().isDirectory()) &#123;</span><br><span class="line">            throw new IllegalStateException(testRootDir.toAbsolutePath().toString() + &quot;不存在！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; filteredFileNames = filter(testRootDir, &quot;.csv&quot;);</span><br><span class="line">        System.out.println(filteredFileNames);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 实现一个按照扩展名过滤文件的功能</span><br><span class="line">     *</span><br><span class="line">     * @param rootDirectory 要过滤的文件夹</span><br><span class="line">     * @param extension 要过滤的文件扩展名，例如 .txt</span><br><span class="line">     * @return 所有该文件夹（及其后代子文件夹中）匹配指定扩展名的文件的名字</span><br><span class="line">     */</span><br><span class="line">    public static List&lt;String&gt; filter(Path rootDirectory, String extension) throws IOException &#123;</span><br><span class="line">        Files.walkFileTree(rootDirectory,new MyFileVisitor());</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 分割线，另一个 java文件里</span><br><span class="line">// MyFileVisitor.java</span><br><span class="line">public class MyFileVisitor implements FileVisitor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public FileVisitResult preVisitDirectory(Object dir, BasicFileAttributes attrs) throws IOException &#123;</span><br><span class="line">        System.out.println(dir);</span><br><span class="line">        return FileVisitResult.CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public FileVisitResult visitFile(Object file, BasicFileAttributes attrs) throws IOException &#123;</span><br><span class="line">        System.out.println(file);</span><br><span class="line">        return FileVisitResult.CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public FileVisitResult visitFileFailed(Object file, IOException exc) throws IOException &#123;</span><br><span class="line">        System.out.println(file);</span><br><span class="line">        return FileVisitResult.CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public FileVisitResult postVisitDirectory(Object dir, IOException exc) throws IOException &#123;</span><br><span class="line">        return FileVisitResult.CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>除此之外，我们可以找到 FileVisitor 的实现类(骨架类)，因为我们不需要实现所有的接口</p>
</blockquote>
<ul>
<li>找到了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class FileFilterVisitor extends SimpleFileVisitor&lt;Path&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123;</span><br><span class="line">        System.out.println(file);</span><br><span class="line">        return FileVisitResult.CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需求添加，我们需要知道过滤文件的扩展名，和返回过滤后的集合</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package com.github.hcsp.polymorphism;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.file.*;</span><br><span class="line">import java.nio.file.attribute.BasicFileAttributes;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class FileFilter &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Path projectDir = Paths.get(System.getProperty(&quot;user.dir&quot;));</span><br><span class="line">        Path testRootDir = projectDir.resolve(&quot;test-root&quot;);</span><br><span class="line">        if (!testRootDir.toFile().isDirectory()) &#123;</span><br><span class="line">            throw new IllegalStateException(testRootDir.toAbsolutePath().toString() + &quot;不存在！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; filteredFileNames = filter(testRootDir, &quot;.csv&quot;);</span><br><span class="line">        System.out.println(filteredFileNames);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static List&lt;String&gt; filter(Path rootDirectory, String extension) throws IOException &#123;</span><br><span class="line">        FileFilterVisitor visitor = new FileFilterVisitor(extension);</span><br><span class="line">        Files.walkFileTree(rootDirectory,visitor);</span><br><span class="line">        return visitor.getFilterNames();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 分割线，另一个 java文件里</span><br><span class="line">// FileFilterVisitor.java</span><br><span class="line">// 使用骨架实现</span><br><span class="line">public class FileFilterVisitor extends SimpleFileVisitor&lt;Path&gt;&#123;</span><br><span class="line">    private String extension;</span><br><span class="line">    private List&lt;String&gt; filterNames = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public FileFilterVisitor(String extension) &#123;</span><br><span class="line">        this.extension = extension;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; getFilterNames() &#123;</span><br><span class="line">        return filterNames;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123;</span><br><span class="line">        System.out.println(file);</span><br><span class="line">        if(file.getFileName().toString().endsWith(extension))&#123;</span><br><span class="line">            filterNames.add(file.getFileName().toString());</span><br><span class="line">        &#125;</span><br><span class="line">        return FileVisitResult.CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="再次升级需求：问题如下"><a href="#再次升级需求：问题如下" class="headerlink" title="再次升级需求：问题如下"></a>再次升级需求：问题如下</h4></blockquote>
<ul>
<li>你的 <code>FileFilterVisitor</code> 不再一个类里，而且还需要定制构造器 传递<code>extension</code>参数</li>
</ul>
<p>于是你把 <code>FileFilterVisitor.java</code> 移到 <code>FileFilter.java</code> 里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package com.github.hcsp.polymorphism;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.file.*;</span><br><span class="line">import java.nio.file.attribute.BasicFileAttributes;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class FileFilter &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Path projectDir = Paths.get(System.getProperty(&quot;user.dir&quot;));</span><br><span class="line">        Path testRootDir = projectDir.resolve(&quot;test-root&quot;);</span><br><span class="line">        if (!testRootDir.toFile().isDirectory()) &#123;</span><br><span class="line">            throw new IllegalStateException(testRootDir.toAbsolutePath().toString() + &quot;不存在！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; filteredFileNames = filter(testRootDir, &quot;.csv&quot;);</span><br><span class="line">        System.out.println(filteredFileNames);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static List&lt;String&gt; filter(Path rootDirectory, String extension) throws IOException &#123;</span><br><span class="line">        FileFilterVisitor visitor = new FileFilterVisitor(extension);</span><br><span class="line">        Files.walkFileTree(rootDirectory,visitor);</span><br><span class="line">        return visitor.getFilterNames();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class FileFilterVisitor extends SimpleFileVisitor&lt;Path&gt;&#123;</span><br><span class="line">    private String extension;</span><br><span class="line">    private List&lt;String&gt; filterNames = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public FileFilterVisitor(String extension) &#123;</span><br><span class="line">        this.extension = extension;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; getFilterNames() &#123;</span><br><span class="line">        return filterNames;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123;</span><br><span class="line">        System.out.println(file);</span><br><span class="line">        if(file.getFileName().toString().endsWith(extension))&#123;</span><br><span class="line">            filterNames.add(file.getFileName().toString());</span><br><span class="line">        &#125;</span><br><span class="line">        return FileVisitResult.CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>即使移到了一个java文件里，但是你还是觉得麻烦</strong></p>
<h4 id="内部类-一个类包含在另一类中"><a href="#内部类-一个类包含在另一类中" class="headerlink" title="内部类(一个类包含在另一类中)"></a>内部类(一个类包含在另一类中)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class FileFilter &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Path projectDir = Paths.get(System.getProperty(&quot;user.dir&quot;));</span><br><span class="line">        Path testRootDir = projectDir.resolve(&quot;test-root&quot;);</span><br><span class="line">        if (!testRootDir.toFile().isDirectory()) &#123;</span><br><span class="line">            throw new IllegalStateException(testRootDir.toAbsolutePath().toString() + &quot;不存在！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; filteredFileNames = filter(testRootDir, &quot;.csv&quot;);</span><br><span class="line">        System.out.println(filteredFileNames);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static List&lt;String&gt; filter(Path rootDirectory, String extension) throws IOException &#123;</span><br><span class="line">        FileFilterVisitor visitor = new FileFilterVisitor(extension);</span><br><span class="line">        Files.walkFileTree(rootDirectory,visitor);</span><br><span class="line">        return visitor.getFilterNames();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 内部类</span><br><span class="line">    public static class FileFilterVisitor extends SimpleFileVisitor&lt;Path&gt;&#123;</span><br><span class="line">        private String extension;</span><br><span class="line">        private List&lt;String&gt; filterNames = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        public FileFilterVisitor(String extension) &#123;</span><br><span class="line">            this.extension = extension;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public List&lt;String&gt; getFilterNames() &#123;</span><br><span class="line">            return filterNames;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">            if(file.getFileName().toString().endsWith(extension))&#123;</span><br><span class="line">                filterNames.add(file.getFileName().toString());</span><br><span class="line">            &#125;</span><br><span class="line">            return FileVisitResult.CONTINUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>还是觉得麻烦，因为要传递<code>extension</code></strong></p>
<blockquote>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class FileFilter &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Path projectDir = Paths.get(System.getProperty(&quot;user.dir&quot;));</span><br><span class="line">        Path testRootDir = projectDir.resolve(&quot;test-root&quot;);</span><br><span class="line">        if (!testRootDir.toFile().isDirectory()) &#123;</span><br><span class="line">            throw new IllegalStateException(testRootDir.toAbsolutePath().toString() + &quot;不存在！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; filteredFileNames = filter(testRootDir, &quot;.csv&quot;);</span><br><span class="line">        System.out.println(filteredFileNames);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 匿名内部类</span><br><span class="line">    public static List&lt;String&gt; filter(Path rootDirectory, String extension) throws IOException &#123;</span><br><span class="line">        List&lt;String&gt; names = new ArrayList&lt;&gt;();</span><br><span class="line">        Files.walkFileTree(rootDirectory,new SimpleFileVisitor&lt;Path&gt;()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123;</span><br><span class="line">                System.out.println(file);</span><br><span class="line">                if(file.getFileName().toString().endsWith(extension))&#123;</span><br><span class="line">                    names.add(file.getFileName().toString());</span><br><span class="line">                &#125;</span><br><span class="line">                return FileVisitResult.CONTINUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return names;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是<strong>多态</strong>的应用</p>
<ul>
<li>通过修改一小块的功能去完成一个更加灵活性的功能</li>
<li><p>通过去覆盖(重写)一个方法来实现更加灵活的功能</p>
</li>
<li><p><a href="https://github.com/hcsp/refactor-filters" target="_blank" rel="noopener">代码参考</a></p>
</li>
<li><a href="https://github.com/hcsp/file-filter/pull/10" target="_blank" rel="noopener">我的pr</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/09/ZB-014-java接口和抽象类01/" data-id="ckkmr2k8c00r5fp91pfmoq60l" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/oak/">oak</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ZB-013-java多态" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/05/ZB-013-java多态/" class="article-date">
  <time datetime="2019-07-05T13:28:53.000Z" itemprop="datePublished">2019-07-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/05/ZB-013-java多态/">ZB-013-java多态</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="什么是多态"><a href="#什么是多态" class="headerlink" title="什么是多态"></a>什么是多态</h3><ul>
<li>实例方法默认是多态的<ul>
<li>在运行时根据this来决定调用那个方法</li>
<li>静态方法没有多态</li>
<li>参数静态绑定，接受者动态绑定<ol>
<li>多态只对方法的接受者生效</li>
<li>多态只选择接受者的类型，不选择参数的类型</li>
</ol>
</li>
</ul>
</li>
<li>例子<ol>
<li>shape</li>
<li>HashSet.addAll() <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 HashSet自己没有 addAll ，从父类继承来的，</span><br><span class="line">2 调用addAll 会调用 add 方法</span><br><span class="line">3 而 HashSet 和 父类 都有 add 方法，那么会调用谁的呢？</span><br><span class="line">4 默念口诀： 实例方法默认是多态的，多态的意思是根据当前的类型来决定调用那个方法</span><br><span class="line">5 虽然 addAll 在父类中 但当前对象是 HashSet 的实例。所有会调用 HashSet 的 add</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<blockquote>
<h4 id="相关例子"><a href="#相关例子" class="headerlink" title="相关例子"></a>相关例子</h4></blockquote>
<ul>
<li><a href="https://github.com/hcsp/shape-polymorphism" target="_blank" rel="noopener">https://github.com/hcsp/shape-polymorphism</a></li>
<li><a href="https://github.com/hcsp/polymorphism-overload-method-selection" target="_blank" rel="noopener">https://github.com/hcsp/polymorphism-overload-method-selection</a></li>
<li><a href="https://github.com/hcsp/discount-strategy-pattern" target="_blank" rel="noopener">策略模式，打折策略</a>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public static int calculatePrice(String discountStrategy, int price, User user) &#123;</span><br><span class="line">    switch (discountStrategy) &#123;</span><br><span class="line">        case &quot;NoDiscount&quot;:</span><br><span class="line">            return price;</span><br><span class="line">        case &quot;Discount95&quot;:</span><br><span class="line">            return (int) (price * 0.95);</span><br><span class="line">        case &quot;OnlyVip&quot;:</span><br><span class="line">            &#123;</span><br><span class="line">                if (user.isVip()) &#123;</span><br><span class="line">                    return (int) (price * 0.95);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return price;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        default:</span><br><span class="line">            throw new IllegalStateException(&quot;Should not be here!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这样的缺点是 后来又多了 N种策略怎么办，别人都不敢轻易改代码了</span><br><span class="line">把每个策略抽象成一种类型单独维护</span><br><span class="line">public static int calculatePrice(DiscountStrategy strategy, int price, User user) &#123;</span><br><span class="line">    return strategy.discount(price, user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// DiscountStrategy 是父类</span><br><span class="line">public class DiscountStrategy &#123;</span><br><span class="line">    public int discount(int price, User user) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 使用 多态实现不同策略  </span><br><span class="line">public class Discount95Strategy extends DiscountStrategy&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int discount(int price, User user) &#123;</span><br><span class="line">        return (int)(price*0.95);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class NoDiscountStrategy extends DiscountStrategy&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int discount(int price, User user) &#123;</span><br><span class="line">        return price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class OnlyVipDiscountStrategy extends DiscountStrategy&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int discount(int price, User user) &#123;</span><br><span class="line">        if(user.isVip())&#123;</span><br><span class="line">            return (int)(price*0.95);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return price;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 这样每次增加策略就新建一个类就行了。</span><br><span class="line"></span><br><span class="line">// 这是个优点，也是个缺点。是因为 如果10000个策略就10000个类</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<h4 id="涉及金额绝对不能用double"><a href="#涉及金额绝对不能用double" class="headerlink" title="涉及金额绝对不能用double"></a>涉及金额绝对不能用double</h4></blockquote>
<ol>
<li>所有金额乘以 100 (1元= 100分)</li>
<li><code>BigDecimal</code>类型 任意精度10进制数</li>
</ol>
<blockquote>
<h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TheadPoolExecutor(</span><br><span class="line">    int corePoolSize,</span><br><span class="line">    int maxiumPoolSize,</span><br><span class="line">    long keepAliveTime,</span><br><span class="line">    TimeUnit unit,</span><br><span class="line">    BlockKingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">    ThreadFactory threadFactory,</span><br><span class="line">    RejectedExecutionHandler handler)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 最后一个参数的意思       </span><br><span class="line">RejectedExecutionHandler 就是策略模式在线程池中的应用</span><br></pre></td></tr></table></figure>
<h4 id="做菜实例"><a href="#做菜实例" class="headerlink" title="做菜实例"></a>做菜实例</h4><ul>
<li><a href="https://github.com/hcsp/refactor-to-abstract-class" target="_blank" rel="noopener">https://github.com/hcsp/refactor-to-abstract-class</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/05/ZB-013-java多态/" data-id="ckkmr2k8b00r3fp91omajogkx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/oak/">oak</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ZB-012-java组合和继承" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/04/ZB-012-java组合和继承/" class="article-date">
  <time datetime="2019-07-04T14:44:46.000Z" itemprop="datePublished">2019-07-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/04/ZB-012-java组合和继承/">ZB-012-java组合和继承</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="什么是继承"><a href="#什么是继承" class="headerlink" title="什么是继承"></a>什么是继承</h3><ul>
<li>程序员的宿命：复制 &amp; 粘贴<ul>
<li>真的只能这样吗？</li>
<li>DRY(Donot Repeat Youself)</li>
<li>事不过三，三则重构</li>
</ul>
</li>
<li>继承的本质是提炼代码，避免重复</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Cat &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void walk()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Dog &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void walk()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Pig &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void walk()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 它们又很多共性和重复</span><br><span class="line">// 一旦walk改变了，要改三个地方</span><br></pre></td></tr></table></figure>
<blockquote>
<p>继承,避免重复</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Animal&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public void walk()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Cat extends Amimal&#123;...&#125;</span><br><span class="line">public class Dog extends Amimal&#123;...&#125;</span><br><span class="line">public class Pig extends Amimal&#123;...&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Java的继承体系"><a href="#Java的继承体系" class="headerlink" title="Java的继承体系"></a>Java的继承体系</h3><ul>
<li>单继承</li>
<li><p>Object 是所有类的基类，所有对象都继承了Object，所以所有对象都有 Object 的非私有成员属性/方法</p>
<ul>
<li><p>equals</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Object 的 equals 默认实现是 </span><br><span class="line">public boolean equals(Object obj)&#123;</span><br><span class="line">    return this == obj; // 比较的是 addr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">针对其他类如 Order  根据 id就可以确定是不是同一订单</span><br><span class="line">public class Order &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (this == o) return true;</span><br><span class="line">        if (o == null || getClass() != o.getClass()) return false;</span><br><span class="line">        Cat cat = (Cat) o;</span><br><span class="line">        return id == cat.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        return Objects.hash(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>toString</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object 的 toString 默认实现是 </span><br><span class="line">public boolean toString()&#123;</span><br><span class="line">    return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode()) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">任何时候打印对象的时候 都会提供字符串表示</span><br><span class="line">System.out.println(xxx); // 隐式调用</span><br><span class="line">xxx.toString();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>单根继承的好处是：</p>
</blockquote>
<ul>
<li>所有对象都有某一行为，因为都继承了 Object</li>
<li>方便处理</li>
</ul>
<blockquote>
<p>如 python支持多继承。会带来很多问题——菱形继承</p>
</blockquote>
<ul>
<li>父类都有 xxx()函数的处理！！！不知道该调用谁，但是python解决了！不再详细解释</li>
</ul>
<h3 id="类的结构和初始化顺序"><a href="#类的结构和初始化顺序" class="headerlink" title="类的结构和初始化顺序"></a>类的结构和初始化顺序</h3><ul>
<li>子类拥有父类一切的数据和行为</li>
<li>父类先于子类</li>
<li>必须拥有匹配的构造器<ul>
<li>super</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Animal &#123;</span><br><span class="line">    String name;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;初始化父类块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public Animal(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Cat extends Animal&#123;</span><br><span class="line">    int age;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;初始化子类块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public Cat(String name,int age) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>过程就是自顶向下依次初始化</li>
</ul>
<h3 id="实例方法的覆盖"><a href="#实例方法的覆盖" class="headerlink" title="实例方法的覆盖"></a>实例方法的覆盖</h3><ul>
<li>又称为重写/覆盖</li>
<li>永远使用<code>@Override</code>注解来防止手残<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Animal &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    public Animal(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sayHello()&#123;</span><br><span class="line">        System.out.println(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ----------------------------------</span><br><span class="line">public class Cat extends Animal&#123;</span><br><span class="line">    int age;</span><br><span class="line"></span><br><span class="line">    public Cat(String name,int age) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello()&#123;</span><br><span class="line">        System.out.println(&quot;cat hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h3><ul>
<li>spring的初始化代码就是模版方法，定义了一些预定义好的方法。自定义的实现可以覆盖模版的方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 模版方法</span><br><span class="line">public class BookWriter &#123;</span><br><span class="line">    // 写书</span><br><span class="line">    public void wtiteBook()&#123;</span><br><span class="line">        writeTitle();</span><br><span class="line">        writeContent();</span><br><span class="line">        writeEnding();</span><br><span class="line">    &#125;</span><br><span class="line">    public void writeTitle()&#123;</span><br><span class="line">        System.out.println(&quot;标题&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void writeContent()&#123;</span><br><span class="line">        System.out.println(&quot;内容&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void writeEnding()&#123;</span><br><span class="line">        System.out.println(&quot;结尾&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 子类继承父类的模版方法</span><br><span class="line">public class MyBookWriter extends BookWriter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void writeContent()&#123;</span><br><span class="line">        System.out.println(&quot;我的内容&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new MyBookWriter().wtiteBook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="向上和向下转型"><a href="#向上和向下转型" class="headerlink" title="向上和向下转型"></a>向上和向下转型</h3><ul>
<li><p>一个子类对象一定是父类类型的对象</p>
<ul>
<li>正如一只猫同时也是一个动物，同时也是一个对象</li>
<li><p>instanceof 判断一个对象是不是一个类的实例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object a = new Integer(1234);</span><br><span class="line">System.out.println(a instanceof Integer); // true</span><br><span class="line">System.out.println(a instanceof Number); // true</span><br><span class="line">System.out.println(a instanceof Object); // true</span><br><span class="line">System.out.println(null instanceof Integer); // false</span><br></pre></td></tr></table></figure>
</li>
<li><p>null installceof ? 都是 false</p>
</li>
</ul>
</li>
<li><p>当需要一个父类型时，可以传递一个子类型</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    setList(new ArrayList&lt;Integer&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void setList(AbstractList&lt;Integer&gt; list)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// &lt;Integer&gt; 是泛型， ArrayList 是 AbstractList 的子类</span><br><span class="line"></span><br><span class="line">// 还可以这样</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    setList(new ArrayList&lt;Integer&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void setList(AbstractList&lt;? super Number&gt; list)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>但是，有的时候你必须进行一些转型</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">    Animal a = new Animal();</span><br><span class="line">    setAnimalName((Dog)animal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void setAnimalName(Dog dog)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.ClassCastException: Animal cannot be cast to Dog</span><br></pre></td></tr></table></figure>
<ul>
<li>转型是不安全的</li>
<li>失败了怎么办？</li>
</ul>
</li>
</ul>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><ul>
<li><p>final声明变量是不可变的(必须初始化)</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final int a = 1; // 正确</span><br><span class="line">final int a ; // 错误 没有初始化</span><br></pre></td></tr></table></figure>
<ul>
<li><p>局部变量/方法参数</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void f(final Date date)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// date的地址不能改变， 地址指向的东西可以改变</span><br></pre></td></tr></table></figure>
</li>
<li><p>成员变量</p>
</li>
<li><p>常量和单例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 命名规则是全部大写 ，然后以下划线区分 如 MAX_VALUE</span><br><span class="line">public static final double PI = 3.1415926;</span><br><span class="line"></span><br><span class="line">// 单例模式</span><br><span class="line">public class World&#123;</span><br><span class="line">    private static final World SINGLETON_INSTANCE = new World();</span><br><span class="line">    private World()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static World getInstance()&#123;</span><br><span class="line">        return SINGLETON_INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>final在方法上的声明： 禁止继承/覆盖/重写此方法</p>
</li>
<li>final在类声明上的声明： 禁止继承此类<ul>
<li>继承提供了灵活性，也埋下了隐患</li>
<li>为什么String/Integer 等是 final的呢？<ol>
<li>假设 <code>MyInteger extends Integer</code> 此时重写 <code>compare</code> 本来 <code>1&lt;2</code> 而你偏偏 <code>改写成 1&gt;2</code> 这样就破坏所有使用<code>Integer</code>方法 的约定</li>
<li>JDK通过把 <code>String/Integer 定义为 final</code> 来阻止恶意的客户端继承常见类，破坏程序的约定</li>
</ol>
</li>
</ul>
</li>
</ul>
<blockquote>
<h4 id="final在-类-方法上有什么优点"><a href="#final在-类-方法上有什么优点" class="headerlink" title="final在 类/方法上有什么优点"></a>final在 类/方法上有什么优点</h4></blockquote>
<ol>
<li>使用 final 可以保证类无法被继承，方法无法被重写，别人无法通过继承来破坏约定，你可以大胆的做一些事情，软件设计的一个约定——放心大胆的做一些事，我可以保证这个约定不会被打破</li>
<li>这个方法是 final 时方法是被确定的无法多态</li>
</ol>
<h3 id="组合和继承"><a href="#组合和继承" class="headerlink" title="组合和继承"></a>组合和继承</h3><ul>
<li>继承：is-a</li>
<li>组合：has-a</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/04/ZB-012-java组合和继承/" data-id="ckkmr2k8b00r1fp91tc13s4mz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/oak/">oak</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ZB-011-java封装和访问控制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/04/ZB-011-java封装和访问控制/" class="article-date">
  <time datetime="2019-07-04T11:59:51.000Z" itemprop="datePublished">2019-07-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/04/ZB-011-java封装和访问控制/">ZB-011-java封装和访问控制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="什么是封装"><a href="#什么是封装" class="headerlink" title="什么是封装"></a>什么是封装</h3><ul>
<li>隐藏内部细节，只暴露出接口</li>
<li>电灯<ul>
<li>你只关心它的“开关”接口，不关心内部的“电路”细节</li>
</ul>
</li>
<li>汽车<ul>
<li>你只关心“方向盘”，不关心内部的细节</li>
</ul>
</li>
</ul>
<p>Light.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Light&#123;</span><br><span class="line"></span><br><span class="line">    public void trunOn()&#123;</span><br><span class="line">        打开电路1();</span><br><span class="line">        打开电路2();</span><br><span class="line">        打开电路3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void 打开电路1()&#123;&#125;</span><br><span class="line">    public void 打开电路2()&#123;&#125;</span><br><span class="line">    public void 打开电路3()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Home.java</p>
</blockquote>
<p>打开灯有两种方式</p>
<ul>
<li>直接调用 <code>trunOn()</code> (低耦合)</li>
<li>调用实现细节 <code>打开电路1();打开电路2();打开电路3()</code>(高耦合)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class public Home&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Light a = new Light();</span><br><span class="line">        a.trunOn();</span><br><span class="line"></span><br><span class="line">        Light b = new Light();</span><br><span class="line">        b.打开电路1();</span><br><span class="line">        b.打开电路2();</span><br><span class="line">        b.打开电路3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如果有一天，一个高级工程师对打开灯的方式进行了优化</strong></p>
<p>此时只要<code>打开电路1();打开电路2();</code> 就可以开灯了</p>
<p>此时 以第二种方式调用开灯的人就要修改 因为它耦合了开灯的细节</p>
<p><strong>一方改变另一方也要改变</strong></p>
<p>而第一种方式只需要更改 <code>turnOn()</code> 自己一个方法就做到了正常工作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void trunOn()&#123;</span><br><span class="line">    打开电路1();</span><br><span class="line">    打开电路2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h4></blockquote>
<p>Person类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Person&#123;</span><br><span class="line">    int id;</span><br><span class="line">    int age;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设10个人都用了你的 <code>Person</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person p = new Person();</span><br><span class="line">p.age = 10;</span><br><span class="line">p.name = &quot;张三&quot;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>老板突然提了个需求，<strong>如果年龄小与0则为0，大于100则为100</strong></p>
</blockquote>
<ul>
<li>这样别人都是通过 <code>p.age = 10</code>设置一个值。这样要改 10个地方。</li>
</ul>
<blockquote>
<p>优化</p>
</blockquote>
<ul>
<li>把成员变量变为私有</li>
<li>设置对应的 get/set 接口</li>
<li>外界只能通过 get/set接口对成员进行操作  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person p = new Person();</span><br><span class="line">p.setAge(10);</span><br><span class="line">p.setName(&quot;张三&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">    // 如果年龄小与0则为0，大于100则为100</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        if(age&lt;0)&#123;</span><br><span class="line">            this.age = 0;</span><br><span class="line">        &#125;else if(age&gt;100)&#123;</span><br><span class="line">            this.age = 100;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            this.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有没有发现改一下接口 <code>setAge()</code> 就轻松的完成了需求</p>
<blockquote>
<p>场景三，你开发的Person 被广泛应用到别人的电脑</p>
</blockquote>
<p>此时你老板认为世界上只有男和女，于是你的<code>gender</code> 采用了 <code>boolean</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private boolean gender;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean isMale() &#123;</span><br><span class="line">        return gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setGender(boolean gender) &#123;</span><br><span class="line">        this.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过了1年后，你老板发现还真有其他性别。你就不得不改变<code>gender 为 String</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package hello.service;</span><br><span class="line"></span><br><span class="line">import java.util.Objects;</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private String gender;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean isMale() &#123;</span><br><span class="line">        // return gender == &quot;M&quot;; 可能会空指针</span><br><span class="line">        // return &quot;M&quot;.equals(gender);  非空对象前置</span><br><span class="line">        return Objects.equals(gender,&quot;M&quot;); </span><br><span class="line">    &#125;</span><br><span class="line">    // 废弃的注解</span><br><span class="line">    @Deprecated</span><br><span class="line">    public void setGender(boolean gender) &#123;</span><br><span class="line">        this.gender = gender ? &quot;M&quot; : &quot;F&quot; ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时使用者无需任何改变，依然能正常使用</p>
<h3 id="封装的实现"><a href="#封装的实现" class="headerlink" title="封装的实现"></a>封装的实现</h3><blockquote>
<p>包的功能就是提供<strong>访问控制，一种边界，封装的边界</strong></p>
</blockquote>
<ul>
<li>public 任何人都能访问</li>
<li>protected 只有子类和同包的可以访问</li>
<li>package private(包级私有)包权限 同包可访问</li>
<li>private 只有自己能访问</li>
</ul>
<p><strong>包是没有嵌套包含关系的！！！跟文件夹父子目录不一样</strong></p>
<h4 id="JavaBean约定"><a href="#JavaBean约定" class="headerlink" title="JavaBean约定"></a>JavaBean约定</h4><ul>
<li>getter</li>
<li>setter</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private boolean cute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>此时 <code>Person 的 name / cute</code> 无法被外界访问因为是 <code>private</code></strong></p>
<p>设置getter/setter</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private boolean cute;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isCute() &#123;</span><br><span class="line">        return cute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCute(boolean cute) &#123;</span><br><span class="line">        this.cute = cute;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么 <code>getter/setter</code>长这个样子,不是无缘无故，而是<strong>JavaBean约定</strong></p>
</blockquote>
<ul>
<li>我们知道 <code>java</code> 代表咖啡，而程序员很浪漫</li>
<li>在<code>java</code>中创建对象了叫什么呢？ 对象？太土了，程序员的浪漫促使它起了名字叫做 <strong>“Bean”</strong> 就是”豆”</li>
<li>JavaBean 就是咖啡豆</li>
</ul>
<p>对于一个 JavaBean 来说 加入他有一个 <code>getX() 和 setX()</code> 方法，我们就认为它有一个 <code>x</code> 属性</p>
<h5 id="规则如下"><a href="#规则如下" class="headerlink" title="规则如下"></a>规则如下</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 非 boolean 值</span><br><span class="line">String name;</span><br><span class="line">setName/getName</span><br><span class="line"></span><br><span class="line">// boolean 值</span><br><span class="line">boolean gender</span><br><span class="line">setGender/isGender</span><br></pre></td></tr></table></figure>
<h5 id="这些约定有什么用呢？"><a href="#这些约定有什么用呢？" class="headerlink" title="这些约定有什么用呢？"></a>这些约定有什么用呢？</h5><ul>
<li>最重要之一就是 <code>JSON</code> 对象和字符串相互转换</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 如 js</span><br><span class="line">var obj = &#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:&quot;李四&quot;&#125;;</span><br><span class="line">// 序列化</span><br><span class="line">JSON.stringify(obj);</span><br><span class="line">// 反序列化</span><br><span class="line">var obj2 = JSON.parse(`&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:&quot;李四&quot;&#125;`);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>java常见序列化库 fastjson / gson / jackson</p>
</blockquote>
<h5 id="java中使用序列化库"><a href="#java中使用序列化库" class="headerlink" title="java中使用序列化库"></a>java中使用序列化库</h5><p>maven里引入依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.58&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Cat &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private boolean cute;</span><br><span class="line"></span><br><span class="line">    public Cat(String name, boolean cute) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.cute = cute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isCute() &#123;</span><br><span class="line">        return cute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCute(boolean cute) &#123;</span><br><span class="line">        this.cute = cute;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.json;</span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Cat cat = new Cat(&quot;a&quot;,true);</span><br><span class="line"></span><br><span class="line">        System.out.printf(JSON.toJSONString(cat));</span><br><span class="line"></span><br><span class="line">        String s = &quot;&#123;\&quot;cute\&quot;:true,\&quot;name\&quot;:\&quot;喵\&quot;&#125;&quot;;</span><br><span class="line"></span><br><span class="line">        cat = JSON.parseObject(s,Cat.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是 JSON 的序列化和反序列化过程</p>
<blockquote>
<h4 id="JavaBean-约定"><a href="#JavaBean-约定" class="headerlink" title="JavaBean 约定"></a>JavaBean 约定</h4></blockquote>
<p><strong>会使用你的 getter/setter 当作属性的名字，而不是你的成员private类型成员</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package com.json;</span><br><span class="line"></span><br><span class="line">public class Cat &#123;</span><br><span class="line">    private boolean cute;</span><br><span class="line"></span><br><span class="line">    public Cat(String name, boolean cute) &#123;</span><br><span class="line">        this.cute = cute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return &quot;123&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isCute() &#123;</span><br><span class="line">        return cute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCute(boolean cute) &#123;</span><br><span class="line">        this.cute = cute;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// name属性不存在了</span><br><span class="line">// getter/setter还在</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Cat cat = new Cat(&quot;a&quot;,true);</span><br><span class="line">        System.out.printf(JSON.toJSONString(cat));</span><br><span class="line">        //&#123;&quot;cute&quot;:true,&quot;name&quot;:&quot;123&quot;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="JavaBean总结"><a href="#JavaBean总结" class="headerlink" title="JavaBean总结"></a>JavaBean总结</h4><p>在Java的世界中，对json进行读写的时候，我们只看JavaBean的 <code>getter/setter</code>方法，而不看是否具有<code>xxx</code>属性</p>
<p><strong>这也进一步验证了我们想要达到封装的目的，封装应该尽可能的隐藏内部实现细节，而仅仅像外界暴露接口</strong></p>
<p>暴露的接口 在JavaBean中就是 <code>getter/setter</code> 方法</p>
<p>虽然每次java里设置一堆<code>getter/setter</code>很繁琐啰嗦，好处就是为你提供了封装，</p>
<ul>
<li>封装是软件得以成功演进的保证</li>
</ul>
<h3 id="设计模式：抽象工厂方法"><a href="#设计模式：抽象工厂方法" class="headerlink" title="设计模式：抽象工厂方法"></a>设计模式：抽象工厂方法</h3><blockquote>
<p>推荐一本书 effective java,无论处在java任何阶段都非常值得一读</p>
</blockquote>
<ul>
<li>使用静态工厂方法代替构造器</li>
<li>将构造器私有化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static Cat newCuteCat(String name)&#123;</span><br><span class="line">        return new Cat(name,true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public static Cat newUnCuteCat(String name)&#123;</span><br><span class="line">    return new Cat(name,false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Cat(String name, boolean cute) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.cute = cute;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 静态工厂方法，可以有个名字，清楚无误的告诉你干什么</span><br><span class="line">Cat.newCuteCat(&quot;xxx&quot;)  // 萌的猫</span><br><span class="line">Cat.newUnCuteCat(&quot;xxx&quot;) // 不萌的猫</span><br><span class="line">new Cat(&quot;xxx&quot;,true) // 看不出来</span><br></pre></td></tr></table></figure>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol>
<li>不像构造器，它是有名字的。可以描述在做什么<ul>
<li>疑问，我可以通过注释来告诉别人构造器做什么</li>
<li>注释是不会被编译器处理的，因此它很有可能过时，过时的注释很可能会误导你，一个过时的<strong>注释</strong>比没有注释更糟糕</li>
<li>尽可能不要写注释，如果你不能保证及时更新</li>
</ul>
</li>
<li>静态方法不一定创建一个实例，你可以返回一个null也可以返回一个之前创建好的对象，但是构造器一定会创建一个实例</li>
<li>静态构造方法可以返回 <strong>该类的子类型</strong>，而构造器只能返回该类的实例</li>
<li><p>可以根据参数决定 要不要创建这个对象，我要创建什么对象，以及要不要把之前的对象缓存一下</p>
<ul>
<li><p>参考<code>Boolean</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final class Boolean implements java.io.Serializable,</span><br><span class="line">                                    Comparable&lt;Boolean&gt;</span><br><span class="line">&#123;</span><br><span class="line">    // 预先定义好的对象</span><br><span class="line">    public static final Boolean TRUE = new Boolean(true);</span><br><span class="line">    public static final Boolean FALSE = new Boolean(false);</span><br><span class="line"></span><br><span class="line">    public static Boolean valueOf(boolean b) &#123;</span><br><span class="line">        return (b ? TRUE : FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>它返回了预先定义好的对象，不用每次都创建，省内存</p>
</li>
</ul>
</li>
<li>静态工厂返回的这个对象，它可以不存在<ul>
<li>动态加载，灵活的体现</li>
</ul>
</li>
</ol>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li>一个子类构造器会自动调用父类的构造器，构造对应的对象，但是静态方法不可以</li>
<li>很难让开发者找到，因为它的灵活性只能打开文档找到它 而不像这样<code>new Cat()</code>方便找到</li>
</ol>
<h5 id="静态方法的最佳实践"><a href="#静态方法的最佳实践" class="headerlink" title="静态方法的最佳实践"></a>静态方法的最佳实践</h5><ul>
<li>将构造器变为私有,此时外界无法创建实例，只能通过暴露的工厂方法</li>
<li>此时你内部如何修改构造器都随意了。外界只能操作暴露的工厂方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Cat &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private boolean cute;</span><br><span class="line"></span><br><span class="line">    public static Cat newCuteCat(String name)&#123;</span><br><span class="line">        return new Cat(name,true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Cat newUnCuteCat(String name)&#123;</span><br><span class="line">        return new Cat(name,false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Cat(String name, boolean cute) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.cute = cute;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类的访问控制"><a href="#类的访问控制" class="headerlink" title="类的访问控制"></a>类的访问控制</h4><p>这就是封装在类级别的表现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 之前，不同包可以直接使用</span><br><span class="line">public class Cat&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 现在 包级私有 package private </span><br><span class="line">class Cat&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>包级私有类 如<code>ProcessEnvironment</code> 在其他包外不能调用。</li>
</ul>
<blockquote>
<h4 id="如何访问一个-包级私有的类呢？-不建议使用太hack"><a href="#如何访问一个-包级私有的类呢？-不建议使用太hack" class="headerlink" title="如何访问一个 包级私有的类呢？(不建议使用太hack)"></a>如何访问一个 包级私有的类呢？(不建议使用太hack)</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 假设一个类,它是 包级私有 只能同包访问</span><br><span class="line">package com.github.demo;</span><br><span class="line">class A&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 在你的 maven项目里创建一个 桥接类 ,它的包路径和 上面的 一样</span><br><span class="line">package com.github.demo;</span><br><span class="line">class 桥接类&#123;</span><br><span class="line">    public A newInstance()&#123;</span><br><span class="line">        // 访问同一包中的私有类</span><br><span class="line">        return new A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 此时你去创建这个类</span><br><span class="line">桥接类.newInstance();// 报错 因为java发现返回值 还是不能访问</span><br><span class="line"></span><br><span class="line">// 怎么办呢,修改返回值类型为 Object</span><br><span class="line">class 桥接类&#123;</span><br><span class="line">    public Object newInstance()&#123;</span><br><span class="line">        // 访问同一包中的私有类</span><br><span class="line">        return new A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 因为 任何对象都是 Object 的子类</span><br><span class="line">// 此时你就可以</span><br><span class="line">桥接类.newInstance();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>既然这样那么我们是不是可以这样绕过限制创建 <code>ProcessEnvironment</code> 的实例呢？</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 你就创建这样的package</span><br><span class="line">package java.lang;</span><br><span class="line">public class MyClass&#123;&#125;</span><br><span class="line">//此时报错了。 说这个类是被禁止的。</span><br><span class="line"></span><br><span class="line">原因是 以 java开头的包都是 jvm的保留包,不允许你自定义一个java.lang包的，但是你可以通过别的包的访问限制</span><br></pre></td></tr></table></figure>
<h4 id="私有内部类"><a href="#私有内部类" class="headerlink" title="私有内部类"></a>私有内部类</h4><p>一个类有简单功能，你不想几个目录跳过来跳过去的使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Home&#123;</span><br><span class="line"></span><br><span class="line">    // 只能在同一个类中访问</span><br><span class="line">    private static class InnerClass&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Java模块系统简介"><a href="#Java模块系统简介" class="headerlink" title="Java模块系统简介"></a>Java模块系统简介</h3><p>需求：你像把若干个包封装在一起，暴露接口出去</p>
<ul>
<li>java8之前是不行的</li>
<li>java9引入了模块化系统，你可以把包封装成模块 module</li>
</ul>
<blockquote>
<p>java9的模块化系统好处是提供了更大范围的封装。但是它太新了。没有被业界所接受。</p>
</blockquote>
<p>例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">假设你是管理者，你手下有工人</span><br><span class="line">package com.farm;</span><br><span class="line">public class Manger&#123;</span><br><span class="line">    private Worker worker;</span><br><span class="line"></span><br><span class="line">    public void manage()&#123;</span><br><span class="line">        worker.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package com.farm;</span><br><span class="line">public class Worker&#123;</span><br><span class="line">    public void work()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 此时你的类发布了,此时你不小心暴露了 worker</span><br></pre></td></tr></table></figure>
<p>另一个项目中,利用同包路径来访问你的worker</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.farm;</span><br><span class="line">public class Boss&#123;</span><br><span class="line">    Manager manager;</span><br><span class="line"></span><br><span class="line">    public void runCompany()&#123;</span><br><span class="line">        manager.manage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Boss直接指挥工人，此时 manager就懵逼了，你怎么直接指挥工人了</span><br><span class="line">    public void directWorker()&#123;</span><br><span class="line">        Worker w1 = new Worker();</span><br><span class="line">        w1.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了不让 Boss 直接指挥 worker</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 你只能包级私有</span><br><span class="line">class Worker&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是有时候，出于其他原因你不得不把它自己包里面</p>
</blockquote>
<ul>
<li>导致 manager 无法指挥 worker了</li>
<li>只能 public了，一旦 public 你的老板又开始指挥工人了</li>
<li>我们只能使用一些君子协定如 internal 包名 让人知道是内部的包。但是别人不君子咋办！！！  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">package com.farm.worker.internal;</span><br><span class="line">public class Worker&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">package com.farm.worker;</span><br><span class="line">class Worker&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>java8之前无法做到，技术上做不到</strong><br><strong>java9的模块化系统可以解决，但是太新了，业界还没接受</strong></p>
<h3 id="builder模式"><a href="#builder模式" class="headerlink" title="builder模式"></a>builder模式</h3><ul>
<li>简略版</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.json;</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">    private String firstName;</span><br><span class="line">    private String lastName;</span><br><span class="line">    private String desc;</span><br><span class="line">    private String job;</span><br><span class="line">    private String phone;</span><br><span class="line">    private String address;</span><br><span class="line"></span><br><span class="line">    public Person(String firstName, String lastName, String desc, String job, String phone, String address) &#123;</span><br><span class="line">        this.firstName = firstName;</span><br><span class="line">        this.lastName = lastName;</span><br><span class="line">        this.desc = desc;</span><br><span class="line">        this.job = job;</span><br><span class="line">        this.phone = phone;</span><br><span class="line">        this.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>一个 <code>Person</code> 有诸多属性你在创建的时候，顺序错了非常难发现，</li>
<li>尤其是在 代码 review 的时候，不再 IDEA 里 ，没有参数提示。</li>
<li>这个时候你可以使用 builder 安装 builder</li>
<li>在IDEA里右键就可以创建 builder</li>
</ul>
<p>此时可以这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person person1 = new Person(&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;)</span><br><span class="line"></span><br><span class="line">// 更加直观，链式调用</span><br><span class="line">Person person = PersonBuilder.aPerson()</span><br><span class="line">    .withFirstName(&quot;&quot;)</span><br><span class="line">    .withLastName(&quot;&quot;)</span><br><span class="line">    .withAddress(&quot;&quot;)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/04/ZB-011-java封装和访问控制/" data-id="ckkmr2k8a00qzfp91urxjjldp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/oak/">oak</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ZB-010-java对象系统" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/03/ZB-010-java对象系统/" class="article-date">
  <time datetime="2019-07-03T12:53:55.000Z" itemprop="datePublished">2019-07-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/03/ZB-010-java对象系统/">ZB-010-java对象系统</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象"></a>什么是对象</h3><ul>
<li>对象就是数据和行为的集合</li>
<li>一切能用 new 创建出来的都是对象  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new Object()</span><br><span class="line"></span><br><span class="line">特例 Integer a = 1; 实际是 Integer a = new Integer(1);</span><br><span class="line">特例 String a = &quot;&quot;; 实际是 String a = new String(&quot;&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="对象的组成"><a href="#对象的组成" class="headerlink" title="对象的组成"></a>对象的组成</h3><ul>
<li>所有的对象都在堆上分配</li>
<li>每个对象有自己的数据(成员变量)<ul>
<li>原生类型成员</li>
<li>引用类型成员</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Home&#123;</span><br><span class="line">    int age;</span><br><span class="line">    Cat cat;</span><br><span class="line">    Home(Cat cat)&#123;</span><br><span class="line">        this.cat = cat;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        new Home(new Cat(1,&quot;阿三&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void miao()&#123;</span><br><span class="line">        System.out.println(&quot;喵&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Cat&#123;</span><br><span class="line">    int age;</span><br><span class="line">    String name;</span><br><span class="line">    Cat(int age,String name)&#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对象的构造函数"><a href="#对象的构造函数" class="headerlink" title="对象的构造函数"></a>对象的构造函数</h3><ul>
<li>新建对象的唯一途径<ol>
<li>在 堆 上分配空间</li>
<li>执行必要的初始化函数</li>
<li>执行构造函数</li>
</ol>
</li>
<li>没有构造器，则编译器偷偷生成一个  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Cat&#123;</span><br><span class="line">    int age; // 默认初始化为 0</span><br><span class="line">    byte b;// 0</span><br><span class="line">    short c;// 0</span><br><span class="line">    float d;// 0f</span><br><span class="line">    double e;// 0d</span><br><span class="line">    String f; // null 引用类型为 null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>new Cat(1,&quot;张三&quot;)</code> 做了什么</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Cat&#123;</span><br><span class="line">    int age;</span><br><span class="line">    String name;</span><br><span class="line">    Cat(int age,String name)&#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在堆上 开辟一个空间</li>
<li>对空间内的对象执行初始化语句，成员变量进行初始化 <code>age = 0 ,name=null</code></li>
<li>执行类的构造器函数,对成员变量进行赋值 <code>age = 1, name=&quot;张三&quot;</code></li>
</ol>
<h3 id="对象的方法"><a href="#对象的方法" class="headerlink" title="对象的方法"></a>对象的方法</h3><ul>
<li>数据是“对象有什么”</li>
<li>方法是“对象做什么”</li>
</ul>
<h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><ul>
<li>重载 overload </li>
<li>重写/覆盖 override</li>
<li>如何区分同名的不同重载方法？<ul>
<li>根据类型</li>
<li>那隐式转换呢？</li>
<li>类型最匹配优先(如果能匹配多个呢？ null)</li>
</ul>
</li>
<li>能仅仅重载返回值吗？</li>
<li>如何为方法提供默认值？<ul>
<li>没办法</li>
<li>但是可以通过重载曲线救国</li>
</ul>
</li>
</ul>
<blockquote>
<p>重载：根据类型区分</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Cat&#123;</span><br><span class="line">    Cat()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    void f()&#123;&#125;</span><br><span class="line">    void f(String s)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Cat cat = new Cat();</span><br><span class="line">        cat.f();</span><br><span class="line">        cat.f(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>重载的坑</strong></p>
</blockquote>
<ul>
<li>装箱类型 int / Integer</li>
<li>Integer 是 Number的子类</li>
<li>Number 是 Object 的子类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Cat&#123;</span><br><span class="line"></span><br><span class="line">    void f(int i)&#123;&#125;</span><br><span class="line">    void f(Integer i)&#123;&#125;</span><br><span class="line">    void f(Number i)&#123;&#125;</span><br><span class="line">    void f(Object i)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Cat cat = new Cat();</span><br><span class="line">        // 此时匹配到哪一个呢？</span><br><span class="line">        cat.f(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个方法调用可以匹配多个方法声明，我该调用谁？</p>
<ul>
<li><p>类型最匹配优先</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> // int 此时会匹配 f(int i) 那个方法</span><br><span class="line">public class Cat&#123;</span><br><span class="line"></span><br><span class="line">     void f(int i)&#123;&#125;</span><br><span class="line">     void f(Integer i)&#123;&#125;</span><br><span class="line">     void f(Number i)&#123;&#125;</span><br><span class="line">     void f(Object i)&#123;&#125;</span><br><span class="line"></span><br><span class="line">     public static void main(String[] args)&#123;</span><br><span class="line">         Cat cat = new Cat();</span><br><span class="line">         // 此时匹配到哪一个呢？</span><br><span class="line">         cat.f(1); // int</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 变化了 注释掉这个 void f(int i)&#123;&#125;</span><br><span class="line">public class Cat&#123;</span><br><span class="line"></span><br><span class="line">    void f(Integer i)&#123;&#125;</span><br><span class="line">    void f(Number i)&#123;&#125;</span><br><span class="line">    void f(Object i)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Cat cat = new Cat();</span><br><span class="line">        // 此时匹配到哪一个呢？ </span><br><span class="line">        // Integer最匹配</span><br><span class="line">        cat.f(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>null值怎么办</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Cat&#123;</span><br><span class="line"></span><br><span class="line">    void f(Integer i)&#123;&#125;</span><br><span class="line">    void f(Object[] i)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Cat cat = new Cat();</span><br><span class="line">        // 此时匹配到哪一个呢？ 两个f都匹配</span><br><span class="line">        // cat.f(null); //标红了</span><br><span class="line">        cat.f((Integer)null); // 强制为 null 指定类型</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  而我这样的时候就不报错了</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Cat&#123;</span><br><span class="line"></span><br><span class="line">    void f(Integer i)&#123;&#125;</span><br><span class="line">    void f(Number i)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Cat cat = new Cat();</span><br><span class="line">        // 此时匹配到哪一个呢？此时竟然不报错了</span><br><span class="line">        cat.f(null); //  Integer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">因为你要记住这句 匹配最接近的 </span><br><span class="line">java的类型树 </span><br><span class="line"></span><br><span class="line">假设我有两种类型 是父子关系。意味着匹配最接近的 就是 Integer</span><br><span class="line">-|Object </span><br><span class="line">--|Number</span><br><span class="line">----|Integer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">假设是兄弟关系呢？ 他们俩与 null的距离相同。所以歧义产生了 ，所以必须要 强制转换</span><br><span class="line">-|Object </span><br><span class="line">--|List</span><br><span class="line">----|ArrayList</span><br><span class="line"></span><br><span class="line">-|Object </span><br><span class="line">--|Number</span><br><span class="line">----|Integer</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<h4 id="能仅仅重载返回值吗？"><a href="#能仅仅重载返回值吗？" class="headerlink" title="能仅仅重载返回值吗？"></a>能仅仅重载返回值吗？</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void f()&#123;&#125;</span><br><span class="line"></span><br><span class="line">int f()&#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 标红</span><br><span class="line">// 因为方法调用允许忽略返回值，</span><br><span class="line">Cat c = new Cat();</span><br><span class="line">c.f(); // 忽略返回值的时候，int f()方法会和 void f()产生冲突，编译器不知道要用哪个，因此不允许这样</span><br></pre></td></tr></table></figure>
<blockquote>
<p>高深的地方</p>
</blockquote>
<ul>
<li>在源代码里是非法的，但在java的字节码里是允许存在的(JVM里允许)</li>
<li>对于我们来说，编译器不让你做就别做！！！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void f()&#123;&#125;</span><br><span class="line">int f()&#123;return 1;&#125;</span><br><span class="line">// 在源代码里是非法的，但在java的字节码里是允许存在的。</span><br></pre></td></tr></table></figure>
<h4 id="如何为方法提供默认值"><a href="#如何为方法提供默认值" class="headerlink" title="如何为方法提供默认值"></a>如何为方法提供默认值</h4><ul>
<li>答案是在java是不行的,只能这样</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void a()&#123;</span><br><span class="line">    System.out.println(&quot;喵&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void a(String a)&#123;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在其他语言，如js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function a(val = &quot;miao&quot;)&#123;</span><br><span class="line">    console.log(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构造器重载的例子"><a href="#构造器重载的例子" class="headerlink" title="构造器重载的例子"></a>构造器重载的例子</h4><ul>
<li>HashMap</li>
</ul>
<h3 id="对象的初始化过程"><a href="#对象的初始化过程" class="headerlink" title="对象的初始化过程"></a>对象的初始化过程</h3><ul>
<li>必要的初始化工作<ol>
<li>静态成员初始化</li>
<li>静态初始化块</li>
<li>成员初始化</li>
<li>初始化块</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Cat&#123;</span><br><span class="line">    static int a = 123;</span><br><span class="line">    static &#123;</span><br><span class="line">        // 这里不能调用 成员方法 f()</span><br><span class="line">        System.out.println(&quot;000&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    int age;</span><br><span class="line">    String name;</span><br><span class="line">    &#123;</span><br><span class="line">        //</span><br><span class="line">        System.out.println(&quot;abc&quot;);</span><br><span class="line">        // 这里可以调用实例方法吗？ 可以的</span><br><span class="line">        // 但是这是非常危险的，因为此阶段 还未调用 构造器 实例对象是残缺不全的</span><br><span class="line">        f();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void f()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    Cat(int age,String name)&#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        new Cat(1,&quot;aaa&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行步骤</p>
<ol>
<li><p>执行入口函数 main之前要先加载类</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">第一步</span><br><span class="line">static int a = 123;</span><br><span class="line">第二步</span><br><span class="line">static &#123;</span><br><span class="line">    // 这里不能调用 成员方法 f()</span><br><span class="line">    System.out.println(&quot;000&quot;);</span><br><span class="line">&#125;</span><br><span class="line">第三步</span><br><span class="line">执行 main 函数 new Cat(1,&quot;aaa&quot;); 开辟内存空间</span><br></pre></td></tr></table></figure>
</li>
<li><p>成员初始化</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第四步</span><br><span class="line">int age = 0;</span><br><span class="line">String name =  &quot;&quot;;</span><br><span class="line">第五步</span><br><span class="line">执行成员方法块</span><br><span class="line">第六步</span><br><span class="line">执行构造器</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="对象的生命周期"><a href="#对象的生命周期" class="headerlink" title="对象的生命周期"></a>对象的生命周期</h3><ul>
<li><p>如果一直新建对象，内存会不会爆？</p>
<ul>
<li><p>可能会</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object[] arr = new Object[10000];</span><br><span class="line">for(int i=0;i&lt;10000;i++)&#123;</span><br><span class="line">    // 每次开辟1MB的空间</span><br><span class="line">    arr[i] = new byte[1024*1024];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 报错 OutOfMemoryError</span><br></pre></td></tr></table></figure>
</li>
<li><p>可能不会, jvm帮你回收 new出来无用的空间</p>
</li>
</ul>
</li>
<li><p>那对象的内存什么时候回收？ <strong>谁也不知道，JVM帮你做</strong></p>
</li>
<li>对象的内存如何被回收？ <strong>不用管，垃圾回收器帮你干</strong> <ul>
<li>GC 垃圾回收器(幕后偷偷帮你做)</li>
</ul>
</li>
<li>JVM怎么知道那个对象没有被用到？<ul>
<li>通过引用链 (GC Roots)</li>
<li>沿着 GC Roots 可达的路径都是活对象，除此之外都是死对象</li>
</ul>
</li>
</ul>
<blockquote>
<p>生活实例</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">内存 =  假设你房子的空间</span><br><span class="line">GC Root = </span><br><span class="line">房间里有一个 你</span><br><span class="line">你.手 = 键盘</span><br><span class="line">键盘.usb = 笔记本</span><br><span class="line">笔记本.usb2 = 鼠标</span><br><span class="line">笔记本.usb3 = 电源</span><br><span class="line"></span><br><span class="line">此时预定义 GCRoot 根就是 “你”</span><br><span class="line">沿着你能找到的所有对象都是好的</span><br><span class="line">地上扔这个喝完的易拉罐，明显是垃圾 可以被干掉了</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对象没有被引用，应该就被回收了吧？    </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这个东西什么时候回收，由不得你。</span><br><span class="line">由JVM自己决定。 可能马上，也可能一直不回收</span><br><span class="line"></span><br><span class="line">GC 也是需要耗费内存空间的。</span><br><span class="line">假设你的空间非常小，GC就会帮你干掉</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不可达的对象会被删除还是什么？</p>
</blockquote>
<ul>
<li>GC 算法（现在的jvm用的是 分代 回收算法）</li>
</ul>
<p>简单理解就是，一块地上盖了楼，现在拆了盖新的楼</p>
<h4 id="分代回收的大概过程"><a href="#分代回收的大概过程" class="headerlink" title="分代回收的大概过程"></a>分代回收的大概过程</h4><ul>
<li>不一定只发生删除</li>
<li>还会发生压缩</li>
</ul>
<p>在内存中除了 占地方 还有一个非常恐怖的事 就是<strong>碎片化</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">比如操场上开始广播体操。 每个人都拉开距离把操场占满了。 每个人占据的实际空间并不大。但是空间被割裂为很碎很碎</span><br><span class="line"></span><br><span class="line">虽然有很大的空间。</span><br><span class="line"></span><br><span class="line">但是此时 如果想在 操场中心建一个花园。 你就做不到了因为 人的分布已经把操场碎片化了。</span><br><span class="line">以至于你不能找到一块 完整的连续的空间 做你想做的事情。</span><br><span class="line">这时候也会抛出内存不足的Error</span><br><span class="line"></span><br><span class="line">因此垃圾回收不仅仅是删除</span><br><span class="line">还可能把这些细碎的内存 “归整” 来释放 完整的连续的空间供其他程序使用</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/03/ZB-010-java对象系统/" data-id="ckkmr2k8900qxfp91mdu2ig5p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/oak/">oak</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ZB-009-java控制流" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/03/ZB-009-java控制流/" class="article-date">
  <time datetime="2019-07-03T12:13:08.000Z" itemprop="datePublished">2019-07-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/03/ZB-009-java控制流/">ZB-009-java控制流</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="方法的控制流"><a href="#方法的控制流" class="headerlink" title="方法的控制流"></a>方法的控制流</h3><ul>
<li>方法调用，就是一个方法栈每当开始一个方法调用的时候就在方法栈上面落上一个方法块(栈帧)，方法调用结束的时候销毁栈帧，控制权交给上一个方法。然后循环往复</li>
</ul>
<h3 id="while和-do-while"><a href="#while和-do-while" class="headerlink" title="while和 do while"></a>while和 do while</h3><p>死循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(true)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>do while </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">while(i &lt;100)&#123;</span><br><span class="line">    i+=1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int j =0;</span><br><span class="line">do&#123;</span><br><span class="line">    System.out.println(i)</span><br><span class="line">    j++;</span><br><span class="line">&#125;while(j&gt;0);</span><br></pre></td></tr></table></figure>
<h3 id="for-和-foreach循环"><a href="#for-和-foreach循环" class="headerlink" title="for 和 foreach循环"></a>for 和 foreach循环</h3><ul>
<li>for循环</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;100;i++)&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>foreach循环(不是java独有的)  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 冒号后面的对象必须实现了  Iterable 接口</span><br><span class="line">for(String e:Iterable&lt;String&gt;)&#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>foreach</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(&quot;1&quot;,&quot;2&quot;);</span><br><span class="line">for(String e:list)&#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a>break 和 continue</h3><ul>
<li>break 立刻结束包裹当前 break 的第一层循环</li>
<li>continue 跳过包裹当前 continue 的第一层循环中的语句，继续下一次循环</li>
<li>break label;</li>
</ul>
<blockquote>
<p>远古黑魔法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    // 这样写是声明了一个 label</span><br><span class="line">    http://google.com </span><br><span class="line">    i++; // label后面必须有一个语句 否则报错</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">～～～～～～～～～～～～～～～～～～～～～～～～～～</span><br><span class="line">// 另一种用法</span><br><span class="line">最外层循环:</span><br><span class="line">for(int i=0;i&lt;100;i++)&#123;</span><br><span class="line">    for(int j=0;j&lt;100;j++)&#123;</span><br><span class="line">        break 最外层循环;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>goto 上古时代控制程序流程的方式</p>
</blockquote>
<ul>
<li>java保留字，不能使用的关键字</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 其他语言 如 C</span><br><span class="line">label:</span><br><span class="line">if(i&lt;100)&#123;</span><br><span class="line">    i++;</span><br><span class="line">    goto label;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><blockquote>
<p>在java中只有三种东西可 switch</p>
<ul>
<li>int/long/char/byte/short</li>
<li>enum</li>
<li>String(JDK7 2011年)</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int i = new Random().nextInt(5);</span><br><span class="line">switch(i)&#123;</span><br><span class="line">    case 0:</span><br><span class="line">        xxx;</span><br><span class="line">        break;</span><br><span class="line">    case 1:</span><br><span class="line">        xxx;</span><br><span class="line">        break;</span><br><span class="line">    case 2:</span><br><span class="line">        xxx;</span><br><span class="line">        break;</span><br><span class="line">    case 3:</span><br><span class="line">        xxx;</span><br><span class="line">        break;</span><br><span class="line">    case 4:</span><br><span class="line">        xxx;</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        xxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>switch 可以贯穿</p>
</blockquote>
<blockquote>
<p>swich的作用域</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int i = new Random().nextInt(5);</span><br><span class="line">switch(i)&#123;</span><br><span class="line">    case 0:</span><br><span class="line">    case 1:</span><br><span class="line">    case 2:&#123;</span><br><span class="line">        String s = &quot;A&quot;;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    case 3:&#123;</span><br><span class="line">        String s = &quot;A&quot;;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    default:</span><br><span class="line">        xxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/03/ZB-009-java控制流/" data-id="ckkmr2k8800qvfp91b0brgnmn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/oak/">oak</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ZB-008-java运算系统" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/02/ZB-008-java运算系统/" class="article-date">
  <time datetime="2019-07-02T13:45:57.000Z" itemprop="datePublished">2019-07-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/02/ZB-008-java运算系统/">ZB-008-java运算系统</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+</span><br><span class="line">- </span><br><span class="line">*</span><br><span class="line">/</span><br><span class="line">% 取余  取余运算是带符号运算</span><br><span class="line"></span><br><span class="line">+=</span><br><span class="line">-=</span><br><span class="line">*=</span><br><span class="line">/=</span><br><span class="line">%=</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int a = 1 + 1; // int</span><br><span class="line">int b = 5 / 2; // int</span><br><span class="line"></span><br><span class="line">5.0/2; double</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 是否是奇数</span><br><span class="line">public static boolean isOdd(int n)&#123;</span><br><span class="line">    reutrn n % 2 !=0; </span><br><span class="line">    // n % 2 == 1; 取余是带符号运算</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自增自减"><a href="#自增自减" class="headerlink" title="自增自减"></a>自增自减</h3><ul>
<li><code>++</code></li>
<li><code>--</code></li>
</ul>
<p><code>i++</code> 和 <code>++i</code> 不一样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">int b = 0;</span><br><span class="line"></span><br><span class="line">System.out.println(a++); // 0</span><br><span class="line">System.out.println(++b); // 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a++ 分两步</span><br><span class="line">1. a = 0 作为表达式的值</span><br><span class="line">2. a = a + 1 </span><br><span class="line"></span><br><span class="line">++b 分两步</span><br><span class="line">1. a = a + 1 作为表达式的值</span><br><span class="line">2. 把结果作为表达式的值</span><br></pre></td></tr></table></figure>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><ul>
<li><code>&gt;</code></li>
<li><code>&lt;</code></li>
<li><code>&gt;=</code></li>
<li><code>&lt;=</code></li>
<li><code>==</code></li>
<li><code>!=</code></li>
</ul>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul>
<li><code>&amp;&amp;</code> 与</li>
<li><code>||</code> 或</li>
<li><code>!</code> 非</li>
<li>短路特性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Boolean b = ?</span><br><span class="line"></span><br><span class="line">// 1 true =&gt; ture</span><br><span class="line">// 2 false =&gt; false</span><br><span class="line">// 3 null =&gt; false</span><br><span class="line"></span><br><span class="line">// 使用短路特性，如果不是 b = null的时候报错 空指针</span><br><span class="line">if( b != null &amp;&amp; b)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三元运算"><a href="#三元运算" class="headerlink" title="三元运算"></a>三元运算</h3><ul>
<li><code>?:</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = 3;</span><br><span class="line">int res = a &gt; 3 ? 1: -1;</span><br></pre></td></tr></table></figure>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><ul>
<li><code>~</code>按位取反</li>
<li><code>&amp; &amp;=</code> 按位与</li>
<li><code>| |=</code> 按位或</li>
<li><code>^ ^=</code> 异或</li>
<li><code>&lt;&lt; &lt;&lt;=</code> 带符号左移</li>
<li><code>&gt;&gt; &gt;&gt;=</code> 带符号右移</li>
<li><code>&gt;&gt;&gt; &gt;&gt;&gt;=</code> 无符号右移(总是补0)</li>
</ul>
<blockquote>
<p>取反</p>
</blockquote>
<p>计算机中 <strong>负数使用 补码表示的</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int a = 3;</span><br><span class="line">存在计算机里是 32位 4字节</span><br><span class="line">00000000 00000000 00000000 00000011</span><br><span class="line"></span><br><span class="line">~a 得到什么？ -4 为啥</span><br><span class="line"></span><br><span class="line">补码 ===&gt; 按位取反</span><br><span class="line">0000 0011 数字3</span><br><span class="line">第一步 按位取反</span><br><span class="line">1111 1100</span><br><span class="line">第二步 补码 = 反码+1</span><br><span class="line">1111 1101 得到数字-3</span><br><span class="line"></span><br><span class="line">如果首位为“符号位” 那么</span><br><span class="line">00000011 是数字 3</span><br><span class="line">10000011 是数字 -3</span><br><span class="line"></span><br><span class="line">如果是无符号就要用到补码了</span><br></pre></td></tr></table></figure>
<h3 id="烧脑的来了"><a href="#烧脑的来了" class="headerlink" title="烧脑的来了"></a>烧脑的来了</h3><p><code>+ - * /</code> 是在电脑中的 <strong>CPU</strong> 负责运算的，是一种硬件电路</p>
<ul>
<li><p>对于基本的运算 <code>+ -</code> 我们能不能统一为一种电路</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">就是一种 加法 的运算 既可以处理 &quot;+&quot; 也可以处理 “-”</span><br></pre></td></tr></table></figure>
</li>
<li><p>这种背景下</p>
</li>
<li>补码出现了</li>
</ul>
<blockquote>
<p>例子 5 - 3 </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">5 - 3 等价于 5 + (-3)</span><br><span class="line"></span><br><span class="line">这样就可以用 “加法” 来完成  5 - 3 的运算</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5 的二进制表示</span><br><span class="line">0000 0101</span><br><span class="line"></span><br><span class="line">3 的二进制表示</span><br><span class="line">0000 0011</span><br><span class="line"></span><br><span class="line">-3 的二进制表示 </span><br><span class="line">0000 0011 数字 3 取反 </span><br><span class="line">1111 1100 反码  计算机里代表 -4</span><br><span class="line">1111 1101 补码</span><br><span class="line"></span><br><span class="line">5 + (-3)</span><br><span class="line">    0000 0101</span><br><span class="line">    1111 1101</span><br><span class="line">-------------</span><br><span class="line">    0000 0010</span><br></pre></td></tr></table></figure>
<h3 id="amp-amp-按位与-按位或"><a href="#amp-amp-按位与-按位或" class="headerlink" title="&amp; &amp;= 按位与| |= 按位或"></a><code>&amp; &amp;=</code> 按位与<code>| |=</code> 按位或</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">3 按位与 5</span><br><span class="line"></span><br><span class="line">0000 0011 =&gt; 5</span><br><span class="line">0000 0101 =&gt; 3</span><br><span class="line">————————————</span><br><span class="line">0000 0001 =&gt; 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6 按位或 8</span><br><span class="line"></span><br><span class="line">0000 0110 =&gt; 6</span><br><span class="line">0000 1000 =&gt; 8</span><br><span class="line">————————————</span><br><span class="line">0000 1110 =&gt; E</span><br></pre></td></tr></table></figure>
<h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">5 异或 7</span><br><span class="line">0000 0101 =&gt; 5</span><br><span class="line">0000 0111 =&gt; 7</span><br><span class="line">_____________</span><br><span class="line">0000 0010 =&gt; 2</span><br><span class="line"></span><br><span class="line">不进位加法</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="NB的异或公式"><a href="#NB的异或公式" class="headerlink" title="NB的异或公式"></a>NB的异或公式</h4></blockquote>
<ul>
<li>用处就是有些算法题可以用来加速计算  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在一个很长的数组里找一个数字 独立存在的数字 答案是 3</span><br><span class="line">[11,22,33,44,12,12,4,3,4] 把所有数字全部异或一次</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x ^ y ^ y = x</span><br><span class="line"></span><br><span class="line">x ^ x = 0</span><br></pre></td></tr></table></figure>
<h3 id="左移-lt-lt"><a href="#左移-lt-lt" class="headerlink" title="左移&lt;&lt;"></a>左移<code>&lt;&lt;</code></h3><ul>
<li>左移的好处就是比乘法操作快</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">数字 5</span><br><span class="line">0000 0101</span><br><span class="line">&lt;&lt;</span><br><span class="line">0000 1010 得到 10 </span><br><span class="line"></span><br><span class="line">每左移一位 实际就是 *2</span><br><span class="line"></span><br><span class="line">5左移1位 ==&gt; 5*2 = 10</span><br><span class="line">5左移2位 ==&gt; 5*4 = 20</span><br></pre></td></tr></table></figure>
<h3 id="右移-gt-gt"><a href="#右移-gt-gt" class="headerlink" title="右移 &gt;&gt;"></a>右移 <code>&gt;&gt;</code></h3><ul>
<li>带符号   首位补 原先的符号位</li>
<li>不带符号 首位补0</li>
</ul>
<h3 id="位运算的场景"><a href="#位运算的场景" class="headerlink" title="位运算的场景"></a>位运算的场景</h3><ul>
<li><code>Modifier类</code></li>
</ul>
<blockquote>
<p>假设你有猫的 <strong>32个boolean值属性</strong> 萌不萌 胖不胖</p>
</blockquote>
<ul>
<li>第一种方式 存放32个 boolean 成员属性，这样导致每个布尔值(1字节)占据 32字节</li>
<li>另一种选择：<strong>一个int是 32位01组成,每位代表之前的boolean属性</strong> 这样 从32个字节 变成了 4字节</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Cat&#123;</span><br><span class="line">    public static final int 萌不萌 = 0x00000001;</span><br><span class="line">    public static final int 胖不胖 = 0x00000002;</span><br><span class="line">    public static final int 爱吃鱼 = 0x00000004;</span><br><span class="line">    public static final int 爱老鼠 = 0x00000008;</span><br><span class="line">    // 等等... </span><br><span class="line"></span><br><span class="line">    public static int final state = </span><br><span class="line">    Cat.萌不萌 | Cat.胖不胖 | Cat.爱吃鱼 | Cat.爱老鼠;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">0x00000001 =&gt; 16进制最后一位换成4位2进制数 0001 萌不萌</span><br><span class="line">0x00000002 =&gt; 16进制最后一位换成4位2进制数 0010 胖不胖</span><br><span class="line">0x00000004 =&gt; 16进制最后一位换成4位2进制数 0100 爱吃鱼</span><br><span class="line">0x00000008 =&gt; 16进制最后一位换成4位2进制数 1000 爱老鼠</span><br><span class="line"></span><br><span class="line">正好 每个位置的 “ 1 ”  都是错开的</span><br><span class="line"></span><br><span class="line">此时设置属性的时候只要 “或” </span><br><span class="line">public static int final state = </span><br><span class="line">    Cat.萌不萌 | Cat.胖不胖 | Cat.爱吃鱼 | Cat.爱老鼠;</span><br><span class="line">// 按位或之后得到 0000 1111</span><br><span class="line"></span><br><span class="line">那么我们如何知道 Cat 萌不萌 呢？</span><br><span class="line">只需要它让一个定义好的数字 &amp; 运算就行了</span><br><span class="line"></span><br><span class="line">// 萌不萌？</span><br><span class="line">1111 // 全部的 state </span><br><span class="line">0001 // 萌不萌的实际取值</span><br><span class="line">// 按位与的结果为</span><br><span class="line">res = 0001 </span><br><span class="line"></span><br><span class="line">结果只要比较 res 是不是 0 即可</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>设置值时候使用 按位或 ｜</strong></li>
<li><strong>取值值时候使用 按位与 &amp;</strong></li>
</ul>
<blockquote>
<p>参考练习题</p>
</blockquote>
<ul>
<li><a href="https://github.com/hcsp/bit-operation-setter-getter" target="_blank" rel="noopener">https://github.com/hcsp/bit-operation-setter-getter</a></li>
</ul>
<h3 id="字符串加法操作"><a href="#字符串加法操作" class="headerlink" title="字符串加法操作"></a>字符串加法操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">int b = 2;</span><br><span class="line">System.out.println(&quot;a=&quot; + a + &quot;,b=&quot; + b);</span><br><span class="line"></span><br><span class="line">// 你可以给 StringBuilder 打断点，因为字符串是不可变字符序列，所以 频繁拼接很浪费空间，于是会使用 StringBuilder 对一块内存进行操作</span><br></pre></td></tr></table></figure>
<ul>
<li>当你进行字符串加法的时候：它会调用这个对象的 toString, (a.toString(),b.toString())</li>
<li>然后在你进行很长的字符串加法时候，JDK内部会自动的帮你转化成 StringBuilder 调用，减轻内存压力，提高性能。</li>
</ul>
<h3 id="判断-char-类型-合法字符问题"><a href="#判断-char-类型-合法字符问题" class="headerlink" title="判断 char 类型 合法字符问题"></a>判断 char 类型 合法字符问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 一个合法的十六进制的字符是：字符0-9，以及字符A/a/B/b/C/c/D/d/E/e/F/f （大小写都是合法的）</span><br><span class="line">// 编写一个方法，给定一个字符，若是合法的十六进制字符，返回true，否则返回false</span><br><span class="line">public static boolean isValidHexCharacter(char ch) &#123;</span><br><span class="line">  return (ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos;)</span><br><span class="line">          || (ch &gt;= &apos;a&apos; &amp;&amp; ch &lt;= &apos;f&apos;)</span><br><span class="line">          || (ch &gt;= &apos;A&apos; &amp;&amp; ch &lt;= &apos;F&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/02/ZB-008-java运算系统/" data-id="ckkmr2k8700qtfp91tqwwf5fs" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/oak/">oak</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ZB-007-java数据类型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/01/ZB-007-java数据类型/" class="article-date">
  <time datetime="2019-07-01T14:30:28.000Z" itemprop="datePublished">2019-07-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/01/ZB-007-java数据类型/">ZB-007-java数据类型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li><p>int 4字节 (4bytes 32bit)</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">int b = 011; //8进制</span><br><span class="line">int c = 0x11; // 16进制</span><br></pre></td></tr></table></figure>
</li>
<li><p>char 2字节</p>
</li>
<li>short 2字节</li>
</ul>
<h3 id="原生数据类型和引用数据类型"><a href="#原生数据类型和引用数据类型" class="headerlink" title="原生数据类型和引用数据类型"></a>原生数据类型和引用数据类型</h3><table>
<thead>
<tr>
<th>原生</th>
<th>引用</th>
</tr>
</thead>
<tbody>
<tr>
<td>int a= 1</td>
<td>String s = “a”</td>
</tr>
<tr>
<td>4字节存放 1这个值</td>
<td>假设 地址值：1234 存放 字符串”a”</td>
</tr>
</tbody>
</table>
<ul>
<li>只要能找到对应的类，就是引用数据类型</li>
<li>否则是原生数据类型</li>
</ul>
<blockquote>
<h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4></blockquote>
<ul>
<li>byte  1字节</li>
<li>short 2字节</li>
<li>int 4字节（最大21亿）<br>  <strong>针对淘宝这种亿级用户最好不要用int使用 long</strong></li>
<li>long 8字节</li>
<li>float 4字节</li>
<li>double 8字节</li>
<li>char 2字节</li>
<li>boolean true/false</li>
<li>void? 不返回任何类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">byte b = (byte)128; // 会丢失精度</span><br><span class="line">long c = 22_0000_0000L; // 不推荐用 &quot;l&quot; 与 “1” 容易歧义</span><br><span class="line">float d = 0.1f;</span><br><span class="line">double e = 2e-3; //科学计数法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// </span><br><span class="line">int f = 0x123;  // 十六进制</span><br><span class="line">int g = 0b1010101; // 二进制， java7之后出现的</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果你想知道原生数据类型的最大最小值是什么？</p>
</blockquote>
<ul>
<li>每一个原生数据类型对应一个装箱数据类型</li>
<li>对应的装箱数据类型里有两个常量 MIN_VALUE/MAX_VALUE</li>
</ul>
<blockquote>
<p>问题来了？如果强行存储超过范围的值会怎么样？</p>
</blockquote>
<ul>
<li>会溢出</li>
</ul>
<blockquote>
<p>浮点数是小数，在计算机中是<strong>近似表示</strong></p>
</blockquote>
<ul>
<li>浮点数只能比较大小，不要比较“<strong>相等</strong>”</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// </span><br><span class="line">float i = 0.1f;</span><br><span class="line">if(i==0.1f)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double d = 0.2;</span><br><span class="line">if(Math.abs(d - 0.2) &lt; 0.000001)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ol>
<li>整数除法是地板除</li>
<li><p>将所有类型提升到最⾼精度进⾏计算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i = 1 + 1; // ok</span><br><span class="line">int b = 1 + 1.0;// not ,因为 1.0是双精度所以 类型都被提升了， 所以 结果是 double 值 需要强制类型转化 </span><br><span class="line">int c = (int)(1 + 1.0); // ok</span><br></pre></td></tr></table></figure>
</li>
<li><p>丢失精度时需要进⾏强制转换</p>
</li>
<li>char参与计算时使⽤ASCII码（Unicode码） <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char c1 = &apos;a&apos;;</span><br><span class="line">char c2 = &apos;A&apos;;</span><br><span class="line">char c3 = &apos;你&apos;;</span><br><span class="line"></span><br><span class="line">char c4 = &apos;1&apos;; // 对应ASC码 为 49</span><br><span class="line">// c4 = c4 + 1; // 报错因为 + 1 是和 int值进行计</span><br><span class="line">算 必须进行强制转换</span><br><span class="line">c4 = (char)(c4 + 1); // c4的值是49 ,49+1 =50 ，50对应的字符是 &apos;2&apos;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p>自动转换</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte b = 100;</span><br><span class="line">int i = b; // 可以直接转换</span><br></pre></td></tr></table></figure>
</li>
<li><p>强制转换</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i = 200;</span><br><span class="line">byte b = (byte) i; // 因为已经溢出了，所以要强制转换</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<h3 id="整数除法计算是-地板除-向下取整"><a href="#整数除法计算是-地板除-向下取整" class="headerlink" title="整数除法计算是 地板除(向下取整)"></a>整数除法计算是 地板除(向下取整)</h3></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int a = 3;</span><br><span class="line">int b = 2;</span><br><span class="line">int c = a / b; // 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 因为设置了返回值是 double 所以 result 会自动提升为 double</span><br><span class="line">public static double divide(int a ,int b)&#123;</span><br><span class="line">    int result = a / b;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">divide(3,2) //  1.0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>精度问题,<strong>所有表达式中，参与计算的表达式都会提升到最高的精度进行计算，最后的结果也是最高精度</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i = 1 + 1; // 没问题</span><br><span class="line"></span><br><span class="line">// int i2 = 1 + 1.0; // 有问题 与浮点数计算会变成double</span><br><span class="line">// 只能这样 强制转换</span><br><span class="line">int i2 = (int)(1 + 1.0);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解决整型地板除损失精度问题</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static double divide(int a ,int b)&#123;</span><br><span class="line">    double result = 1.0 * a / b;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line"></span><br><span class="line">public static double divide(int a ,int b)&#123;</span><br><span class="line">    double result = (double)a / b;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="void-类型"><a href="#void-类型" class="headerlink" title="void 类型"></a>void 类型</h4></blockquote>
<ul>
<li>所有的类型可以  类型.class 得到它的 class值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class c = String.class;</span><br><span class="line">Class intCLass = int.class;</span><br><span class="line">Class voidCLass = void.class;</span><br></pre></td></tr></table></figure>
<h3 id="装箱类型-引用类型"><a href="#装箱类型-引用类型" class="headerlink" title="装箱类型(引用类型)"></a>装箱类型(引用类型)</h3><ul>
<li>Byte(byte)</li>
<li>Short(short)</li>
<li>Integer(int)</li>
<li>Long(long)</li>
<li>Float(float)</li>
<li>Double(double)</li>
<li>Character(char)</li>
<li>Boolean(boolean)</li>
<li>Void?(void)</li>
</ul>
<p>任何原生数据类型都有对应的装箱类型</p>
<blockquote>
<p>自动装箱/自动拆箱</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static int add(int i)&#123; return new Integer(i);&#125;</span><br><span class="line"></span><br><span class="line">int i = 100;</span><br><span class="line">Integer integer = i; // 自动装箱</span><br><span class="line">add(integer); // 自动拆箱</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么要有引用类型</p>
<ul>
<li>容器类不接受原⽣数据类型  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// List里只接受引用类型，不接受原生类型</span><br><span class="line">List&lt;Integer&gt; a = new ArrayList&lt;&gt;();</span><br><span class="line">a.add(1); // 丢进去的是 int 自动装箱 为 Integer</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<ul>
<li><p>可以赋值为null</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// boolean 只能有两种状态 true/false</span><br><span class="line"></span><br><span class="line">// 而装箱类型还有第三种状态 true/false/null</span><br><span class="line">Boolean state = null;</span><br></pre></td></tr></table></figure>
</li>
<li><p>提供额外的⽅法</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;123&quot;;</span><br><span class="line">// 内存中对应 是一个 char[] 数组  </span><br><span class="line"></span><br><span class="line">// 而数字 内存中 4字节 01组成的序列</span><br><span class="line">int i = 123;</span><br></pre></td></tr></table></figure>
</li>
<li><p>⾃动装箱与拆箱</p>
</li>
</ul>
<h3 id="原⽣类型与引⽤类型带来的坑"><a href="#原⽣类型与引⽤类型带来的坑" class="headerlink" title="原⽣类型与引⽤类型带来的坑"></a>原⽣类型与引⽤类型带来的坑</h3><ul>
<li><p>对null拆箱将引发空指针异常</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer a = null;</span><br><span class="line">int i = a;// 空指针异常</span><br></pre></td></tr></table></figure>
</li>
<li><p>==与equals约定</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int a = 5;</span><br><span class="line">int b = 5;</span><br><span class="line">a == b // true</span><br><span class="line"></span><br><span class="line">Integer c = 1000; // 假设内存地址 512</span><br><span class="line">Integer d = 1000; // 假设内存地址 600</span><br><span class="line">c == d // false 因为 “==“ 比较的是值，而引用类型的值是 ”地址“  512 != 600</span><br><span class="line"></span><br><span class="line">c.equals(d) // true</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>“==” </p>
</blockquote>
<p>比较二者是否相同</p>
<blockquote>
<p>“equals()”</p>
</blockquote>
<p>比较二者是否是不是相等</p>
<ul>
<li><h4 id="让你惊讶的地方！！！"><a href="#让你惊讶的地方！！！" class="headerlink" title="让你惊讶的地方！！！"></a>让你惊讶的地方！！！</h4></li>
<li><h4 id="让你惊讶的地方！！！-1"><a href="#让你惊讶的地方！！！-1" class="headerlink" title="让你惊讶的地方！！！"></a>让你惊讶的地方！！！</h4></li>
<li><h4 id="让你惊讶的地方！！！-2"><a href="#让你惊讶的地方！！！-2" class="headerlink" title="让你惊讶的地方！！！"></a>让你惊讶的地方！！！</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Integer e = 1;</span><br><span class="line">Integer f = 1;</span><br><span class="line"></span><br><span class="line">e == f // true 竟然相等了？ </span><br><span class="line">e.equals(f) // true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int类型是占据 4字节的空间，</span><br><span class="line">而 Object / Integer 这类引用数据类型 远比int占据的空间要多</span><br><span class="line"></span><br><span class="line">如果你频繁 </span><br><span class="line">Ingeter i = 1;  // 占据空间远远大于4字节</span><br><span class="line">Ingeter b = 2;  // 占据空间远远大于4字节</span><br><span class="line"></span><br><span class="line">所以java偷偷做了一件事</span><br><span class="line">对于非常小的数字则认为是常用的数字。</span><br><span class="line">则对其进行缓存 具体参考 IntegerCache的文档</span><br><span class="line">会对 -128～+127的 数字进行缓存，而不是重新创建对象</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>顺便提一句：Integer对象是不可变的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer c = 1; // 内存地址 509</span><br><span class="line">c = c + 1; // +1 操作 此时 c的地址变成了 512</span><br><span class="line">// Integer 本身是不可变的</span><br></pre></td></tr></table></figure>
<h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><blockquote>
<p>面试题：请你给我解释一下数组是什么，为啥我没看见过数组类型的声明，却可以直接用呢？</p>
</blockquote>
<ul>
<li>数组类型是一种特殊的类型，JDK负责创建它</li>
</ul>
<blockquote>
<p>由JDK负责创建的特殊类型</p>
</blockquote>
<ul>
<li><code>X[] x = new X[10]</code> 长度为10的数组</li>
<li><code>X[] x = new X[]{5,4,3,2,1}</code> 长度为5的数组</li>
<li><code>X[] x = {5,4,3,2,1}</code></li>
<li>其中 X 也可以是数组类型   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[][] c = new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>数组的主要特性</p>
</blockquote>
<ul>
<li>长度不可变</li>
<li>类型安全 <code>String[] c = {&quot;a&quot;,&quot;b&quot;}; // 声明了是 String 就不能丢其他类型的东西</code></li>
<li>只有一个 length 属性</li>
<li>可以用下标去取对应元素 <code>a[1]</code></li>
<li>可以使用 for 循环</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/01/ZB-007-java数据类型/" data-id="ckkmr2k8700qrfp91matqtk9n" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/oak/">oak</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ZB-006-工具使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/01/ZB-006-工具使用/" class="article-date">
  <time datetime="2019-07-01T13:50:31.000Z" itemprop="datePublished">2019-07-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/01/ZB-006-工具使用/">ZB-006-工具使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h3><ul>
<li>提供一个生命周期流程</li>
<li>每个插件可以把一小部分工作绑定到生命周期上</li>
<li>maven本身对这些事不做任何干涉，只定义生命周期</li>
<li>maven 每个阶段执行时都会把前面的每个阶段执行一遍</li>
<li><a href="https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html" target="_blank" rel="noopener">maven default lifecycle</a></li>
</ul>
<blockquote>
<p>参考资料</p>
</blockquote>
<ul>
<li><a href="https://github.com/slTrust/javaweb/tree/master/web012maven%E4%BD%BF%E7%94%A8" target="_blank" rel="noopener">https://github.com/slTrust/javaweb/tree/master/web012maven%E4%BD%BF%E7%94%A8</a></li>
</ul>
<blockquote>
<p>maven依赖的问题——传递性依赖</p>
</blockquote>
<ul>
<li>你的项目依赖多个库 A、B、C</li>
<li>而这个库A又依赖别的库 如C</li>
<li>此时 多个地方依赖 C C的版本如果不一致就会有问题</li>
</ul>
<blockquote>
<p>maven显示依赖树</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn dependency:tree</span><br></pre></td></tr></table></figure>
<h3 id="IDEA生产力翻倍的快捷键"><a href="#IDEA生产力翻倍的快捷键" class="headerlink" title="IDEA生产力翻倍的快捷键"></a>IDEA生产力翻倍的快捷键</h3><ul>
<li>万能键 ALT + ENTER 任何情况都可以使用</li>
<li>左侧项目结构面板右上角有个按钮 Scroll from Source 从源代码跳转</li>
<li>Search  everywhere: 双击 shift</li>
<li>查看定义：Declaration (command + B) (等价于按住command + 鼠标右键)</li>
<li>查看⽂件：Navigate - File</li>
<li><strong>⾼级查找</strong>：Find in Path (顶栏Edit-Find-Find in Path) 几乎满足你查找的所有需求(command + shift + f)</li>
<li>快速⽣成：Generate(ctrl +  N)</li>
<li>格式化：Reformat Code(alt + command + L)</li>
<li>优化导⼊语句：Optimize imports(alt + command + O)<ul>
<li>比如你代码里开始用了 ArrayList,后来不用了，但是会被导入，这个时候用这个</li>
</ul>
</li>
<li>导航：Navigate - Back/Forward(alt + command + ⬅️ ➡️)</li>
<li>所有的实现类：Implementation(command + 1)</li>
<li>谁调⽤了这个⽅法：Call Hierarchy(command + 2)</li>
<li>⽂件⼤纲：File Structure (command + 3)<ul>
<li>列出这个类的所有方法，成员</li>
</ul>
</li>
<li>下⼀处错误：Next Highlighted Error （command + 4）</li>
<li><strong>⾼级重命名</strong>：Rename (command + 5)</li>
<li>调试器快捷键：F5/F6/F7/F8</li>
</ul>
<h3 id="Git相关操作"><a href="#Git相关操作" class="headerlink" title="Git相关操作"></a>Git相关操作</h3><ul>
<li>查找背锅侠：Annotate/Blame</li>
<li>查看当前⽂件的历史版本</li>
<li>⾼级筛选⽅式查找commit记录</li>
<li>显示差异：show diff</li>
<li>Open in GitHub (选中你的代码 右键列表里)</li>
</ul>
<blockquote>
<h4 id="底部工具栏-Version-Control"><a href="#底部工具栏-Version-Control" class="headerlink" title="底部工具栏 Version Control"></a>底部工具栏 Version Control</h4></blockquote>
<ul>
<li>Local Changes 等同于 git status 本地的变更还没有提交</li>
<li>Log 这个仓库里所有的日志</li>
</ul>
<h4 id="编程快捷键"><a href="#编程快捷键" class="headerlink" title="编程快捷键"></a>编程快捷键</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">psvm ==&gt; public static void main()&#123;&#125;</span><br><span class="line"></span><br><span class="line">sout ==&gt; System.out.println()</span><br><span class="line"></span><br><span class="line">soutv ==&gt; System.out.println(&quot;xxx=&quot; + xxx)</span><br><span class="line"></span><br><span class="line">fori ==&gt; for(int i = 0 ; i &lt; ;i++)</span><br><span class="line"></span><br><span class="line">fore ==&gt; ...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>寻找配对括号的小插件</p>
</blockquote>
<ul>
<li>Rainbow Brackets</li>
</ul>
<h3 id="调试器：没有解决不了的问题"><a href="#调试器：没有解决不了的问题" class="headerlink" title="调试器：没有解决不了的问题"></a>调试器：没有解决不了的问题</h3><blockquote>
<p>为什么需要调试器</p>
<ul>
<li>理解程序执⾏的过程</li>
<li>理解JVM的内部构造</li>
<li>⾮常⽅便的检查在任意时间点JVM的内部状态</li>
</ul>
</blockquote>
<blockquote>
<h4 id="调试器"><a href="#调试器" class="headerlink" title="调试器"></a>调试器</h4></blockquote>
<ul>
<li>单步跳过  ,Step over 执行一行,无论当前行的语句有多么的复杂。</li>
<li>单步进⼊  , Step into 执行一个语句。进入这个方法的执行(最详细的方法执行)。</li>
<li>单步跳出</li>
<li>全速运⾏ Resume Program （F8）恢复程序，当前的程序全速跑到下一个断点</li>
<li>断点（⾯板）</li>
<li>条件断点 (所在行设置断点，点击右键弹出一个框 Condition 输入 i==5000 当i=5000的时候)</li>
<li>跳转到源代码</li>
<li>Watch</li>
</ul>
<p><img src="https://raw.githubusercontent.com/slTrust/java_static_repo/main/java006/001.png" alt></p>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ul>
<li>堆 所有对象都在堆上分配</li>
<li>栈 (假设现在只有一个线程。每个线程有一个方法栈。方法的入口就是main方法。每次调用一个方法就会压栈，方法结束就会出栈)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        a();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void a() &#123;</span><br><span class="line">        System.out.println(&quot;a&quot;);</span><br><span class="line">        b();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void b() &#123;</span><br><span class="line">        System.out.println(&quot;b&quot;);</span><br><span class="line">        c();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void c() &#123;</span><br><span class="line">        int x = 1;</span><br><span class="line">        System.out.println(&quot;c&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数一次一次调用形成的方法块叫什么</p>
</blockquote>
<ul>
<li>栈帧</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c执行结束 它里面的局部变量x会被销毁</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="执行表达式"><a href="#执行表达式" class="headerlink" title="执行表达式"></a>执行表达式</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">打断点后，选中所在行右键选择Evaluate Expression</span><br><span class="line"></span><br><span class="line">输入框里可写任意代码</span><br></pre></td></tr></table></figure>
<blockquote>
<p>鬼畜的用法，打破流程,不推荐用</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return result; // 右键， View/Edit Text 修改为你要返回的内容</span><br></pre></td></tr></table></figure>
<h3 id="调试器的原理"><a href="#调试器的原理" class="headerlink" title="调试器的原理"></a>调试器的原理</h3><ul>
<li>调试⾮项⽬源代码</li>
<li>调试命令⾏程序</li>
</ul>
<h4 id="调试-mvn-compile-过程的代码"><a href="#调试-mvn-compile-过程的代码" class="headerlink" title="调试 mvn compile 过程的代码"></a>调试 mvn compile 过程的代码</h4><ul>
<li>你想调试什么东西，首先要拿到这个东西的源代码</li>
<li>比如调试 mvn compile，本质也是一个JVM</li>
<li><a href="https://github.com/apache/maven-compiler-plugin" target="_blank" rel="noopener">google 搜索maven compiler plugin github</a> 把代码clone到本地</li>
<li>mvn 除了这个命令，还有一个调试版的命令 mvnDebug</li>
<li>你可以这样运行 <code>/Users/hjx/maven/apache-maven-3.6.3/bin/mvnDebug compile</code>  这就是 debug模式运行 mvn</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 1。 找到你本地 mvn的 debug模式命令</span><br><span class="line">&gt; /Users/hjx/maven/apache-maven-3.6.2/bin/</span><br><span class="line">mvnDebug compile</span><br><span class="line"></span><br><span class="line"># 2。 debug 模式运行 mvn,监听在 8000端口</span><br><span class="line">Preparing to execute Maven in debug mode</span><br><span class="line">Listening for transport dt_socket at address: 8000</span><br><span class="line"></span><br><span class="line"># 3。 此时在 IDEA里 编辑器右边顶部 的 add Configuration 里 “加号 + ”选择 Remote ，Port填入 8000，然后 ok</span><br><span class="line">    # 为什么是 Remote 这个过程不仅可以发生在你本地，还可以发生在你的生产服务器</span><br><span class="line"># 然后在 mvn compile 源代码的 CompilerMojo 里 skipMain 这行 176</span><br><span class="line"></span><br><span class="line"># 4。 然后 debug模式运行，你发现代码没有停在这里，不要开始怀疑人生， 要看你本地的 mvn版本 和代码的版本是否是一个版本</span><br><span class="line"></span><br><span class="line"># 5。 源代码终端输入 git tag 找到跟你本地一致的版本号 如 3.6.2</span><br><span class="line"></span><br><span class="line"># 6。 切换本地代码版本 </span><br><span class="line">git checkout maven-compiler-plugin-3.6.2</span><br><span class="line"></span><br><span class="line"># 7。 在此 debug运行代码</span><br><span class="line"></span><br><span class="line">此时你就可以调试 mvn compile 了</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/01/ZB-006-工具使用/" data-id="ckkmr2k8600qpfp91f5dto5at" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/oak/">oak</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ZB-005-JAVA基本结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/30/ZB-005-JAVA基本结构/" class="article-date">
  <time datetime="2019-06-30T12:22:40.000Z" itemprop="datePublished">2019-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/30/ZB-005-JAVA基本结构/">ZB-005-JAVA基本结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="JAVA介绍"><a href="#JAVA介绍" class="headerlink" title="JAVA介绍"></a>JAVA介绍</h3><ol>
<li>强类型</li>
<li>静态编译</li>
<li>跨平台</li>
</ol>
<blockquote>
<p>代码比较死板，但是非常适合团队协作项目。</p>
</blockquote>
<ul>
<li><a href="https://www.zhihu.com/question/56468869/answer/261050848" target="_blank" rel="noopener">如何看待知乎、饿了么后端的招聘纷纷由 Python 渐渐转向 Java？ - 曲奇的回答 - 知乎</a></li>
<li>当你的代码足够庞大时</li>
<li>比如 TS的兴起就是 类型约束和静态编译</li>
</ul>
<blockquote>
<p>什么是操作系统</p>
</blockquote>
<p>比如现在有 windows / mac / linux 三个系统，你要让他们做什么比如 打开文件，发请求就要<strong>使用操作系统的语言(API)和操作系统对话</strong></p>
<p>这样就给软件开发者开了一个很大的难题。你开发了一个软件跑在三个系统上。就要用三个系统的API去分别编写。此时工作量变成了三倍！</p>
<blockquote>
<p>举个例子,比如你要写一本书，三个系统好比三个国家。</p>
</blockquote>
<ul>
<li>你使用了某个语言如 英语 English </li>
<li>此时需要去三个国家找到对应懂英语的人。</li>
<li>这样你只要在每个国家找到懂英语的人。你本来是要为每个国家开发一本书。现在你只需要开发一本书，然后让不同平台懂英语的人翻译成对应国家的语言。</li>
</ul>
<p>这个会翻译的人 在JAVA中就叫 JVM 虚拟机</p>
<p><strong>JVM负责与操作系统的接口打交道，此时你只要写一种语言如java,剩下的交给JVM将 java翻译成中间层的语言 byte code(字节码)</strong></p>
<blockquote>
<p>字节码</p>
</blockquote>
<p>二进制，在计算机里只有0和1</p>
<h4 id="java广告词"><a href="#java广告词" class="headerlink" title="java广告词"></a>java广告词</h4><ul>
<li>一次编写，处处运行。</li>
<li>比如现在的服务器通常是linux，而开发者的电脑可能是 windows 。你在Windows代码可以稳定的跑在linux上。这就是java的可贵之处</li>
<li><a href="https://www.zhihu.com/question/30753144" target="_blank" rel="noopener">知乎：java是如何实现跨平台的？</a></li>
<li><a href="http://www.weixueyuan.net/view/6309.html" target="_blank" rel="noopener">Java虚拟机(JVM)以及跨平台原理</a></li>
</ul>
<h3 id="java语言的基本单元-类-和-包"><a href="#java语言的基本单元-类-和-包" class="headerlink" title="java语言的基本单元 类 和 包"></a>java语言的基本单元 类 和 包</h3><p>class</p>
<ul>
<li>java最小的结构是 类</li>
<li>类必须放在与它同名的 <code>.java</code>文件中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 程序最小的结构是 class</span><br><span class="line">// 直接放在 src/main/java下的包叫做 “默认包”</span><br><span class="line">public class Cat&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="package"><a href="#package" class="headerlink" title="package"></a>package</h4><ul>
<li>每个类都处在一个包中</li>
<li>包的名字由目录结构所确定</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 目录结构为: src/main/java/my/cute</span><br><span class="line">package my.cute;</span><br><span class="line">public class Cat&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="推荐包名规则"><a href="#推荐包名规则" class="headerlink" title="推荐包名规则"></a>推荐包名规则</h5><ul>
<li>java程序约定(我不强制你这么做，但我约定你这么做)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 不建议这样</span><br><span class="line">package my.cute;</span><br><span class="line"></span><br><span class="line"># java推荐约定  包名以你互联网公司域名的反序来命名，这样可以避免命名冲突</span><br><span class="line">package com.alibaba</span><br><span class="line">package com.google</span><br></pre></td></tr></table></figure>
<h4 id="maven的项目约定"><a href="#maven的项目约定" class="headerlink" title="maven的项目约定"></a>maven的项目约定</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 生产代码</span><br><span class="line">src/main/java/my/cute/Cat.java</span><br><span class="line"></span><br><span class="line">// 测试代码</span><br><span class="line">src/test/java/my/cute/CatTest.java</span><br></pre></td></tr></table></figure>
<h4 id="包的意义"><a href="#包的意义" class="headerlink" title="包的意义"></a>包的意义</h4><p>如果存在如下两个同名的类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">src/main/java/my/pet/Cat.java</span><br><span class="line">src/main/java/my/pet2/Cat.java</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 如何在 src/main/java/my/Home.java里引用者两个 Cat呢？</span><br><span class="line"></span><br><span class="line">// Home.java</span><br><span class="line">package my;</span><br><span class="line"></span><br><span class="line">import my.pet.Cat;</span><br><span class="line">// import my.pet2.Cat; </span><br><span class="line"></span><br><span class="line">public class Home&#123;</span><br><span class="line">    Cat cat;</span><br><span class="line">    //全限定类名</span><br><span class="line">    my.pet2.Cat cat2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在JVM中所有的类 都会变成“全限定类名” Full Qualified Name (FQCN)  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Home&#123;</span><br><span class="line">    // 最终都会变成</span><br><span class="line">    my.pet.Cat cat;</span><br><span class="line">    my.pet2.Cat cat2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这就是为什么我们需要“包” 最大的作用就是<strong>避免命名冲突，区分同名但不同的类</strong></p>
<blockquote>
<p>main函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Cat&#123;</span><br><span class="line">    // 程序的入口函数</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>疑问为什么<code>String[] args</code> 里的 String不用写包名 ，如果你用的是 IDEA按住 alt点击进去，发现 String的包名是 <code>package java.lang</code></li>
<li>如果你的类放在 java.lang 下 可以不经引入直接使用</li>
</ul>
<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><ul>
<li>在每个函数调用的时候，它会创建一个全新的函数的执行环境</li>
<li>函数多次调用的过程之间，它们是相互独立的。</li>
<li>函数可以被一次声明，然后多次调用，每次调用的执行环境都是独立的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Cat&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        f(1);</span><br><span class="line">        f(2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void f(int i)&#123;</span><br><span class="line">        return i + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><ul>
<li>包围它的第一对花括号<code>{}</code></li>
</ul>
<h4 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h4><p>存在遥远的jvm的一个地方，独立于任何的对象。和任何对象都没关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Cat&#123;</span><br><span class="line">    public static int i; // 默认会初始化为0</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        add();</span><br><span class="line">        add();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void add()&#123;</span><br><span class="line">        i = i + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="对象-构造器和成员变量"><a href="#对象-构造器和成员变量" class="headerlink" title="对象/构造器和成员变量"></a>对象/构造器和成员变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Home&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Cat cat = new Cat();</span><br><span class="line">        cat.name = &quot;阿三&quot;;</span><br><span class="line">        cat.miao();</span><br><span class="line"></span><br><span class="line">        Cat cat2 = new Cat(&quot;阿大&quot;);</span><br><span class="line">        cat2.miao();</span><br><span class="line"></span><br><span class="line">        Cat cat3 = new Cat();</span><br><span class="line">        cat3.miao(); // 空指针 因为name是null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat&#123;</span><br><span class="line">    // 成员变量</span><br><span class="line">    private String name;</span><br><span class="line">    // 假如你没声明任何的构造器 ,编译器会帮你偷偷生产一个构造器</span><br><span class="line">    //  Cat()&#123;&#125; // 你不写就自带一个</span><br><span class="line"></span><br><span class="line">    public Cat()&#123;&#125;</span><br><span class="line">    // 如果你写了其他构造器，将不再提供默认的无参构造器，而你想调用无参的构造器则要自己写。</span><br><span class="line">    public Cat(String name)&#123;</span><br><span class="line">        // this = 刚刚创建的Cat类的实例</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">    public static void miao()&#123;</span><br><span class="line">        // 报错，静态方法不能调用非静态成员</span><br><span class="line">        System.out.println(&quot;喵,我是&quot;+ name)</span><br><span class="line">    &#125;</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    public void miao()&#123;</span><br><span class="line">        System.out.println(&quot;喵,我是&quot;+ name)</span><br><span class="line">        // 在不引起歧义的情况下，你可以 省略 this</span><br><span class="line">        System.out.println(&quot;喵,我是&quot;+ this.name + &quot;我的名字长度是&quot; + name.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实例方法和空指针异常"><a href="#实例方法和空指针异常" class="headerlink" title="实例方法和空指针异常"></a>实例方法和空指针异常</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Home&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Cat cat = new Cat();</span><br><span class="line">        cat.name = &quot;阿三&quot;;</span><br><span class="line">        cat.miao();</span><br><span class="line"></span><br><span class="line">        Cat cat2 = new Cat(&quot;阿大&quot;);</span><br><span class="line">        cat2.miao();</span><br><span class="line"></span><br><span class="line">        Cat cat3 = new Cat();</span><br><span class="line">        cat3.miao(); // 空指针 因为name是null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat&#123;</span><br><span class="line">    String name;</span><br><span class="line">    public Cat()&#123;&#125;</span><br><span class="line">    public Cat(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void miao()&#123;</span><br><span class="line">        // 非空判断 ，规避空指针</span><br><span class="line">        if(name == null)&#123;</span><br><span class="line">            System.out.println(&quot;我还没名字&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            System.out.println(&quot;喵,我是&quot;+ this.name + &quot;我的名字长度是&quot; + name.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对象和引用、值传递"><a href="#对象和引用、值传递" class="headerlink" title="对象和引用、值传递"></a>对象和引用、值传递</h3><ul>
<li>最重要概念之一</li>
<li>画内存图</li>
<li><p>引用</p>
<ul>
<li>addr</li>
<li>门牌号 201/301/333</li>
</ul>
</li>
<li><p><a href="https://sltrust.github.io/2017/11/19/N021_JS%E9%87%8C%E7%9A%84%E7%B1%BB%E5%9E%8B/" target="_blank" rel="noopener">参考之前的JS总结</a></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/30/ZB-005-JAVA基本结构/" data-id="ckkmr2k8500qnfp91rainhg2c" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/oak/">oak</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/14/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><a class="page-number" href="/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/page/53/">53</a><a class="extend next" rel="next" href="/page/16/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6速学/">ES6速学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS不知深浅/">JS不知深浅</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/M01/">M01</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/M02/">M02</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/M03/">M03</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/M04/">M04</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/M06/">M06</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/M07/">M07</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/M08/">M08</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/M09/">M09</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NodeWeb/">NodeWeb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node后端/">Node后端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ReactWheels/">ReactWheels</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React入门/">React入门</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TS入门/">TS入门</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/express/">express</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fullstack/">fullstack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jQuery/">jQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mobile/">mobile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb/">mongodb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/">node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node每日精进/">node每日精进</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oak/">oak</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tools/">tools</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/">vim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vultr/">vultr</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web性能优化/">web性能优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web面经/">web面经</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端知识点/">前端知识点</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 14.09px;">CSS</a> <a href="/tags/ES6速学/" style="font-size: 13.64px;">ES6速学</a> <a href="/tags/JS不知深浅/" style="font-size: 11.36px;">JS不知深浅</a> <a href="/tags/M01/" style="font-size: 13.64px;">M01</a> <a href="/tags/M02/" style="font-size: 15px;">M02</a> <a href="/tags/M03/" style="font-size: 15.45px;">M03</a> <a href="/tags/M04/" style="font-size: 15.91px;">M04</a> <a href="/tags/M06/" style="font-size: 18.18px;">M06</a> <a href="/tags/M07/" style="font-size: 17.73px;">M07</a> <a href="/tags/M08/" style="font-size: 16.82px;">M08</a> <a href="/tags/M09/" style="font-size: 11.82px;">M09</a> <a href="/tags/NodeWeb/" style="font-size: 12.27px;">NodeWeb</a> <a href="/tags/Node后端/" style="font-size: 18.64px;">Node后端</a> <a href="/tags/ReactWheels/" style="font-size: 16.36px;">ReactWheels</a> <a href="/tags/React入门/" style="font-size: 15px;">React入门</a> <a href="/tags/TS入门/" style="font-size: 14.55px;">TS入门</a> <a href="/tags/express/" style="font-size: 10.45px;">express</a> <a href="/tags/fullstack/" style="font-size: 17.73px;">fullstack</a> <a href="/tags/http/" style="font-size: 12.27px;">http</a> <a href="/tags/jQuery/" style="font-size: 10px;">jQuery</a> <a href="/tags/java/" style="font-size: 19.09px;">java</a> <a href="/tags/linux/" style="font-size: 10.91px;">linux</a> <a href="/tags/mobile/" style="font-size: 11.36px;">mobile</a> <a href="/tags/mongodb/" style="font-size: 12.73px;">mongodb</a> <a href="/tags/mysql/" style="font-size: 12.73px;">mysql</a> <a href="/tags/node/" style="font-size: 10.45px;">node</a> <a href="/tags/node每日精进/" style="font-size: 10px;">node每日精进</a> <a href="/tags/oak/" style="font-size: 20px;">oak</a> <a href="/tags/python/" style="font-size: 17.27px;">python</a> <a href="/tags/tools/" style="font-size: 10px;">tools</a> <a href="/tags/vim/" style="font-size: 10px;">vim</a> <a href="/tags/vue/" style="font-size: 13.18px;">vue</a> <a href="/tags/vultr/" style="font-size: 10px;">vultr</a> <a href="/tags/web性能优化/" style="font-size: 10px;">web性能优化</a> <a href="/tags/web面经/" style="font-size: 10px;">web面经</a> <a href="/tags/前端知识点/" style="font-size: 19.55px;">前端知识点</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/01/20/HTTP06密码学到https流程/">HTTP06密码学到https流程</a>
          </li>
        
          <li>
            <a href="/2021/01/19/HTTP05缓存控制/">HTTP05缓存控制</a>
          </li>
        
          <li>
            <a href="/2021/01/18/HTTP04报文和http状态码/">HTTP04报文和http状态码</a>
          </li>
        
          <li>
            <a href="/2021/01/17/HTTP03http常用方法/">HTTP03http常用方法</a>
          </li>
        
          <li>
            <a href="/2021/01/16/HTTP02三次握手四度挥手/">HTTP02三次握手四度挥手</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Stevin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>