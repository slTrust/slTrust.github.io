
 <!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  
    <title>Almost</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Stevin">
    

    
    <meta property="og:type" content="website">
<meta property="og:title" content="Almost">
<meta property="og:url" content="http://yoursite.com/page/13/index.html">
<meta property="og:site_name" content="Almost">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Almost">

    
    <link rel="alternative" href="/atom.xml" title="Almost" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>
</html>
  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Almost" title="Almost"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Almost">Almost</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/07/05/ZB-013-java多态/" title="ZB-013-java多态" itemprop="url">ZB-013-java多态</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Stevin" target="_blank" itemprop="author">Stevin</a>
		
  <p class="article-time">
    <time datetime="2019-07-05T13:28:53.000Z" itemprop="datePublished"> Published 2019-07-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="什么是多态"><a href="#什么是多态" class="headerlink" title="什么是多态"></a>什么是多态</h3><ul>
<li>实例方法默认是多态的<ul>
<li>在运行时根据this来决定调用那个方法</li>
<li>静态方法没有多态</li>
<li>参数静态绑定，接受者动态绑定<ol>
<li>多态只对方法的接受者生效</li>
<li>多态只选择接受者的类型，不选择参数的类型</li>
</ol>
</li>
</ul>
</li>
<li>例子<ol>
<li>shape</li>
<li>HashSet.addAll() <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 HashSet自己没有 addAll ，从父类继承来的，</span><br><span class="line">2 调用addAll 会调用 add 方法</span><br><span class="line">3 而 HashSet 和 父类 都有 add 方法，那么会调用谁的呢？</span><br><span class="line">4 默念口诀： 实例方法默认是多态的，多态的意思是根据当前的类型来决定调用那个方法</span><br><span class="line">5 虽然 addAll 在父类中 但当前对象是 HashSet 的实例。所有会调用 HashSet 的 add</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<blockquote>
<h4 id="相关例子"><a href="#相关例子" class="headerlink" title="相关例子"></a>相关例子</h4></blockquote>
<ul>
<li><a href="https://github.com/hcsp/shape-polymorphism" target="_blank" rel="noopener">https://github.com/hcsp/shape-polymorphism</a></li>
<li><a href="https://github.com/hcsp/polymorphism-overload-method-selection" target="_blank" rel="noopener">https://github.com/hcsp/polymorphism-overload-method-selection</a></li>
<li><a href="https://github.com/hcsp/discount-strategy-pattern" target="_blank" rel="noopener">策略模式，打折策略</a>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public static int calculatePrice(String discountStrategy, int price, User user) &#123;</span><br><span class="line">    switch (discountStrategy) &#123;</span><br><span class="line">        case &quot;NoDiscount&quot;:</span><br><span class="line">            return price;</span><br><span class="line">        case &quot;Discount95&quot;:</span><br><span class="line">            return (int) (price * 0.95);</span><br><span class="line">        case &quot;OnlyVip&quot;:</span><br><span class="line">            &#123;</span><br><span class="line">                if (user.isVip()) &#123;</span><br><span class="line">                    return (int) (price * 0.95);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return price;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        default:</span><br><span class="line">            throw new IllegalStateException(&quot;Should not be here!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这样的缺点是 后来又多了 N种策略怎么办，别人都不敢轻易改代码了</span><br><span class="line">把每个策略抽象成一种类型单独维护</span><br><span class="line">public static int calculatePrice(DiscountStrategy strategy, int price, User user) &#123;</span><br><span class="line">    return strategy.discount(price, user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// DiscountStrategy 是父类</span><br><span class="line">// 使用 多态实现不同策略  </span><br><span class="line">public class Discount95Strategy extends DiscountStrategy&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int discount(int price, User user) &#123;</span><br><span class="line">        return (int)(price*0.95);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class NoDiscountStrategy extends DiscountStrategy&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int discount(int price, User user) &#123;</span><br><span class="line">        return price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class OnlyVipDiscountStrategy extends DiscountStrategy&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int discount(int price, User user) &#123;</span><br><span class="line">        if(user.isVip())&#123;</span><br><span class="line">            return (int)(price*0.95);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return price;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 这样每次增加策略就新建一个类就行了。</span><br><span class="line"></span><br><span class="line">// 这是个优点，也是个缺点。是因为 如果10000个策略就10000个类</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<h4 id="涉及金额绝对不能用double"><a href="#涉及金额绝对不能用double" class="headerlink" title="涉及金额绝对不能用double"></a>涉及金额绝对不能用double</h4></blockquote>
<ol>
<li>所有金额乘以 100 (1元= 100分)</li>
<li><code>BigDecimal</code>类型 任意精度10进制数</li>
</ol>
<blockquote>
<h4 id="TheadPoolExecutor"><a href="#TheadPoolExecutor" class="headerlink" title="TheadPoolExecutor"></a>TheadPoolExecutor</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TheadPoolExecutor(</span><br><span class="line">    int corePoolSize,</span><br><span class="line">    int maxiumPoolSize,</span><br><span class="line">    long keepAliveTime,</span><br><span class="line">    TimeUnit unit,</span><br><span class="line">    BlockKingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">    ThreadFactory threadFactory,</span><br><span class="line">    RejectedExecutionHandler handler)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 最后一个参数的意思       </span><br><span class="line">RejectedExecutionHandler 就是策略模式在线程池中的应用</span><br></pre></td></tr></table></figure>
<h4 id="做菜实例"><a href="#做菜实例" class="headerlink" title="做菜实例"></a>做菜实例</h4><ul>
<li><a href="https://github.com/hcsp/refactor-to-abstract-class" target="_blank" rel="noopener">https://github.com/hcsp/refactor-to-abstract-class</a></li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/oak/">oak</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/07/04/ZB-012-java组合和继承/" title="ZB-012-java组合和继承" itemprop="url">ZB-012-java组合和继承</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Stevin" target="_blank" itemprop="author">Stevin</a>
		
  <p class="article-time">
    <time datetime="2019-07-04T14:44:46.000Z" itemprop="datePublished"> Published 2019-07-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="什么是继承"><a href="#什么是继承" class="headerlink" title="什么是继承"></a>什么是继承</h3><ul>
<li>程序员的宿命：复制 &amp; 粘贴<ul>
<li>真的只能这样吗？</li>
<li>DRY(Donot Repeat Youself)</li>
<li>事不过三，三则重构</li>
</ul>
</li>
<li>继承的本质是提炼代码，避免重复</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Cat &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void walk()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Dog &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void walk()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Pig &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void walk()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 它们又很多共性和重复</span><br><span class="line">// 一旦walk改变了，要改三个地方</span><br></pre></td></tr></table></figure>
<blockquote>
<p>继承,避免重复</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Animal&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public void walk()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Cat extends Amimal&#123;...&#125;</span><br><span class="line">public class Dog extends Amimal&#123;...&#125;</span><br><span class="line">public class Pig extends Amimal&#123;...&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Java的继承体系"><a href="#Java的继承体系" class="headerlink" title="Java的继承体系"></a>Java的继承体系</h3><ul>
<li>单继承</li>
<li><p>Object 是所有类的基类，所有对象都继承了Object，所以所有对象都有 Object 的非私有成员属性/方法</p>
<ul>
<li><p>equals</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Object 的 equals 默认实现是 </span><br><span class="line">public boolean equals(Object obj)&#123;</span><br><span class="line">    return this == obj; // 比较的是 addr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">针对其他类如 Order  根据 id就可以确定是不是同一订单</span><br><span class="line">public class Order &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (this == o) return true;</span><br><span class="line">        if (o == null || getClass() != o.getClass()) return false;</span><br><span class="line">        Cat cat = (Cat) o;</span><br><span class="line">        return id == cat.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        return Objects.hash(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>toString</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object 的 toString 默认实现是 </span><br><span class="line">public boolean toString()&#123;</span><br><span class="line">    return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode()) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">任何时候打印对象的时候 都会提供字符串表示</span><br><span class="line">System.out.println(xxx); // 隐式调用</span><br><span class="line">xxx.toString();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>单根继承的好处是：</p>
</blockquote>
<ul>
<li>所有对象都有某一行为，因为都继承了 Object</li>
<li>方便处理</li>
</ul>
<blockquote>
<p>如 python支持多继承。会带来很多问题——菱形继承</p>
</blockquote>
<ul>
<li>父类都有 xxx()函数的处理！！！不知道该调用谁，但是python解决了！不再详细解释</li>
</ul>
<h3 id="类的结构和初始化顺序"><a href="#类的结构和初始化顺序" class="headerlink" title="类的结构和初始化顺序"></a>类的结构和初始化顺序</h3><ul>
<li>子类拥有父类一切的数据和行为</li>
<li>父类先于子类</li>
<li>必须拥有匹配的构造器<ul>
<li>super</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Animal &#123;</span><br><span class="line">    String name;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;初始化父类块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public Animal(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Cat extends Animal&#123;</span><br><span class="line">    int age;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;初始化子类块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public Cat(String name,int age) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>过程就是自顶向下依次初始化</li>
</ul>
<h3 id="实例方法的覆盖"><a href="#实例方法的覆盖" class="headerlink" title="实例方法的覆盖"></a>实例方法的覆盖</h3><ul>
<li>又称为重写/覆盖</li>
<li>永远使用<code>@Override</code>注解来防止手残<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Animal &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    public Animal(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sayHello()&#123;</span><br><span class="line">        System.out.println(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ----------------------------------</span><br><span class="line">public class Cat extends Animal&#123;</span><br><span class="line">    int age;</span><br><span class="line"></span><br><span class="line">    public Cat(String name,int age) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello()&#123;</span><br><span class="line">        System.out.println(&quot;cat hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h3><ul>
<li>spring的初始化代码就是模版方法，定义了一些预定义好的方法。自定义的实现可以覆盖模版的方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 模版方法</span><br><span class="line">public class BookWriter &#123;</span><br><span class="line">    // 写书</span><br><span class="line">    public void wtiteBook()&#123;</span><br><span class="line">        writeTitle();</span><br><span class="line">        writeContent();</span><br><span class="line">        writeEnding();</span><br><span class="line">    &#125;</span><br><span class="line">    public void writeTitle()&#123;</span><br><span class="line">        System.out.println(&quot;标题&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void writeContent()&#123;</span><br><span class="line">        System.out.println(&quot;内容&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void writeEnding()&#123;</span><br><span class="line">        System.out.println(&quot;结尾&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 子类继承父类的模版方法</span><br><span class="line">public class MyBookWriter extends BookWriter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void writeContent()&#123;</span><br><span class="line">        System.out.println(&quot;我的内容&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new MyBookWriter().wtiteBook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="向上和向下转型"><a href="#向上和向下转型" class="headerlink" title="向上和向下转型"></a>向上和向下转型</h3><ul>
<li><p>一个子类对象一定是父类类型的对象</p>
<ul>
<li>正如一只猫同时也是一个动物，同时也是一个对象</li>
<li><p>instanceof 判断一个对象是不是一个类的实例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object a = new Integer(1234);</span><br><span class="line">System.out.println(a instanceof Integer); // true</span><br><span class="line">System.out.println(a instanceof Number); // true</span><br><span class="line">System.out.println(a instanceof Object); // true</span><br><span class="line">System.out.println(null instanceof Integer); // false</span><br></pre></td></tr></table></figure>
</li>
<li><p>null installceof ? 都是 false</p>
</li>
</ul>
</li>
<li><p>当需要一个父类型时，可以传递一个子类型</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    setList(new ArrayList&lt;Integer&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void setList(AbstractList&lt;Integer&gt; list)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// &lt;Integer&gt; 是泛型， ArrayList 是 AbstractList 的子类</span><br><span class="line"></span><br><span class="line">// 还可以这样</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    setList(new ArrayList&lt;Integer&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void setList(AbstractList&lt;? super Number&gt; list)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>但是，有的时候你必须进行一些转型</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">    Animal a = new Animal();</span><br><span class="line">    setAnimalName((Dog)animal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void setAnimalName(Dog dog)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>转型是不安全的</li>
<li>失败了怎么办？</li>
</ul>
</li>
</ul>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><ul>
<li><p>final声明变量是不可变的(必须初始化)</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final int a = 1; // 正确</span><br><span class="line">final int a ; // 错误 没有初始化</span><br></pre></td></tr></table></figure>
<ul>
<li><p>局部变量/方法参数</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void f(final Date date)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// date的地址不能改变， 地址指向的东西可以改变</span><br></pre></td></tr></table></figure>
</li>
<li><p>成员变量</p>
</li>
<li><p>常量和单例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 命名规则是全部大写 ，然后以下划线区分 如 MAX_VALUE</span><br><span class="line">public static final double PI = 3.1415926;</span><br><span class="line"></span><br><span class="line">// 单例模式</span><br><span class="line">public class World&#123;</span><br><span class="line">    public static final World SINGLETON_INSTANCE = new World();</span><br><span class="line">    private World()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static World getInstance()&#123;</span><br><span class="line">        return SINGLETON_INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>final在方法上的声明： 禁止继承/覆盖/重写此方法</p>
</li>
<li>final在类声明上的声明： 禁止继承此类<ul>
<li>继承提供了灵活性，也埋下了隐患</li>
<li>为什么String/Integer 等是 final的呢？<ol>
<li>假设 <code>MyInteger extends Integer</code> 此时重写 <code>compare</code> 本来 <code>1&lt;2</code> 而你偏偏 <code>改写成 1&gt;2</code> 这样就破坏所有使用<code>Integer</code>方法 的约定</li>
<li>JDK通过把 <code>String/Integer 定义为 final</code> 来阻止恶意的客户端继承常见类，破坏程序的约定</li>
</ol>
</li>
</ul>
</li>
</ul>
<blockquote>
<h4 id="final在-类-方法上有什么优点"><a href="#final在-类-方法上有什么优点" class="headerlink" title="final在 类/方法上有什么优点"></a>final在 类/方法上有什么优点</h4></blockquote>
<ol>
<li>使用 final 可以保证类无法被继承，方法无法被重写，别人无法通过继承来破坏约定，你可以大胆的做一些事情，软件设计的一个约定——放心大胆的做一些事，我可以保证这个约定不会被打破</li>
<li>这个方法是 final 时方法是被确定的无法多态</li>
</ol>
<h3 id="组合和继承"><a href="#组合和继承" class="headerlink" title="组合和继承"></a>组合和继承</h3><ul>
<li>继承：is-a</li>
<li>组合：has-a</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/oak/">oak</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/07/04/ZB-011-java封装和访问控制/" title="ZB-011-java封装和访问控制" itemprop="url">ZB-011-java封装和访问控制</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Stevin" target="_blank" itemprop="author">Stevin</a>
		
  <p class="article-time">
    <time datetime="2019-07-04T11:59:51.000Z" itemprop="datePublished"> Published 2019-07-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="什么是封装"><a href="#什么是封装" class="headerlink" title="什么是封装"></a>什么是封装</h3><ul>
<li>隐藏内部细节，只暴露出接口</li>
<li>电灯<ul>
<li>你只关心它的“开关”接口，不关心内部的“电路”细节</li>
</ul>
</li>
<li>汽车<ul>
<li>你只关心“方向盘”，不关心内部的细节</li>
</ul>
</li>
</ul>
<p>Light.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Light&#123;</span><br><span class="line"></span><br><span class="line">    public void trunOn()&#123;</span><br><span class="line">        打开电路1();</span><br><span class="line">        打开电路2();</span><br><span class="line">        打开电路3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void 打开电路1()&#123;&#125;</span><br><span class="line">    public void 打开电路2()&#123;&#125;</span><br><span class="line">    public void 打开电路3()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Home.java</p>
</blockquote>
<p>打开灯有两种方式</p>
<ul>
<li>直接调用 <code>trunOn()</code> (低耦合)</li>
<li>调用实现细节 <code>打开电路1();打开电路2();打开电路3()</code>(高耦合)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class public Home&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Light a = new Light();</span><br><span class="line">        a.trunOn();</span><br><span class="line"></span><br><span class="line">        Light b = new Light();</span><br><span class="line">        b.打开电路1();</span><br><span class="line">        b.打开电路2();</span><br><span class="line">        b.打开电路3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如果有一天，一个高级工程师对打开灯的方式进行了优化</strong></p>
<p>此时只要<code>打开电路1();打开电路2();</code> 就可以开灯了</p>
<p>此时 以第二种方式调用开灯的人就要修改 因为它耦合了开灯的细节</p>
<p><strong>一方改变另一方也要改变</strong></p>
<p>而第一种方式只需要更改 <code>turnOn()</code> 自己一个方法就做到了正常工作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void trunOn()&#123;</span><br><span class="line">    打开电路1();</span><br><span class="line">    打开电路2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h4></blockquote>
<p>Person类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Person&#123;</span><br><span class="line">    int id;</span><br><span class="line">    int age;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设10个人都用了你的 <code>Person</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person p = new Person();</span><br><span class="line">p.age = 10;</span><br><span class="line">p.name = &quot;张三&quot;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>老板突然提了个需求，<strong>如果年龄小与0则为0，大于100则为100</strong></p>
</blockquote>
<ul>
<li>这样别人都是通过 <code>p.age = 10</code>设置一个值。这样要改 10个地方。</li>
</ul>
<blockquote>
<p>优化</p>
</blockquote>
<ul>
<li>把成员变量变为私有</li>
<li>设置对应的 get/set 接口</li>
<li>外界只能通过 get/set接口对成员进行操作  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person p = new Person();</span><br><span class="line">p.setAge(10);</span><br><span class="line">p.setName(&quot;张三&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">    // 如果年龄小与0则为0，大于100则为100</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        if(age&lt;0)&#123;</span><br><span class="line">            this.age = 0;</span><br><span class="line">        &#125;else if(age&gt;100)&#123;</span><br><span class="line">            this.age = 100;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            this.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有没有发现改一下接口 <code>setAge()</code> 就轻松的完成了需求</p>
<blockquote>
<p>场景三，你开发的Person 被广泛应用到别人的电脑</p>
</blockquote>
<p>此时你老板认为世界上只有男和女，于是你的<code>gender</code> 采用了 <code>boolean</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private boolean gender;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean isMale() &#123;</span><br><span class="line">        return gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setGender(boolean gender) &#123;</span><br><span class="line">        this.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过了1年后，你老板发现还真有其他性别。你就不得不改变<code>gender 为 String</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package hello.service;</span><br><span class="line"></span><br><span class="line">import java.util.Objects;</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private String gender;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean isMale() &#123;</span><br><span class="line">        // return gender == &quot;M&quot;; 可能会空指针</span><br><span class="line">        // return &quot;M&quot;.equals(gender);  非空对象前置</span><br><span class="line">        return Objects.equals(gender,&quot;M&quot;); </span><br><span class="line">    &#125;</span><br><span class="line">    // 废弃的注解</span><br><span class="line">    @Deprecated</span><br><span class="line">    public void setGender(boolean gender) &#123;</span><br><span class="line">        this.gender = gender ? &quot;M&quot; : &quot;F&quot; ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时使用者无需任何改变，依然能正常使用</p>
<h3 id="封装的实现"><a href="#封装的实现" class="headerlink" title="封装的实现"></a>封装的实现</h3><blockquote>
<p>包的功能就是提供<strong>访问控制，一种边界，封装的边界</strong></p>
</blockquote>
<ul>
<li>public 任何人都能访问</li>
<li>protected 只有子类和同包的可以访问</li>
<li>package private(包级私有)包权限 同包可访问</li>
<li>private 只有自己能访问</li>
</ul>
<p><strong>包是没有嵌套包含关系的！！！跟文件夹父子目录不一样</strong></p>
<h4 id="JavaBean约定"><a href="#JavaBean约定" class="headerlink" title="JavaBean约定"></a>JavaBean约定</h4><ul>
<li>getter</li>
<li>setter</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private boolean cute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>此时 <code>Person 的 name / cute</code> 无法被外界访问因为是 <code>private</code></strong></p>
<p>设置getter/setter</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private boolean cute;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isCute() &#123;</span><br><span class="line">        return cute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCute(boolean cute) &#123;</span><br><span class="line">        this.cute = cute;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么 <code>getter/setter</code>长这个样子,不是无缘无故，而是<strong>JavaBean约定</strong></p>
</blockquote>
<ul>
<li>我们知道 <code>java</code> 代表咖啡，而程序员很浪漫</li>
<li>在<code>java</code>中创建对象了叫什么呢？ 对象？太土了，程序员的浪漫促使它起了名字叫做 <strong>“Bean”</strong> 就是”豆”</li>
<li>JavaBean 就是咖啡豆</li>
</ul>
<p>对于一个 JavaBean 来说 加入他有一个 <code>getX() 和 setX()</code> 方法，我们就认为它有一个 <code>x</code> 属性</p>
<h5 id="规则如下"><a href="#规则如下" class="headerlink" title="规则如下"></a>规则如下</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 非 boolean 值</span><br><span class="line">String name;</span><br><span class="line">setName/getName</span><br><span class="line"></span><br><span class="line">// boolean 值</span><br><span class="line">boolean gender</span><br><span class="line">setGender/isGender</span><br></pre></td></tr></table></figure>
<h5 id="这些约定有什么用呢？"><a href="#这些约定有什么用呢？" class="headerlink" title="这些约定有什么用呢？"></a>这些约定有什么用呢？</h5><ul>
<li>最重要之一就是 <code>JSON</code> 对象和字符串相互转换</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 如 js</span><br><span class="line">var obj = &#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:&quot;李四&quot;&#125;;</span><br><span class="line">// 序列化</span><br><span class="line">JSON.stringify(obj);</span><br><span class="line">// 反序列化</span><br><span class="line">var obj2 = JSON.parse(`&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:&quot;李四&quot;&#125;`);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>java常见序列化库 fastjson / gson / jackson</p>
</blockquote>
<h5 id="java中使用序列化库"><a href="#java中使用序列化库" class="headerlink" title="java中使用序列化库"></a>java中使用序列化库</h5><p>maven里引入依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.58&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Cat &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private boolean cute;</span><br><span class="line"></span><br><span class="line">    public Cat(String name, boolean cute) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.cute = cute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isCute() &#123;</span><br><span class="line">        return cute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCute(boolean cute) &#123;</span><br><span class="line">        this.cute = cute;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.json;</span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Cat cat = new Cat(&quot;a&quot;,true);</span><br><span class="line"></span><br><span class="line">        System.out.printf(JSON.toJSONString(cat));</span><br><span class="line"></span><br><span class="line">        String s = &quot;&#123;\&quot;cute\&quot;:true,\&quot;name\&quot;:\&quot;喵\&quot;&#125;&quot;;</span><br><span class="line"></span><br><span class="line">        cat = JSON.parseObject(s,Cat.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是 JSON 的序列化和反序列化过程</p>
<blockquote>
<h4 id="JavaBean-约定"><a href="#JavaBean-约定" class="headerlink" title="JavaBean 约定"></a>JavaBean 约定</h4></blockquote>
<p><strong>会使用你的 getter/setter 当作属性的名字，而不是你的成员private类型成员</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package com.json;</span><br><span class="line"></span><br><span class="line">public class Cat &#123;</span><br><span class="line">    private boolean cute;</span><br><span class="line"></span><br><span class="line">    public Cat(String name, boolean cute) &#123;</span><br><span class="line">        this.cute = cute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return &quot;123&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isCute() &#123;</span><br><span class="line">        return cute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCute(boolean cute) &#123;</span><br><span class="line">        this.cute = cute;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// name属性不存在了</span><br><span class="line">// getter/setter还在</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Cat cat = new Cat(&quot;a&quot;,true);</span><br><span class="line">        System.out.printf(JSON.toJSONString(cat));</span><br><span class="line">        //&#123;&quot;cute&quot;:true,&quot;name&quot;:&quot;123&quot;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="JavaBean总结"><a href="#JavaBean总结" class="headerlink" title="JavaBean总结"></a>JavaBean总结</h4><p>在Java的世界中，对json进行读写的时候，我们只看JavaBean的 <code>getter/setter</code>方法，而不看是否具有<code>xxx</code>属性</p>
<p><strong>这也进一步验证了我们想要达到封装的目的，封装应该尽可能的隐藏内部实现细节，而仅仅像外界暴露接口</strong></p>
<p>暴露的接口 在JavaBean中就是 <code>getter/setter</code> 方法</p>
<p>虽然每次java里设置一堆<code>getter/setter</code>很繁琐啰嗦，好处就是为你提供了封装，</p>
<ul>
<li>封装是软件得以成功演进的保证</li>
</ul>
<h3 id="设计模式：抽象工厂方法"><a href="#设计模式：抽象工厂方法" class="headerlink" title="设计模式：抽象工厂方法"></a>设计模式：抽象工厂方法</h3><blockquote>
<p>推荐一本书 effective java,无论处在java任何阶段都非常值得一读</p>
</blockquote>
<ul>
<li>使用静态工厂方法代替构造器</li>
<li>将构造器私有化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static Cat newCuteCat(String name)&#123;</span><br><span class="line">        return new Cat(name,true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public static Cat newUnCuteCat(String name)&#123;</span><br><span class="line">    return new Cat(name,false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Cat(String name, boolean cute) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.cute = cute;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 静态工厂方法，可以有个名字，清楚无误的告诉你干什么</span><br><span class="line">Cat.newCuteCat(&quot;xxx&quot;)  // 萌的猫</span><br><span class="line">Cat.newUnCuteCat(&quot;xxx&quot;) // 不萌的猫</span><br><span class="line">new Cat(&quot;xxx&quot;,true) // 看不出来</span><br></pre></td></tr></table></figure>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol>
<li>不像构造器，它是有名字的。可以描述在做什么<ul>
<li>疑问，我可以通过注释来告诉别人构造器做什么</li>
<li>注释是不会被编译器处理的，因此它很有可能过时，过时的注释很可能会误导你，一个过时的<strong>注释</strong>比没有注释更糟糕</li>
<li>尽可能不要写注释，如果你不能保证及时更新</li>
</ul>
</li>
<li>静态方法不一定创建一个实例，你可以返回一个null也可以返回一个之前创建好的对象，但是构造器一定会创建一个实例</li>
<li>静态构造方法可以返回 <strong>该类的子类型</strong>，而构造器只能返回该类的实例</li>
<li><p>可以根据参数决定 要不要创建这个对象，我要创建什么对象，以及要不要把之前的对象缓存一下</p>
<ul>
<li><p>参考<code>Boolean</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final class Boolean implements java.io.Serializable,</span><br><span class="line">                                    Comparable&lt;Boolean&gt;</span><br><span class="line">&#123;</span><br><span class="line">    // 预先定义好的对象</span><br><span class="line">    public static final Boolean TRUE = new Boolean(true);</span><br><span class="line">    public static final Boolean FALSE = new Boolean(false);</span><br><span class="line"></span><br><span class="line">    public static Boolean valueOf(boolean b) &#123;</span><br><span class="line">        return (b ? TRUE : FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>它返回了预先定义好的对象，不用每次都创建，省内存</p>
</li>
</ul>
</li>
<li>静态工厂返回的这个对象，它可以不存在<ul>
<li>动态加载，灵活的体现</li>
</ul>
</li>
</ol>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li>一个子类构造器会自动调用父类的构造器，构造对应的对象，但是静态方法不可以</li>
<li>很难让开发者找到，因为它的灵活性只能打开文档找到它 而不像这样<code>new Cat()</code>方便找到</li>
</ol>
<h5 id="静态方法的最佳实践"><a href="#静态方法的最佳实践" class="headerlink" title="静态方法的最佳实践"></a>静态方法的最佳实践</h5><ul>
<li>将构造器变为私有,此时外界无法创建实例，只能通过暴露的工厂方法</li>
<li>此时你内部如何修改构造器都随意了。外界只能操作暴露的工厂方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Cat &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private boolean cute;</span><br><span class="line"></span><br><span class="line">    public static Cat newCuteCat(String name)&#123;</span><br><span class="line">        return new Cat(name,true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Cat newUnCuteCat(String name)&#123;</span><br><span class="line">        return new Cat(name,false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Cat(String name, boolean cute) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.cute = cute;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类的访问控制"><a href="#类的访问控制" class="headerlink" title="类的访问控制"></a>类的访问控制</h4><p>这就是封装在类级别的表现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 之前，不同包可以直接使用</span><br><span class="line">public class Cat&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 现在 包级私有 package private </span><br><span class="line">class Cat&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>包级私有类 如<code>ProcessEnvironment</code> 在其他包外不能调用。</li>
</ul>
<blockquote>
<h4 id="如何访问一个-包级私有的类呢？-不建议以后使用太hack"><a href="#如何访问一个-包级私有的类呢？-不建议以后使用太hack" class="headerlink" title="如何访问一个 包级私有的类呢？(不建议以后使用太hack)"></a>如何访问一个 包级私有的类呢？(不建议以后使用太hack)</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 假设一个类,它是 包级私有 只能同包访问</span><br><span class="line">package com.github.demo;</span><br><span class="line">class A&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 在你的 maven项目里创建一个 桥接类 ,它的包路径和 上面的 一样</span><br><span class="line">package com.github.demo;</span><br><span class="line">class 桥接类&#123;</span><br><span class="line">    public A newInstance()&#123;</span><br><span class="line">        // 访问同一包中的私有类</span><br><span class="line">        return new A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 此时你去创建这个类</span><br><span class="line">桥接类.newInstance();// 报错 因为java发现返回值 还是不能访问</span><br><span class="line"></span><br><span class="line">// 怎么办呢,修改返回值类型为 Object</span><br><span class="line">class 桥接类&#123;</span><br><span class="line">    public Object newInstance()&#123;</span><br><span class="line">        // 访问同一包中的私有类</span><br><span class="line">        return new A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 因为 任何对象都是 Object 的子类</span><br><span class="line">// 此时你就可以</span><br><span class="line">桥接类.newInstance();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>既然这样那么我们是不是可以这样绕过限制创建 <code>ProcessEnvironment</code> 的实例呢？</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 你就创建这样的package</span><br><span class="line">package java.lang;</span><br><span class="line">public class MyClass&#123;&#125;</span><br><span class="line">//此时报错了。 说这个类是被禁止的。</span><br><span class="line"></span><br><span class="line">原因是 以 java开头的包都是 jvm的保留包,不允许你自定义一个java.lang包的，但是你可以通过别的包的访问限制</span><br></pre></td></tr></table></figure>
<h4 id="私有内部类"><a href="#私有内部类" class="headerlink" title="私有内部类"></a>私有内部类</h4><p>一个类有简单功能，你不想几个目录跳过来跳过去的使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Home&#123;</span><br><span class="line"></span><br><span class="line">    // 只能在同一个类中访问</span><br><span class="line">    private static class InnerClass&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Java模块系统简介"><a href="#Java模块系统简介" class="headerlink" title="Java模块系统简介"></a>Java模块系统简介</h3><p>需求：你像把若干个包封装在一起，暴露接口出去</p>
<ul>
<li>java8之前是不行的</li>
<li>java9引入了模块化系统，你可以把包封装成模块 module</li>
</ul>
<blockquote>
<p>java9的模块化系统好处是提供了更大范围的封装。但是它太新了。没有被业界所接受。</p>
</blockquote>
<p>例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">假设你是管理者，你手下有工人</span><br><span class="line">package com.farm;</span><br><span class="line">public class Manger&#123;</span><br><span class="line">    private Worker worker;</span><br><span class="line"></span><br><span class="line">    public void manage()&#123;</span><br><span class="line">        worker.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package com.farm;</span><br><span class="line">public class Worker&#123;</span><br><span class="line">    public void work()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 此时你的类发布了,此时你不小心暴露了 worker</span><br></pre></td></tr></table></figure>
<p>另一个项目中,利用同包路径来访问你的worker</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.farm;</span><br><span class="line">public class Boss&#123;</span><br><span class="line">    Manager manager;</span><br><span class="line"></span><br><span class="line">    public void runCompany()&#123;</span><br><span class="line">        manager.manage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Boss直接指挥工人，此时 manager就懵逼了，你怎么直接指挥工人了</span><br><span class="line">    public void directWorker()&#123;</span><br><span class="line">        Worker w1 = new Worker();</span><br><span class="line">        w1.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了不让 Boss 直接指挥 worker</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 你只能包级私有</span><br><span class="line">class Worker&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是有时候，出于其他原因你不得不把它自己包里面</p>
</blockquote>
<ul>
<li>导致 manager 无法指挥 worker了</li>
<li>只能 public了，一旦 public 你的老板又开始指挥工人了</li>
<li>我们只能使用一些君子协定如 internal 包名 让人知道是内部的包。但是别人不君子咋办！！！  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">package com.farm.worker.internal;</span><br><span class="line">public class Worker&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">package com.farm.worker;</span><br><span class="line">class Worker&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>java8之前无法做到，技术上做不到</strong><br><strong>java9的模块化系统可以解决，但是太新了，业界还没接受</strong></p>
<h3 id="builder模式"><a href="#builder模式" class="headerlink" title="builder模式"></a>builder模式</h3><ul>
<li>简略版</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.json;</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">    private String firstName;</span><br><span class="line">    private String lastName;</span><br><span class="line">    private String desc;</span><br><span class="line">    private String job;</span><br><span class="line">    private String phone;</span><br><span class="line">    private String address;</span><br><span class="line"></span><br><span class="line">    public Person(String firstName, String lastName, String desc, String job, String phone, String address) &#123;</span><br><span class="line">        this.firstName = firstName;</span><br><span class="line">        this.lastName = lastName;</span><br><span class="line">        this.desc = desc;</span><br><span class="line">        this.job = job;</span><br><span class="line">        this.phone = phone;</span><br><span class="line">        this.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>一个 <code>Person</code> 有诸多属性你在创建的时候，顺序错了非常难发现，</li>
<li>尤其是在 代码 review 的时候，不再 IDEA 里 ，没有参数提示。</li>
<li>这个时候你可以使用 builder 安装 builder</li>
<li>在IDEA里右键就可以创建 builder</li>
</ul>
<p>此时可以这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person person1 = new Person(&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;)</span><br><span class="line"></span><br><span class="line">// 更加直观，链式调用</span><br><span class="line">Person person = PersonBuilder.aPerson()</span><br><span class="line">    .withFirstName(&quot;&quot;)</span><br><span class="line">    .withLastName(&quot;&quot;)</span><br><span class="line">    .withAddress(&quot;&quot;)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/oak/">oak</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/07/03/ZB-010-java对象系统/" title="ZB-010-java对象系统" itemprop="url">ZB-010-java对象系统</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Stevin" target="_blank" itemprop="author">Stevin</a>
		
  <p class="article-time">
    <time datetime="2019-07-03T12:53:55.000Z" itemprop="datePublished"> Published 2019-07-03</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象"></a>什么是对象</h3><ul>
<li>对象就是数据和行为的集合</li>
<li>一切能用 new 创建出来的都是对象  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new Object()</span><br><span class="line"></span><br><span class="line">特例 Integer a = 1; 实际是 Integer a = new Integer(1);</span><br><span class="line">特例 String a = &quot;&quot;; 实际是 String a = new String(&quot;&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="对象的组成"><a href="#对象的组成" class="headerlink" title="对象的组成"></a>对象的组成</h3><ul>
<li>所有的对象都在堆上分配</li>
<li>每个对象有自己的数据(成员变量)<ul>
<li>原生类型成员</li>
<li>引用类型成员</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Home&#123;</span><br><span class="line">    int age;</span><br><span class="line">    Cat cat;</span><br><span class="line">    Home(Cat cat)&#123;</span><br><span class="line">        this.cat = cat;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        new Home(new Cat(1,&quot;阿三&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void miao()&#123;</span><br><span class="line">        System.out.println(&quot;喵&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Cat&#123;</span><br><span class="line">    int age;</span><br><span class="line">    String name;</span><br><span class="line">    Cat(int age,String name)&#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对象的构造函数"><a href="#对象的构造函数" class="headerlink" title="对象的构造函数"></a>对象的构造函数</h3><ul>
<li>新建对象的唯一途径<ol>
<li>在 堆 上分配空间</li>
<li>执行必要的初始化函数</li>
<li>执行构造函数</li>
</ol>
</li>
<li>没有构造器，则编译器偷偷生成一个  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Cat&#123;</span><br><span class="line">    int age; // 默认初始化为 0</span><br><span class="line">    byte b;// 0</span><br><span class="line">    short c;// 0</span><br><span class="line">    float d;// 0f</span><br><span class="line">    double e;// 0d</span><br><span class="line">    String f; // null 引用类型为 null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>new Cat(1,&quot;张三&quot;)</code> 做了什么</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Cat&#123;</span><br><span class="line">    int age;</span><br><span class="line">    String name;</span><br><span class="line">    Cat(int age,String name)&#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在堆上 开辟一个空间</li>
<li>对空间内的对象执行初始化语句，成员变量进行初始化 <code>age = 0 ,name=null</code></li>
<li>执行类的构造器函数,对成员变量进行赋值 <code>age = 1, name=&quot;张三&quot;</code></li>
</ol>
<h3 id="对象的方法"><a href="#对象的方法" class="headerlink" title="对象的方法"></a>对象的方法</h3><ul>
<li>数据是“对象有什么”</li>
<li>方法是“对象做什么”</li>
</ul>
<h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><ul>
<li>重载 overload </li>
<li>重写/覆盖 override</li>
<li>如何区分同名的不同重载方法？<ul>
<li>根据类型</li>
<li>那隐式转换呢？</li>
<li>类型最匹配优先(如果能匹配多个呢？ null)</li>
</ul>
</li>
<li>能仅仅重载返回值吗？</li>
<li>如何为方法提供默认值？<ul>
<li>没办法</li>
<li>但是可以通过重载曲线救国</li>
</ul>
</li>
</ul>
<blockquote>
<p>重载：根据类型区分</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Cat&#123;</span><br><span class="line">    Cat()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    void f()&#123;&#125;</span><br><span class="line">    void f(String s)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Cat cat = new Cat();</span><br><span class="line">        cat.f();</span><br><span class="line">        cat.f(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>重载的坑</strong></p>
</blockquote>
<ul>
<li>装箱类型 int / Integer</li>
<li>Integer 是 Number的子类</li>
<li>Number 是 Objeact 的子类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Cat&#123;</span><br><span class="line"></span><br><span class="line">    void f(int i)&#123;&#125;</span><br><span class="line">    void f(Integer i)&#123;&#125;</span><br><span class="line">    void f(Number i)&#123;&#125;</span><br><span class="line">    void f(Object i)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Cat cat = new Cat();</span><br><span class="line">        // 此时匹配到哪一个呢？</span><br><span class="line">        cat.f(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个方法调用可以匹配多个方法声明，我该调用谁？</p>
<ul>
<li><p>类型最匹配优先</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> // int 此时会匹配 f(int i) 那个方法</span><br><span class="line">public class Cat&#123;</span><br><span class="line"></span><br><span class="line">     void f(int i)&#123;&#125;</span><br><span class="line">     void f(Integer i)&#123;&#125;</span><br><span class="line">     void f(Number i)&#123;&#125;</span><br><span class="line">     void f(Object i)&#123;&#125;</span><br><span class="line"></span><br><span class="line">     public static void main(String[] args)&#123;</span><br><span class="line">         Cat cat = new Cat();</span><br><span class="line">         // 此时匹配到哪一个呢？</span><br><span class="line">         cat.f(1);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 变化了 注释掉这个 void f(int i)&#123;&#125;</span><br><span class="line">public class Cat&#123;</span><br><span class="line"></span><br><span class="line">    void f(Integer i)&#123;&#125;</span><br><span class="line">    void f(Number i)&#123;&#125;</span><br><span class="line">    void f(Object i)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Cat cat = new Cat();</span><br><span class="line">        // 此时匹配到哪一个呢？ </span><br><span class="line">        // Integer最匹配</span><br><span class="line">        cat.f(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>null值怎么办</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Cat&#123;</span><br><span class="line"></span><br><span class="line">    void f(Integer i)&#123;&#125;</span><br><span class="line">    void f(Object[] i)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Cat cat = new Cat();</span><br><span class="line">        // 此时匹配到哪一个呢？ 两个f都匹配</span><br><span class="line">        // cat.f(null); //标红了</span><br><span class="line">        cat.f((Integer)null); // 强制为 null 指定类型</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  而我这样的时候就不报错了</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Cat&#123;</span><br><span class="line"></span><br><span class="line">    void f(Integer i)&#123;&#125;</span><br><span class="line">    void f(Number i)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Cat cat = new Cat();</span><br><span class="line">        // 此时匹配到哪一个呢？此时竟然不报错了</span><br><span class="line">        cat.f(null); // </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">因为你要记住这句 匹配最接近的 </span><br><span class="line">java的类型树 </span><br><span class="line"></span><br><span class="line">假设我有两种类型 是父子关系。意味着匹配最接近的 就是 Integer</span><br><span class="line">-|Object </span><br><span class="line">--|Number</span><br><span class="line">----|Integer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">假设是兄弟关系呢？ 他们俩与 null的距离相同。所以歧义产生了 ，所以必须要 强制转换</span><br><span class="line">-|Object </span><br><span class="line">--|List</span><br><span class="line">----|ArrayList</span><br><span class="line"></span><br><span class="line">-|Object </span><br><span class="line">--|Number</span><br><span class="line">----|Integer</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<h4 id="能仅仅重载返回值吗？"><a href="#能仅仅重载返回值吗？" class="headerlink" title="能仅仅重载返回值吗？"></a>能仅仅重载返回值吗？</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void f()&#123;&#125;</span><br><span class="line"></span><br><span class="line">int f()&#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 标红</span><br><span class="line">// 因为方法调用允许忽略返回值，</span><br><span class="line">Cat c = new Cat();</span><br><span class="line">c.f(); // 忽略返回值的时候，int f()方法会和 void f()产生冲突，编译器不知道要用哪个，因此不允许这样</span><br></pre></td></tr></table></figure>
<blockquote>
<p>高深的地方</p>
</blockquote>
<ul>
<li>在源代码里是非法的，但在java的字节码里是允许存在的(JVM里允许)</li>
<li>对于我们来说，编译器不让你做就别做！！！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void f()&#123;&#125;</span><br><span class="line">int f()&#123;return 1;&#125;</span><br><span class="line">// 在源代码里是非法的，但在java的字节码里是允许存在的。</span><br></pre></td></tr></table></figure>
<h4 id="如何为方法提供默认值"><a href="#如何为方法提供默认值" class="headerlink" title="如何为方法提供默认值"></a>如何为方法提供默认值</h4><ul>
<li>答案是在java是不行的,只能这样</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void a()&#123;</span><br><span class="line">    System.out.println(&quot;喵&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void a(String a)&#123;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在其他语言，如js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function a(val = &quot;miao&quot;)&#123;</span><br><span class="line">    console.log(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构造器重载的例子"><a href="#构造器重载的例子" class="headerlink" title="构造器重载的例子"></a>构造器重载的例子</h4><ul>
<li>HashMap</li>
</ul>
<h3 id="对象的初始化过程"><a href="#对象的初始化过程" class="headerlink" title="对象的初始化过程"></a>对象的初始化过程</h3><ul>
<li>必要的初始化工作<ol>
<li>静态成员初始化</li>
<li>静态初始化块</li>
<li>成员初始化</li>
<li>初始化块</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Cat&#123;</span><br><span class="line">    static int a = 123;</span><br><span class="line">    static &#123;</span><br><span class="line">        // 这里不能调用 成员方法 f()</span><br><span class="line">        System.out.println(&quot;000&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    int age;</span><br><span class="line">    String name;</span><br><span class="line">    &#123;</span><br><span class="line">        //</span><br><span class="line">        System.out.println(&quot;abc&quot;);</span><br><span class="line">        // 这里可以调用实例方法吗？ 可以的</span><br><span class="line">        // 但是这是非常危险的，因为此阶段 还未调用 构造器 实例对象是残缺不全的</span><br><span class="line">        f();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void f()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    Cat(int age,String name)&#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        new Cat(1,&quot;aaa&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行步骤</p>
<ol>
<li><p>执行入口函数 main之前要先加载类</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">第一步</span><br><span class="line">static int a = 123;</span><br><span class="line">第二步</span><br><span class="line">static &#123;</span><br><span class="line">    // 这里不能调用 成员方法 f()</span><br><span class="line">    System.out.println(&quot;000&quot;);</span><br><span class="line">&#125;</span><br><span class="line">第三步</span><br><span class="line">执行 main 函数 new Cat(1,&quot;aaa&quot;); 开辟内存空间</span><br></pre></td></tr></table></figure>
</li>
<li><p>成员初始化</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第四步</span><br><span class="line">int age = 0;</span><br><span class="line">String name =  &quot;&quot;;</span><br><span class="line">第五步</span><br><span class="line">执行成员方法块</span><br><span class="line">第六步</span><br><span class="line">执行构造器</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="对象的生命周期"><a href="#对象的生命周期" class="headerlink" title="对象的生命周期"></a>对象的生命周期</h3><ul>
<li><p>如果一直新建对象，内存会不会爆？</p>
<ul>
<li><p>可能会</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object[] arr = new Object[10000]</span><br><span class="line">for(int i=0;i&lt;10000;i++)&#123;</span><br><span class="line">    // 每次开辟1MB的空间</span><br><span class="line">    array[i] = new byte[1024*1024];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 报错 OutOfMemoryError</span><br></pre></td></tr></table></figure>
</li>
<li><p>可能不会, jvm帮你回收 new出来无用的空间</p>
</li>
</ul>
</li>
<li><p>那对象的内存什么时候回收？ <strong>谁也不知道，JVM帮你做</strong></p>
</li>
<li>对象的内存如何被回收？ <strong>不用管，垃圾回收器帮你干</strong> <ul>
<li>GC 垃圾回收器(幕后偷偷帮你做)</li>
</ul>
</li>
<li>JVM怎么知道那个对象没有被用到？<ul>
<li>通过引用链 (GC Roots)</li>
<li>沿着 GC Roots 可达的路径都是活对象，除此之外都是死对象</li>
</ul>
</li>
</ul>
<blockquote>
<p>生活实例</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">内存 =  假设你房子的空间</span><br><span class="line">GC Root = </span><br><span class="line">房间里有一个 你</span><br><span class="line">你.手 = 键盘</span><br><span class="line">键盘.usb = 笔记本</span><br><span class="line">笔记本.usb2 = 鼠标</span><br><span class="line">笔记本.usb3 = 电源</span><br><span class="line"></span><br><span class="line">此时预定义 GCRoot 根就是 “你”</span><br><span class="line">沿着你能找到的所有对象都是好的</span><br><span class="line">地上扔这个喝完的易拉罐，明显是垃圾 可以被干掉了</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对象没有被引用，应该就被回收了吧？    </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这个东西什么时候回收，由不得你。</span><br><span class="line">由JVM自己决定。 可能马上，也可能一直不回收</span><br><span class="line"></span><br><span class="line">GC 也是需要耗费内存空间的。</span><br><span class="line">假设你的空间非常小，GC就会帮你干掉</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不可达的对象会被删除还是什么？</p>
</blockquote>
<ul>
<li>GC 算法（现在的jvm用的是 分代 回收算法）</li>
</ul>
<p>简单理解就是，一块地上盖了楼，现在拆了盖新的楼</p>
<h4 id="分代回收的大概过程"><a href="#分代回收的大概过程" class="headerlink" title="分代回收的大概过程"></a>分代回收的大概过程</h4><ul>
<li>不一定只发生删除</li>
<li>还会发生压缩</li>
</ul>
<p>在内存中除了 占地方 还有一个非常恐怖的事 就是<strong>碎片化</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">比如操场上开始广播体操。 每个人都拉开距离把操场占满了。 每个人占据的实际空间并不大。但是空间被割裂为很碎很碎</span><br><span class="line"></span><br><span class="line">虽然有很大的空间。</span><br><span class="line"></span><br><span class="line">但是此时 如果想在 操场中心建一个花园。 你就做不到了因为 人的分布已经把操场碎片化了。</span><br><span class="line">以至于你不能找到一块 完整的连续的空间 做你想做的事情。</span><br><span class="line">这时候也会抛出内存不足的Error</span><br><span class="line"></span><br><span class="line">因此垃圾回收不仅仅是删除</span><br><span class="line">还可能把这些细碎的内存 “归整” 来释放 完整的连续的空间供其他程序使用</span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/oak/">oak</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/07/03/ZB-009-java控制流/" title="ZB-009-java控制流" itemprop="url">ZB-009-java控制流</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Stevin" target="_blank" itemprop="author">Stevin</a>
		
  <p class="article-time">
    <time datetime="2019-07-03T12:13:08.000Z" itemprop="datePublished"> Published 2019-07-03</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="方法的控制流"><a href="#方法的控制流" class="headerlink" title="方法的控制流"></a>方法的控制流</h3><ul>
<li>方法调用，就是一个方法栈每当开始一个方法调用的时候就在方法栈上面落上一个方法块(栈帧)，方法调用结束的时候销毁栈帧，控制权交给上一个方法。然后循环往复</li>
</ul>
<h3 id="while和-do-while"><a href="#while和-do-while" class="headerlink" title="while和 do while"></a>while和 do while</h3><p>死循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(true)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>do while </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">while(i &lt;100)&#123;</span><br><span class="line">    i+=1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int j =0;</span><br><span class="line">do&#123;</span><br><span class="line">    System.out.println(i)</span><br><span class="line">    j++;</span><br><span class="line">&#125;while(j&gt;0);</span><br></pre></td></tr></table></figure>
<h3 id="for-和-foreach循环"><a href="#for-和-foreach循环" class="headerlink" title="for 和 foreach循环"></a>for 和 foreach循环</h3><ul>
<li>for循环</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;100;i++)&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>foreach循环(不是java独有的)  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 冒号后面的对象必须实现了  Iterable 接口</span><br><span class="line">for(String e:Iterable&lt;String&gt;)&#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>foreach</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(&quot;1&quot;,&quot;2&quot;);</span><br><span class="line">for(String e:list)&#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a>break 和 continue</h3><ul>
<li>break 立刻结束包裹当前 break 的第一层循环</li>
<li>continue 跳过包裹当前 continue 的第一层循环中的语句，继续下一次循环</li>
<li>break label;</li>
</ul>
<blockquote>
<p>远古黑魔法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    // 这样写是声明了一个 label</span><br><span class="line">    http://google.com </span><br><span class="line">    i++; // label后面必须有一个语句 否则报错</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">～～～～～～～～～～～～～～～～～～～～～～～～～～</span><br><span class="line">// 另一种用法</span><br><span class="line">最外层循环:</span><br><span class="line">for(int i=0;i&lt;100;i++)&#123;</span><br><span class="line">    for(int j=0;j&lt;100;j++)&#123;</span><br><span class="line">        break 最外层循环;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>goto 上古时代控制程序流程的方式</p>
</blockquote>
<ul>
<li>java保留字，不能使用的关键字</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 其他语言 如 C</span><br><span class="line">label:</span><br><span class="line">if(i&lt;100)&#123;</span><br><span class="line">    i++;</span><br><span class="line">    goto label;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><blockquote>
<p>在java中只有三种东西可 switch</p>
<ul>
<li>int/long/char/byte/short</li>
<li>enum</li>
<li>String(JDK7 2011年)</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int i = new Random().nextInt(5);</span><br><span class="line">switch(i)&#123;</span><br><span class="line">    case 0:</span><br><span class="line">        xxx;</span><br><span class="line">        break;</span><br><span class="line">    case 1:</span><br><span class="line">        xxx;</span><br><span class="line">        break;</span><br><span class="line">    case 2:</span><br><span class="line">        xxx;</span><br><span class="line">        break;</span><br><span class="line">    case 3:</span><br><span class="line">        xxx;</span><br><span class="line">        break;</span><br><span class="line">    case 4:</span><br><span class="line">        xxx;</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        xxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>switch 可以贯穿</p>
</blockquote>
<blockquote>
<p>swich的作用域</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int i = new Random().nextInt(5);</span><br><span class="line">switch(i)&#123;</span><br><span class="line">    case 0:</span><br><span class="line">    case 1:</span><br><span class="line">    case 2:&#123;</span><br><span class="line">        String s = &quot;A&quot;;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    case 3:&#123;</span><br><span class="line">        String s = &quot;A&quot;;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    default:</span><br><span class="line">        xxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/oak/">oak</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/07/02/ZB-008-java运算系统/" title="ZB-008-java运算系统" itemprop="url">ZB-008-java运算系统</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Stevin" target="_blank" itemprop="author">Stevin</a>
		
  <p class="article-time">
    <time datetime="2019-07-02T13:45:57.000Z" itemprop="datePublished"> Published 2019-07-02</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+</span><br><span class="line">- </span><br><span class="line">*</span><br><span class="line">/</span><br><span class="line">% 取余  取余运算是带符号运算</span><br><span class="line"></span><br><span class="line">+=</span><br><span class="line">-=</span><br><span class="line">*=</span><br><span class="line">/=</span><br><span class="line">%=</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int a = 1 + 1; // int</span><br><span class="line">int b = 5 / 2; // int</span><br><span class="line"></span><br><span class="line">5.0/2; double</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 是否是奇数</span><br><span class="line">public static boolean isOdd(int n)&#123;</span><br><span class="line">    reutrn n % 2 !=0; </span><br><span class="line">    // n % 2 == 1; 取余是带符号运算</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自增自减"><a href="#自增自减" class="headerlink" title="自增自减"></a>自增自减</h3><ul>
<li><code>++</code></li>
<li><code>--</code></li>
</ul>
<p><code>i++</code> 和 <code>++i</code> 不一样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">int b = 0;</span><br><span class="line"></span><br><span class="line">System.out.println(a++); // 0</span><br><span class="line">System.out.println(++b); // 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a++ 分两步</span><br><span class="line">1. a = 0 作为表达式的值</span><br><span class="line">2. a = a + 1 </span><br><span class="line"></span><br><span class="line">++b 分两步</span><br><span class="line">1. a = a + 1 作为表达式的值</span><br><span class="line">2. 把结果作为表达式的值</span><br></pre></td></tr></table></figure>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><ul>
<li><code>&gt;</code></li>
<li><code>&lt;</code></li>
<li><code>&gt;=</code></li>
<li><code>&lt;=</code></li>
<li><code>==</code></li>
<li><code>!=</code></li>
</ul>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul>
<li><code>&amp;&amp;</code> 与</li>
<li><code>||</code> 或</li>
<li><code>!</code> 非</li>
<li>短路特性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Boolean b = ?</span><br><span class="line"></span><br><span class="line">// 1 true =&gt; ture</span><br><span class="line">// 2 false =&gt; false</span><br><span class="line">// 3 null =&gt; false</span><br><span class="line"></span><br><span class="line">// 使用短路特性，如果不是 b = null的时候报错 空指针</span><br><span class="line">if( b != null &amp;&amp; b)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三元运算"><a href="#三元运算" class="headerlink" title="三元运算"></a>三元运算</h3><ul>
<li><code>?:</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = 3;</span><br><span class="line">int res = a &gt; 3 ? 1: -1;</span><br></pre></td></tr></table></figure>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><ul>
<li><code>~</code>按位取反</li>
<li><code>&amp; &amp;=</code> 按位与</li>
<li><code>| |=</code> 按位或</li>
<li><code>^ ^=</code> 异或</li>
<li><code>&lt;&lt; &lt;&lt;=</code> 带符号左移</li>
<li><code>&gt;&gt; &gt;&gt;=</code> 带符号右移</li>
<li><code>&gt;&gt;&gt; &gt;&gt;&gt;=</code> 无符号右移(总是补0)</li>
</ul>
<blockquote>
<p>取反</p>
</blockquote>
<p>计算机中 <strong>负数使用 补码表示的</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int a = 3;</span><br><span class="line">存在计算机里是 32位 4字节</span><br><span class="line">00000000 00000000 00000000 00000011</span><br><span class="line"></span><br><span class="line">~a 得到什么？ -4 为啥</span><br><span class="line"></span><br><span class="line">补码 ===&gt; 按位取反</span><br><span class="line">0000 0011 数字3</span><br><span class="line">第一步 按位取反</span><br><span class="line">1111 1100</span><br><span class="line">第二步 补码 = 反码+1</span><br><span class="line">1111 1101 得到数字-3</span><br><span class="line"></span><br><span class="line">如果首位为“符号位” 那么</span><br><span class="line">00000011 是数字 3</span><br><span class="line">10000011 是数字 -3</span><br><span class="line"></span><br><span class="line">如果是无符号就要用到补码了</span><br></pre></td></tr></table></figure>
<h3 id="烧脑的来了"><a href="#烧脑的来了" class="headerlink" title="烧脑的来了"></a>烧脑的来了</h3><p><code>+ - * /</code> 是在电脑中的 <strong>CPU</strong> 负责运算的，是一种硬件电路</p>
<ul>
<li><p>对于基本的运算 <code>+ -</code> 我们能不能统一为一种电路</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">就是一种 加法 的运算 既可以处理 &quot;+&quot; 也可以处理 “-”</span><br></pre></td></tr></table></figure>
</li>
<li><p>这种背景下</p>
</li>
<li>补码出现了</li>
</ul>
<blockquote>
<p>例子 5 - 3 </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">5 - 3 等价于 5 + (-3)</span><br><span class="line"></span><br><span class="line">这样就可以用 “加法” 来完成  5 - 3 的运算</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5 的二进制表示</span><br><span class="line">0000 0101</span><br><span class="line"></span><br><span class="line">3 的二进制表示</span><br><span class="line">0000 0011</span><br><span class="line"></span><br><span class="line">-3 的二进制表示 </span><br><span class="line">0000 0011 数字 3 取反 </span><br><span class="line">1111 1100 反码  计算机里代表 -4</span><br><span class="line">1111 1101 补码</span><br><span class="line"></span><br><span class="line">5 + (-3)</span><br><span class="line">    0000 0101</span><br><span class="line">    1111 1101</span><br><span class="line">-------------</span><br><span class="line">    0000 0010</span><br></pre></td></tr></table></figure>
<h3 id="amp-amp-按位与-按位或"><a href="#amp-amp-按位与-按位或" class="headerlink" title="&amp; &amp;= 按位与| |= 按位或"></a><code>&amp; &amp;=</code> 按位与<code>| |=</code> 按位或</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">3 按位与 5</span><br><span class="line"></span><br><span class="line">0000 0011 =&gt; 5</span><br><span class="line">0000 0101 =&gt; 3</span><br><span class="line">————————————</span><br><span class="line">0000 0001 =&gt; 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6 按位或 8</span><br><span class="line"></span><br><span class="line">0000 0110 =&gt; 6</span><br><span class="line">0000 1000 =&gt; 8</span><br><span class="line">————————————</span><br><span class="line">0000 1110 =&gt; E</span><br></pre></td></tr></table></figure>
<h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">5 异或 7</span><br><span class="line">0000 0101 =&gt; 5</span><br><span class="line">0000 0111 =&gt; 7</span><br><span class="line">_____________</span><br><span class="line">0000 0010 =&gt; 2</span><br><span class="line"></span><br><span class="line">不进位加法</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="NB的异或公式"><a href="#NB的异或公式" class="headerlink" title="NB的异或公式"></a>NB的异或公式</h4></blockquote>
<ul>
<li>用处就是有些算法题可以用来加速计算  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在一个很长的数组里找一个数字 独立存在的数字 答案是 3</span><br><span class="line">[11,22,33,44,12,12,4,3,4] 把所有数字全部异或一次</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x ^ y ^ y = x</span><br><span class="line"></span><br><span class="line">x ^ x = 0</span><br></pre></td></tr></table></figure>
<h3 id="左移-lt-lt"><a href="#左移-lt-lt" class="headerlink" title="左移&lt;&lt;"></a>左移<code>&lt;&lt;</code></h3><ul>
<li>左移的好处就是比乘法操作快</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">数字 5</span><br><span class="line">0000 0101</span><br><span class="line">&lt;&lt;</span><br><span class="line">0000 1010 得到 10 </span><br><span class="line"></span><br><span class="line">每左移一位 实际就是 *2</span><br><span class="line"></span><br><span class="line">5左移1位 ==&gt; 5*2 = 10</span><br><span class="line">5左移2位 ==&gt; 5*4 = 20</span><br></pre></td></tr></table></figure>
<h3 id="右移-gt-gt"><a href="#右移-gt-gt" class="headerlink" title="右移 &gt;&gt;"></a>右移 <code>&gt;&gt;</code></h3><ul>
<li>带符号   首位补 原先的符号位</li>
<li>不带符号 首位补0</li>
</ul>
<h3 id="位运算的场景"><a href="#位运算的场景" class="headerlink" title="位运算的场景"></a>位运算的场景</h3><ul>
<li><code>Modifier类</code></li>
</ul>
<blockquote>
<p>假设你有猫的 <strong>32个boole      an值属性</strong> 萌不萌 胖不胖</p>
</blockquote>
<ul>
<li>第一种方式 存放32个 boolean 成员属性，这样导致每个布尔值(1字节)占据 32字节</li>
<li>另一种选择：<strong>一个int是 32位01组成,每位代表之前的boolean属性</strong> 这样 从32个字节 变成了 4字节</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Cat&#123;</span><br><span class="line">    public static final int 萌不萌 = 0x00000001;</span><br><span class="line">    public static final int 胖不胖 = 0x00000002;</span><br><span class="line">    public static final int 爱吃鱼 = 0x00000004;</span><br><span class="line">    public static final int 爱老鼠 = 0x00000008;</span><br><span class="line">    // 等等... </span><br><span class="line"></span><br><span class="line">    public static int final state = </span><br><span class="line">    Cat.萌不萌 | Cat.胖不胖 | Cat.爱吃鱼 | Cat.爱老鼠;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">0x00000001 =&gt; 16进制最后一位换成4位2进制数 0001 萌不萌</span><br><span class="line">0x00000002 =&gt; 16进制最后一位换成4位2进制数 0010 胖不胖</span><br><span class="line">0x00000004 =&gt; 16进制最后一位换成4位2进制数 0100 爱吃鱼</span><br><span class="line">0x00000008 =&gt; 16进制最后一位换成4位2进制数 1000 爱老鼠</span><br><span class="line"></span><br><span class="line">正好 每个位置的 “ 1 ”  都是错开的</span><br><span class="line"></span><br><span class="line">此时设置属性的时候只要 “与” </span><br><span class="line">public static int final state = </span><br><span class="line">    Cat.萌不萌 | Cat.胖不胖 | Cat.爱吃鱼 | Cat.爱老鼠;</span><br><span class="line">// 按位与之后得到 0000 1111</span><br><span class="line"></span><br><span class="line">那么我们如何知道 Cat 萌不萌 呢？</span><br><span class="line">只需要它让一个定义好的数字 &amp; 运算就行了</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>设置值时候使用 按位或 ｜</strong></li>
<li><strong>取值值时候使用 按位与 &amp;</strong></li>
</ul>
<blockquote>
<p>参考练习题</p>
</blockquote>
<ul>
<li><a href="https://github.com/hcsp/bit-operation-setter-getter" target="_blank" rel="noopener">https://github.com/hcsp/bit-operation-setter-getter</a></li>
</ul>
<h3 id="字符串加法操作"><a href="#字符串加法操作" class="headerlink" title="字符串加法操作"></a>字符串加法操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">int b = 2;</span><br><span class="line">System.out.println(&quot;a=&quot; + a + &quot;,b=&quot; + b);</span><br><span class="line"></span><br><span class="line">// 你可以给 StringBuilder 打断点，因为字符串是不可变字符序列，所以 频繁拼接很浪费空间，于是会使用 StringBuilder 对一块内存进行操作</span><br></pre></td></tr></table></figure>
<ul>
<li>当你进行字符串加法的时候：它会调用这个对象的 toString, (a.toString(),b.toString())</li>
<li>然后在你进行很长的字符串加法时候，JDK内部会自动的帮你转化成 StringBuilder 调用，减轻内存压力，提高性能。</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/oak/">oak</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/07/01/ZB-007-java数据类型/" title="ZB-007-java数据类型" itemprop="url">ZB-007-java数据类型</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Stevin" target="_blank" itemprop="author">Stevin</a>
		
  <p class="article-time">
    <time datetime="2019-07-01T14:30:28.000Z" itemprop="datePublished"> Published 2019-07-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li><p>int 4字节 (4bytes 32bit)</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">int b = 011; //8进制</span><br><span class="line">int c = 0x11; // 16进制</span><br></pre></td></tr></table></figure>
</li>
<li><p>char 2字节</p>
</li>
<li>short 2字节</li>
</ul>
<h3 id="原生数据类型和引用数据类型"><a href="#原生数据类型和引用数据类型" class="headerlink" title="原生数据类型和引用数据类型"></a>原生数据类型和引用数据类型</h3><table>
<thead>
<tr>
<th>原生</th>
<th>引用</th>
</tr>
</thead>
<tbody>
<tr>
<td>int a= 1</td>
<td>String s = “a”</td>
</tr>
<tr>
<td>4字节存放 1这个值</td>
<td>假设 地址值：1234 存放 字符串”a”</td>
</tr>
</tbody>
</table>
<ul>
<li>只要能找到对应的类，就是引用数据类型</li>
<li>否则是原生数据类型</li>
</ul>
<blockquote>
<h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4></blockquote>
<ul>
<li>byte  1字节</li>
<li>short 2字节</li>
<li>int 4字节（最大21亿）<br>  <strong>针对淘宝这种亿级用户最好不要用int使用 long</strong></li>
<li>long 8字节</li>
<li>float 4字节</li>
<li>double 8字节</li>
<li>char 2字节</li>
<li>boolean true/false</li>
<li>void? 不返回任何类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">byte b = (byte)128; // 会丢失精度</span><br><span class="line">long c = 22_0000_0000L; // 不推荐用 &quot;l&quot; 与 “1” 容易歧义</span><br><span class="line">float d = 0.1f;</span><br><span class="line">double e = 2e-3; //科学计数法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// </span><br><span class="line">int f = 0x123;  // 十六进制</span><br><span class="line">int g = 0b1010101; // 二进制， java7之后出现的</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果你想知道原生数据类型的最大最小值是什么？</p>
</blockquote>
<ul>
<li>每一个原生数据类型对应一个装箱数据类型</li>
<li>对应的装箱数据类型里有两个常量 MIN_VALUE/MAX_VALUE</li>
</ul>
<blockquote>
<p>问题来了？如果强行存储超过范围的值会怎么样？</p>
</blockquote>
<ul>
<li>会溢出</li>
</ul>
<blockquote>
<p>浮点数是小数，在计算机中是<strong>近似表示</strong></p>
</blockquote>
<ul>
<li>浮点数只能比较大小，不要比较“<strong>相等</strong>”</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// </span><br><span class="line">float i = 0.1f;</span><br><span class="line">if(i==0.1f)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double d = 0.2;</span><br><span class="line">if(Math.abs(d - 0.2) &lt; 0.000001)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ol>
<li>整数除法是地板除</li>
<li><p>将所有类型提升到最⾼精度进⾏计算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i = 1 + 1; // ok</span><br><span class="line">int b = 1 + 1.0;// not ,因为 1.0是双精度所以 类型都被提升了， 所以 结果是 double 值 需要强制类型转化 </span><br><span class="line">int c = (int)(1 + 1.0); // ok</span><br></pre></td></tr></table></figure>
</li>
<li><p>丢失精度时需要进⾏强制转换</p>
</li>
<li>char参与计算时使⽤ASCII码（Unicode码） <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char c1 = &apos;a&apos;;</span><br><span class="line">char c2 = &apos;A&apos;;</span><br><span class="line">char c3 = &apos;你&apos;;</span><br><span class="line"></span><br><span class="line">char c4 = &apos;1&apos;; // 对应ASC码 为 49</span><br><span class="line">// c4 = c4 + 1; // 报错因为 + 1 是和 int值进行计</span><br><span class="line">算 必须进行强制转换</span><br><span class="line">c4 = (char)(c4 + 1); // c4的值是49 ,49+1 =50 ，50对应的字符是 &apos;2&apos;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p>自动转换</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte b = 100;</span><br><span class="line">int i = b; // 可以直接转换</span><br></pre></td></tr></table></figure>
</li>
<li><p>强制转换</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i = 200;</span><br><span class="line">byte b = (byte) i; // 因为已经溢出了，所以要强制转换</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<h3 id="整数除法计算是-地板除-向下取整"><a href="#整数除法计算是-地板除-向下取整" class="headerlink" title="整数除法计算是 地板除(向下取整)"></a>整数除法计算是 地板除(向下取整)</h3></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int a = 3;</span><br><span class="line">int b = 2;</span><br><span class="line">int c = a / b; // 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 因为设置了返回值是 double 所以 result 会自动提升为 double</span><br><span class="line">public static double divide(int a ,int b)&#123;</span><br><span class="line">    int result = a / b;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">divide(3,2) //  1.0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>精度问题,<strong>所有表达式中，参与计算的表达式都会提升到最高的精度进行计算，最后的结果也是最高精度</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i = 1 + 1; // 没问题</span><br><span class="line"></span><br><span class="line">// int i2 = 1 + 1.0; // 有问题 与浮点数计算会变成double</span><br><span class="line">// 只能这样 强制转换</span><br><span class="line">int i2 = (int)(1 + 1.0);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解决整型地板除损失精度问题</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static double divide(int a ,int b)&#123;</span><br><span class="line">    double result = 1.0 * a / b;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line"></span><br><span class="line">public static double divide(int a ,int b)&#123;</span><br><span class="line">    double result = (double)a / b;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="void-类型"><a href="#void-类型" class="headerlink" title="void 类型"></a>void 类型</h4></blockquote>
<ul>
<li>所有的类型可以  类型.class 得到它的 class值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class c = String.class;</span><br><span class="line">Class intCLass = int.class;</span><br><span class="line">Class voidCLass = void.class;</span><br></pre></td></tr></table></figure>
<h3 id="装箱类型-引用类型"><a href="#装箱类型-引用类型" class="headerlink" title="装箱类型(引用类型)"></a>装箱类型(引用类型)</h3><ul>
<li>Byte(byte)</li>
<li>Short(short)</li>
<li>Integer(int)</li>
<li>Long(long)</li>
<li>Float(float)</li>
<li>Double(double)</li>
<li>Character(char)</li>
<li>Boolean(boolean)</li>
<li>Void?(void)</li>
</ul>
<p>任何原生数据类型都有对应的装箱类型</p>
<blockquote>
<p>自动装箱/自动拆箱</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static int add(int i)&#123; return new Integer(i);&#125;</span><br><span class="line"></span><br><span class="line">int i = 100;</span><br><span class="line">Integer integer = i; // 自动装箱</span><br><span class="line">add(integer); // 自动装箱</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么要有装箱类型</p>
<ul>
<li>容器类不接受原⽣数据类型  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// List里只接受引用类型，不接受原生类型</span><br><span class="line">List&lt;Integer&gt; a = new ArrayList&lt;&gt;();</span><br><span class="line">a.add(1);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<ul>
<li><p>可以赋值为null</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// boolean 只能有两种状态 true/false</span><br><span class="line"></span><br><span class="line">// 而装箱类型还有第三种状态 true/false/null</span><br><span class="line">Boolean state = null;</span><br></pre></td></tr></table></figure>
</li>
<li><p>提供额外的⽅法</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;123&quot;;</span><br><span class="line">// 内存中对应 是一个 char[] 数组 </span><br><span class="line"></span><br><span class="line">// 而数字 内存中 4字节 01组成的序列</span><br><span class="line">int i = 123; //</span><br></pre></td></tr></table></figure>
</li>
<li><p>⾃动装箱与拆箱</p>
</li>
</ul>
<h3 id="原⽣类型与引⽤类型带来的坑"><a href="#原⽣类型与引⽤类型带来的坑" class="headerlink" title="原⽣类型与引⽤类型带来的坑"></a>原⽣类型与引⽤类型带来的坑</h3><ul>
<li><p>对null拆箱将引发空指针异常</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer a = null;</span><br><span class="line">int i = a;// 空指针异常</span><br></pre></td></tr></table></figure>
</li>
<li><p>==与equals约定</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int a = 5;</span><br><span class="line">int b = 5;</span><br><span class="line">a == b // true</span><br><span class="line"></span><br><span class="line">Integer c = 1000; // 假设内存地址 512</span><br><span class="line">Integer d = 1000; // 假设内存地址 600</span><br><span class="line">c == d // false 因为 “==“ 比较的是值，而引用类型的值是 ”地址“  512 != 600</span><br><span class="line"></span><br><span class="line">c.equals(d) // true</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>“==” </p>
</blockquote>
<p>比较二者是否相同</p>
<blockquote>
<p>“equals()”</p>
</blockquote>
<p>比较二者是否是不是相等</p>
<ul>
<li><h4 id="让你惊讶的地方！！！"><a href="#让你惊讶的地方！！！" class="headerlink" title="让你惊讶的地方！！！"></a>让你惊讶的地方！！！</h4></li>
<li><h4 id="让你惊讶的地方！！！-1"><a href="#让你惊讶的地方！！！-1" class="headerlink" title="让你惊讶的地方！！！"></a>让你惊讶的地方！！！</h4></li>
<li><h4 id="让你惊讶的地方！！！-2"><a href="#让你惊讶的地方！！！-2" class="headerlink" title="让你惊讶的地方！！！"></a>让你惊讶的地方！！！</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Integer e = 1;</span><br><span class="line">Integer f = 1;</span><br><span class="line"></span><br><span class="line">e == f // true 竟然相等了？ </span><br><span class="line">e.equals(f) // true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int类型是占据 4字节的空间，</span><br><span class="line">而 Object / Integer 这类引用数据类型 远比int占据的空间要多</span><br><span class="line"></span><br><span class="line">如果你频繁 </span><br><span class="line">Ingeter i = 1;  // 占据空间远远大于4字节</span><br><span class="line">Ingeter b = 2;  // 占据空间远远大于4字节</span><br><span class="line"></span><br><span class="line">所以java偷偷做了一件事</span><br><span class="line">对于非常小的数字则认为是常用的数字。</span><br><span class="line">则对其进行缓存 具体参考 IntegerCache的文档</span><br><span class="line">会对 -128～+127的 数字进行缓存，而不是重新创建对象</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><blockquote>
<p>由JDK负责创建的特殊类型</p>
</blockquote>
<ul>
<li><code>X[] x = new X[10]</code> 长度为10的数组</li>
<li><code>X[] x = new X[]{5,4,3,2,1}</code> 长度为5的数组</li>
<li><code>X[] x = {5,4,3,2,1}</code></li>
<li>其中 X 也可以是数组类型   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[][] c = new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>数组的主要特性</p>
</blockquote>
<ul>
<li>长度不可变</li>
<li>类型安全 <code>String[] c = {&quot;a&quot;,&quot;b&quot;}; // 声明了是 String 就不能丢其他类型的东西</code></li>
<li>只有一个 length 属性</li>
<li>可以用下标去取对应元素 <code>a[1]</code></li>
<li>可以使用 for 循环</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/oak/">oak</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/07/01/ZB-006-工具使用/" title="ZB-006-工具使用" itemprop="url">ZB-006-工具使用</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Stevin" target="_blank" itemprop="author">Stevin</a>
		
  <p class="article-time">
    <time datetime="2019-07-01T13:50:31.000Z" itemprop="datePublished"> Published 2019-07-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h3><ul>
<li>提供一个生命周期流程</li>
<li>每个插件可以把一小部分工作绑定到生命周期上</li>
<li>maven本身对这些事不做任何干涉，只定义生命周期</li>
<li>maven 每个阶段执行时都会把前面的每个阶段执行一遍</li>
<li><a href="https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html" target="_blank" rel="noopener">maven default lifecycle</a></li>
</ul>
<blockquote>
<p>参考资料</p>
</blockquote>
<ul>
<li><a href="https://github.com/slTrust/javaweb/tree/master/web012maven%E4%BD%BF%E7%94%A8" target="_blank" rel="noopener">https://github.com/slTrust/javaweb/tree/master/web012maven%E4%BD%BF%E7%94%A8</a></li>
</ul>
<blockquote>
<p>maven依赖的问题——传递性依赖</p>
</blockquote>
<ul>
<li>你的项目依赖多个库 A、B、C</li>
<li>而这个库A又依赖别的库 如C</li>
<li>此时 多个地方依赖 C C的版本如果不一致就会有问题</li>
</ul>
<blockquote>
<p>maven显示依赖树</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn dependency:tree</span><br></pre></td></tr></table></figure>
<h3 id="IDEA生产力翻倍的快捷键"><a href="#IDEA生产力翻倍的快捷键" class="headerlink" title="IDEA生产力翻倍的快捷键"></a>IDEA生产力翻倍的快捷键</h3><ul>
<li>万能键 ALT + ENTER 任何情况都可以使用</li>
<li>左侧项目结构面板右上角有个按钮 Scroll from Source 从源代码跳转</li>
<li>Search  everywhere: 双击 shift</li>
<li>查看定义：Declaration </li>
<li>查看⽂件：Navigate - File</li>
<li><strong>⾼级查找</strong>：Find in Path (顶栏Edit-Find-Find in Path) 几乎满足你查找的所有需求</li>
<li>快速⽣成：Generate(Command N)</li>
<li>格式化：Reformat Code</li>
<li>优化导⼊语句：Optimize imports<ul>
<li>比如你代码里开始用了 ArrayList,后来不用了，但是会被导入，这个时候用这个</li>
</ul>
</li>
<li>导航：Navigate - Back/Forward</li>
<li>谁调⽤了这个⽅法：Call Hierarchy</li>
<li>所有的实现类：Implementation</li>
<li>⽂件⼤纲：File Structure<ul>
<li>列出这个类的所有方法，成员</li>
</ul>
</li>
<li>下⼀处错误：Next Highlighted Error</li>
<li>⾼级重命名：Rename</li>
<li>调试器快捷键：F5/F6/F7/F8</li>
</ul>
<h3 id="Git相关操作"><a href="#Git相关操作" class="headerlink" title="Git相关操作"></a>Git相关操作</h3><ul>
<li>查找背锅侠：Annotate/Blame</li>
<li>查看当前⽂件的历史版本</li>
<li>⾼级筛选⽅式查找commit记录</li>
<li>显示差异：show diff</li>
<li>Open in GitHub (选中你的代码 右键列表里)</li>
</ul>
<blockquote>
<h4 id="底部工具栏-Version-Control"><a href="#底部工具栏-Version-Control" class="headerlink" title="底部工具栏 Version Control"></a>底部工具栏 Version Control</h4></blockquote>
<ul>
<li>Local Changes 等同于 git status 本地的变更还没有提交</li>
<li>Log 这个仓库里所有的日志</li>
</ul>
<h4 id="编程快捷键"><a href="#编程快捷键" class="headerlink" title="编程快捷键"></a>编程快捷键</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">psvm ==&gt; public static void main()&#123;&#125;</span><br><span class="line"></span><br><span class="line">sout ==&gt; System.out.println()</span><br><span class="line"></span><br><span class="line">fori ==&gt; for(int i = 0 ; i &lt; ;i++)</span><br><span class="line"></span><br><span class="line">fore ==&gt; ...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>寻找配对括号的小插件</p>
</blockquote>
<ul>
<li>Rainbow Brackets</li>
</ul>
<h3 id="调试器：没有解决不了的问题"><a href="#调试器：没有解决不了的问题" class="headerlink" title="调试器：没有解决不了的问题"></a>调试器：没有解决不了的问题</h3><blockquote>
<p>为什么需要调试器</p>
<ul>
<li>理解程序执⾏的过程</li>
<li>理解JVM的内部构造</li>
<li>⾮常⽅便的检查在任意时间点JVM的内部状态</li>
</ul>
</blockquote>
<blockquote>
<h4 id="调试器"><a href="#调试器" class="headerlink" title="调试器"></a>调试器</h4></blockquote>
<ul>
<li>单步跳过  ,Step over 执行一行,无论当前行的语句有多么的复杂。</li>
<li>单步进⼊  , Step into 执行一个语句。进入这个方法的执行(最详细的方法执行)。</li>
<li>单步跳出</li>
<li>全速运⾏ Resume Program （F8）恢复程序，当前的程序全速跑到下一个断点</li>
<li>断点（⾯板）</li>
<li>条件断点 (所在行设置断点，点击右键弹出一个框 Condition 输入 i==5000 当i=5000的时候)</li>
<li>跳转到源代码</li>
<li>Watch</li>
</ul>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ul>
<li>堆 所有对象都在堆上分配</li>
<li>栈 (假设现在只有一个线程。每个线程有一个方法栈。方法的入口就是main方法。每次调用一个方法就会压栈，方法结束就会出栈)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        a();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void a() &#123;</span><br><span class="line">        System.out.println(&quot;a&quot;);</span><br><span class="line">        b();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void b() &#123;</span><br><span class="line">        System.out.println(&quot;b&quot;);</span><br><span class="line">        c();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void c() &#123;</span><br><span class="line">        int x = 1;</span><br><span class="line">        System.out.println(&quot;c&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数一次一次调用形成的方法块叫什么</p>
</blockquote>
<ul>
<li>栈帧</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c执行结束 它里面的局部变量x会被销毁</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="执行表达式"><a href="#执行表达式" class="headerlink" title="执行表达式"></a>执行表达式</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">打断点后，选中所在行右键选择Evaluate Expression</span><br><span class="line"></span><br><span class="line">输入框里可写任意代码</span><br></pre></td></tr></table></figure>
<blockquote>
<p>鬼畜的用法，打破流程,不推荐用</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return result; // 右键， View/Edit Text 修改为你要返回的内容</span><br></pre></td></tr></table></figure>
<h3 id="调试器的原理"><a href="#调试器的原理" class="headerlink" title="调试器的原理"></a>调试器的原理</h3><ul>
<li>调试⾮项⽬源代码</li>
<li>调试命令⾏程序</li>
</ul>
<h4 id="调试-mvn-compile-过程的代码"><a href="#调试-mvn-compile-过程的代码" class="headerlink" title="调试 mvn compile 过程的代码"></a>调试 mvn compile 过程的代码</h4><ul>
<li>你想调试什么东西，首先要拿到这个东西的源代码</li>
<li>比如调试 mvn compile，本质也是一个JVM</li>
<li><a href="https://github.com/apache/maven-compiler-plugin" target="_blank" rel="noopener">google 搜索maven compiler plugin github</a> 把代码clone到本地</li>
<li>mvn 除了这个命令，还有一个调试版的命令 mvnDebug</li>
<li>你可以这样运行 <code>/Users/hjx/maven/apache-maven-3.6.3/bin/mvnDebug compile</code>  这就是 debug模式运行 mvn</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 1。 找到你本地 mvn的 debug模式命令</span><br><span class="line">&gt; /Users/hjx/maven/apache-maven-3.6.2/bin/</span><br><span class="line">mvnDebug compile</span><br><span class="line"></span><br><span class="line"># 2。 debug 模式运行 mvn,监听在 8000端口</span><br><span class="line">Preparing to execute Maven in debug mode</span><br><span class="line">Listening for transport dt_socket at address: 8000</span><br><span class="line"></span><br><span class="line"># 3。 此时在 IDEA里 编辑器右边顶部 的 add Configuration 里 “加号 + ”选择 Remote ，Port填入 8000，然后 ok</span><br><span class="line">    # 为什么是 Remote 这个过程不仅可以发生在你本地，还可以发生在你的生产服务器</span><br><span class="line"># 然后在 mvn compile 源代码的 CompilerMojo 里 skipMain 这行 176</span><br><span class="line"></span><br><span class="line"># 4。 然后 debug模式运行，你发现代码没有停在这里，不要开始怀疑人生， 要看你本地的 mvn版本 和代码的版本是否是一个版本</span><br><span class="line"></span><br><span class="line"># 5。 源代码终端输入 git tag 找到跟你本地一致的版本号 如 3.6.2</span><br><span class="line"></span><br><span class="line"># 6。 切换本地代码版本 </span><br><span class="line">git checkout maven-compiler-plugin-3.6.2</span><br><span class="line"></span><br><span class="line"># 7。 在此 debug运行代码</span><br><span class="line"></span><br><span class="line">此时你就可以调试 mvn compile 了</span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/oak/">oak</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/06/30/ZB-005-JAVA基本结构/" title="ZB-005-JAVA基本结构" itemprop="url">ZB-005-JAVA基本结构</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Stevin" target="_blank" itemprop="author">Stevin</a>
		
  <p class="article-time">
    <time datetime="2019-06-30T12:22:40.000Z" itemprop="datePublished"> Published 2019-06-30</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="JAVA介绍"><a href="#JAVA介绍" class="headerlink" title="JAVA介绍"></a>JAVA介绍</h3><ol>
<li>强类型</li>
<li>静态编译</li>
<li>跨平台</li>
</ol>
<blockquote>
<p>代码比较死板，但是非常适合团队协作项目。</p>
</blockquote>
<ul>
<li><a href="https://www.zhihu.com/question/56468869/answer/261050848" target="_blank" rel="noopener">如何看待知乎、饿了么后端的招聘纷纷由 Python 渐渐转向 Java？ - 曲奇的回答 - 知乎</a></li>
<li>当你的代码足够庞大时</li>
<li>比如 TS的兴起就是 类型约束和静态编译</li>
</ul>
<blockquote>
<p>什么是操作系统</p>
</blockquote>
<p>比如现在有 windows / mac / linux 三个系统，你要让他们做什么比如 打开文件，发请求就要<strong>使用操作系统的语言(API)和操作系统对话</strong></p>
<p>这样就给软件开发者开了一个很大的难题。你开发了一个软件跑在三个系统上。就要用三个系统的API去分别编写。此时工作量变成了三倍！</p>
<blockquote>
<p>举个例子,比如你要写一本书，三个系统好比三个国家。</p>
</blockquote>
<ul>
<li>你使用了某个语言如 英语 English </li>
<li>此时需要去三个国家找到对应懂英语的人。</li>
<li>这样你只要在每个国家找到懂英语的人。你本来是要为每个国家开发一本书。现在你只需要开发一本书，然后让不同平台懂英语的人翻译成对应国家的语言。</li>
</ul>
<p>这个会翻译的人 在JAVA中就叫 JVM 虚拟机</p>
<p><strong>JVM负责与操作系统的接口打交道，此时你只要写一种语言如java,剩下的交给JVM将 java翻译成中间层的语言 byte code(字节码)</strong></p>
<blockquote>
<p>字节码</p>
</blockquote>
<p>二进制，在计算机里只有0和1</p>
<h4 id="java广告词"><a href="#java广告词" class="headerlink" title="java广告词"></a>java广告词</h4><ul>
<li>一次编写，处处运行。</li>
<li>比如现在的服务器通常是linux，而开发者的电脑可能是 windows 。你在Windows代码可以稳定的跑在linux上。这就是java的可贵之处</li>
</ul>
<h3 id="java语言的基本单元-类-和-包"><a href="#java语言的基本单元-类-和-包" class="headerlink" title="java语言的基本单元 类 和 包"></a>java语言的基本单元 类 和 包</h3><p>class</p>
<ul>
<li>java最小的结构是 类</li>
<li>类必须放在与它同名的 <code>.java</code>文件中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 程序最小的结构是 class</span><br><span class="line">// 直接放在 src/main/java下的包叫做 “默认包”</span><br><span class="line">public class Cat&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="package"><a href="#package" class="headerlink" title="package"></a>package</h4><ul>
<li>每个类都处在一个包中</li>
<li>包的名字由目录结构所确定</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 目录结构为: src/main/java/my/cute</span><br><span class="line">package my.cute;</span><br><span class="line">public class Cat&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="推荐包名规则"><a href="#推荐包名规则" class="headerlink" title="推荐包名规则"></a>推荐包名规则</h5><ul>
<li>java程序约定(我不强制你这么做，但我约定你这么做)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 不建议这样</span><br><span class="line">package my.cute;</span><br><span class="line"></span><br><span class="line"># java推荐约定  包名以你互联网公司域名的反序来命名，这样可以避免命名冲突</span><br><span class="line">package com.alibaba</span><br><span class="line">package com.google</span><br></pre></td></tr></table></figure>
<h4 id="maven的项目约定"><a href="#maven的项目约定" class="headerlink" title="maven的项目约定"></a>maven的项目约定</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 生产代码</span><br><span class="line">src/main/java/my/cute/Cat.java</span><br><span class="line"></span><br><span class="line">// 测试代码</span><br><span class="line">src/test/java/my/cute/CatTest.java</span><br></pre></td></tr></table></figure>
<h4 id="包的意义"><a href="#包的意义" class="headerlink" title="包的意义"></a>包的意义</h4><p>如果存在如下两个同名的类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">src/main/java/my/pet/Cat.java</span><br><span class="line">src/main/java/my/pet2/Cat.java</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 如何在 src/main/java/my/Home.java里引用者两个 Cat呢？</span><br><span class="line"></span><br><span class="line">// Home.java</span><br><span class="line">package my;</span><br><span class="line"></span><br><span class="line">import my.pet.Cat;</span><br><span class="line">// import my.pet2.Cat; </span><br><span class="line"></span><br><span class="line">public class Home&#123;</span><br><span class="line">    Cat cat;</span><br><span class="line">    //全限定类名</span><br><span class="line">    my.pet2.Cat cat2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在JVM中所有的类 都会变成“全限定类名” Full Qualified Name (FQCN)  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Home&#123;</span><br><span class="line">    // 最终都会变成</span><br><span class="line">    my.pet.Cat cat;</span><br><span class="line">    my.pet2.Cat cat2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这就是为什么我们需要“包” 最大的作用就是<strong>避免命名冲突，区分同名但不同的类</strong></p>
<blockquote>
<p>main函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Cat&#123;</span><br><span class="line">    // 程序的入口函数</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>疑问为什么<code>String[] args</code> 里的 String不用写包名 ，如果你用的是 IDEA按住 alt点击进去，发现 String的包名是 <code>package java.lang</code></li>
<li>如果你的类放在 java.lang 下 可以不经引入直接使用</li>
</ul>
<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><ul>
<li>在每个函数调用的时候，它会创建一个全新的函数的执行环境</li>
<li>函数多次调用的过程之间，它们是相互独立的。</li>
<li>函数可以被一次声明，然后多次调用，每次调用的执行环境都是独立的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Cat&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        f();</span><br><span class="line">        f();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void f(int i)&#123;</span><br><span class="line">        return i + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><ul>
<li>包围它的第一对花括号<code>{}</code></li>
</ul>
<h4 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h4><p>存在遥远的jvm的一个地方，独立于任何的对象。和任何对象都没关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Cat&#123;</span><br><span class="line">    public static int i; // 默认会初始化为0</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        add();</span><br><span class="line">        add();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void add()&#123;</span><br><span class="line">        i = i + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="对象-构造器和成员变量"><a href="#对象-构造器和成员变量" class="headerlink" title="对象/构造器和成员变量"></a>对象/构造器和成员变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Home&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Cat cat = new Cat();</span><br><span class="line">        cat.name = &quot;阿三&quot;;</span><br><span class="line">        cat.miao();</span><br><span class="line"></span><br><span class="line">        Cat cat2 = new Cat(&quot;阿大&quot;);</span><br><span class="line">        cat2.miao();</span><br><span class="line"></span><br><span class="line">        Cat cat3 = new Cat();</span><br><span class="line">        cat3.miao(); // 空指针 因为name是null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat&#123;</span><br><span class="line">    // 成员变量</span><br><span class="line">    private String name;</span><br><span class="line">    // 假如你没声明任何的构造器 ,编译器会帮你偷偷生产一个构造器</span><br><span class="line">    //  Cat()&#123;&#125; // 你不写就自带一个</span><br><span class="line"></span><br><span class="line">    public Cat()&#123;&#125;</span><br><span class="line">    // 如果你写了其他构造器，将不再提供默认的无参构造器，而你想调用无参的构造器则要自己写。</span><br><span class="line">    public Cat(String name)&#123;</span><br><span class="line">        // this = 刚刚创建的Cat类的实例</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">    public static void miao()&#123;</span><br><span class="line">        // 报错，静态方法不能调用非静态成员</span><br><span class="line">        System.out.println(&quot;喵,我是&quot;+ name)</span><br><span class="line">    &#125;</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    public void miao()&#123;</span><br><span class="line">        System.out.println(&quot;喵,我是&quot;+ name)</span><br><span class="line">        // 在不引起歧义的情况下，你可以 省略 this</span><br><span class="line">        System.out.println(&quot;喵,我是&quot;+ this.name + &quot;我的名字长度是&quot; + name.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实例方法和空指针异常"><a href="#实例方法和空指针异常" class="headerlink" title="实例方法和空指针异常"></a>实例方法和空指针异常</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Home&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Cat cat = new Cat();</span><br><span class="line">        cat.name = &quot;阿三&quot;;</span><br><span class="line">        cat.miao();</span><br><span class="line"></span><br><span class="line">        Cat cat2 = new Cat(&quot;阿大&quot;);</span><br><span class="line">        cat2.miao();</span><br><span class="line"></span><br><span class="line">        Cat cat3 = new Cat();</span><br><span class="line">        cat3.miao(); // 空指针 因为name是null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat&#123;</span><br><span class="line">    String name;</span><br><span class="line">    public Cat()&#123;&#125;</span><br><span class="line">    public Cat(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void miao()&#123;</span><br><span class="line">        // 非空判断 ，规避空指针</span><br><span class="line">        if(name == null)&#123;</span><br><span class="line">            System.out.println(&quot;我还没名字&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            System.out.println(&quot;喵,我是&quot;+ this.name + &quot;我的名字长度是&quot; + name.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对象和引用、值传递"><a href="#对象和引用、值传递" class="headerlink" title="对象和引用、值传递"></a>对象和引用、值传递</h3><ul>
<li>最重要概念之一</li>
<li>画内存图</li>
<li><p>引用</p>
<ul>
<li>addr</li>
<li>门牌号 201/301/333</li>
</ul>
</li>
<li><p><a href="https://sltrust.github.io/2017/11/19/N021_JS%E9%87%8C%E7%9A%84%E7%B1%BB%E5%9E%8B/" target="_blank" rel="noopener">参考之前的JS总结</a></p>
</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/oak/">oak</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/06/30/ZB-004-FQ/" title="ZB-004-FQ" itemprop="url">ZB-004-FQ</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Stevin" target="_blank" itemprop="author">Stevin</a>
		
  <p class="article-time">
    <time datetime="2019-06-30T08:54:56.000Z" itemprop="datePublished"> Published 2019-06-30</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="翻了个墙"><a href="#翻了个墙" class="headerlink" title="翻了个墙"></a>翻了个墙</h3><ul>
<li><a href="https://jscode.me/" target="_blank" rel="noopener">https://jscode.me/</a> 进入搜 翻了个墙</li>
<li><a href="https://jscode.me/t/topic/582" target="_blank" rel="noopener">https://jscode.me/t/topic/582</a></li>
</ul>
<h3 id="chrome自动识别是否翻墙"><a href="#chrome自动识别是否翻墙" class="headerlink" title="chrome自动识别是否翻墙"></a>chrome自动识别是否翻墙</h3><ul>
<li><a href="https://jscode.me/t/topic/751" target="_blank" rel="noopener">https://jscode.me/t/topic/751</a></li>
<li>下载里面的配置文件，然后导入配置，然后应用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">导入配置之后记得，选择自动切换。如果FQ发现失败。</span><br><span class="line"></span><br><span class="line">代理的默认端口是1080，所以理论上不用改。</span><br><span class="line">但是针对你失败有可能是 你小飞机的 socks5端口根 chrome插件的不一样 </span><br><span class="line">就把agent那个里面的端口改成你小飞机里 socks5端口</span><br></pre></td></tr></table></figure>
<h3 id="命令行翻墙"><a href="#命令行翻墙" class="headerlink" title="命令行翻墙"></a>命令行翻墙</h3><p><a href="https://jscode.me/t/topic/789" target="_blank" rel="noopener">https://jscode.me/t/topic/789</a></p>
<ul>
<li><a href="https://jscode.me/t/topic/1141" target="_blank" rel="noopener">mac</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 1 安装 homebrew</span><br><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br><span class="line"></span><br><span class="line"># 2 安装 proxychains-ng</span><br><span class="line">brew install proxychains-ng</span><br><span class="line"></span><br><span class="line"># 3 配置</span><br></pre></td></tr></table></figure>
<blockquote>
<p>配置</p>
</blockquote>
<p>1 新建 <code>~/.proxychains.conf</code> 文件</p>
<p>内容如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">strict_chain</span><br><span class="line">quiet_mode</span><br><span class="line">proxy_dns </span><br><span class="line"></span><br><span class="line">remote_dns_subnet 224</span><br><span class="line">tcp_read_time_out 15000</span><br><span class="line">tcp_connect_time_out 8000</span><br><span class="line">[ProxyList]</span><br><span class="line"># 你的代理 如 ss 我的端口是 1086</span><br><span class="line">socks5 	127.0.0.1 1080</span><br></pre></td></tr></table></figure>
<p>2 第二步 <code>touch ~/.bashrc</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;alias pc=&quot;proxychains4 -f ~/.proxychains.conf&quot;&apos; &gt;&gt; ~/.bashrc source ~/.bashrc&apos;</span><br></pre></td></tr></table></figure>
<p>3 第三步 <code>source ~/.bashrc</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 测试</span><br><span class="line">pc curl -L https://twitter.com/</span><br><span class="line"></span><br><span class="line"># 如果失败 看看你的 mac版本是否是 10.12之后</span><br><span class="line"># 如果是</span><br><span class="line"># 关闭SIP</span><br><span class="line">https://www.jianshu.com/p/fe78d2036192</span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/oak/">oak</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/12/"><span></span>Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/51/">51</a><a class="extend next" rel="next" href="/page/14/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  

  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/oak/" title="oak">oak<sup>71</sup></a></li>
			
		
			
				<li><a href="/tags/前端知识点/" title="前端知识点">前端知识点<sup>43</sup></a></li>
			
		
			
				<li><a href="/tags/java/" title="java">java<sup>37</sup></a></li>
			
		
			
				<li><a href="/tags/Node后端/" title="Node后端">Node后端<sup>34</sup></a></li>
			
		
			
				<li><a href="/tags/M06/" title="M06">M06<sup>29</sup></a></li>
			
		
			
				<li><a href="/tags/fullstack/" title="fullstack">fullstack<sup>27</sup></a></li>
			
		
			
				<li><a href="/tags/M07/" title="M07">M07<sup>27</sup></a></li>
			
		
			
				<li><a href="/tags/python/" title="python">python<sup>26</sup></a></li>
			
		
			
				<li><a href="/tags/M08/" title="M08">M08<sup>25</sup></a></li>
			
		
			
				<li><a href="/tags/M04/" title="M04">M04<sup>22</sup></a></li>
			
		
			
				<li><a href="/tags/M03/" title="M03">M03<sup>20</sup></a></li>
			
		
			
				<li><a href="/tags/M02/" title="M02">M02<sup>17</sup></a></li>
			
		
			
				<li><a href="/tags/React入门/" title="React入门">React入门<sup>17</sup></a></li>
			
		
			
				<li><a href="/tags/ReactWheels/" title="ReactWheels">ReactWheels<sup>16</sup></a></li>
			
		
			
				<li><a href="/tags/TS入门/" title="TS入门">TS入门<sup>16</sup></a></li>
			
		
			
				<li><a href="/tags/CSS/" title="CSS">CSS<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/M01/" title="M01">M01<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/vue/" title="vue">vue<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/ES6速学/" title="ES6速学">ES6速学<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/mongodb/" title="mongodb">mongodb<sup>7</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=&verifier=b3593ceb&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Larry Page in Google. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2176287895" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2020 
		
		<a href="/about" target="_blank" title="Stevin">Stevin</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>












<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
